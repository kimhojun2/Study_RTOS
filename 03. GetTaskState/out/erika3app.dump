
erika3app.elf:     file format elf32-tricore
erika3app.elf
architecture: TriCore:V1_6_1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x80000020

Program Header:
    LOAD off    0x00004020 vaddr 0x80000020 paddr 0x80000020 align 2**14
         filesz 0x0000df18 memsz 0x0000df18 flags r-x
    LOAD off    0x00014000 vaddr 0x70000000 paddr 0x8000df38 align 2**14
         filesz 0x00000930 memsz 0x00000930 flags rw-
    LOAD off    0x00016600 vaddr 0x5001a600 paddr 0x8000e868 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00017700 vaddr 0x5001b700 paddr 0x8000e868 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00016600 vaddr 0x6001a600 paddr 0x8000e868 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00017700 vaddr 0x6001b700 paddr 0x8000e868 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00014930 vaddr 0x70000930 paddr 0x8000e868 align 2**14
         filesz 0x00000000 memsz 0x00000320 flags rw-
    LOAD off    0x00018600 vaddr 0x70018600 paddr 0x8000e868 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00015700 vaddr 0x70019700 paddr 0x8000e868 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00017c00 vaddr 0x5001bc00 paddr 0x8000e880 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x00017c00 vaddr 0x6001bc00 paddr 0x8000e880 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x00015c00 vaddr 0x70019c00 paddr 0x8000e880 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .startup      00000006  80000020  80000020  00004020  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00001090  80000028  80000028  00004028  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .bss          00000320  70000930  8000e868  00014930  2**3
                  ALLOC
  3 .data         00000930  70000000  8000df38  00014000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  4 .traptab      00000100  80001100  80001100  00005100  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .ctors        00000008  80001200  80001200  00005200  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .dtors        00000008  80001208  80001208  00005208  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .inttab_cpu0  00002000  80002000  80002000  00006000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text         00009f38  80004000  80004000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .CPU2.ustack  00001000  5001a600  8000e868  00016600  2**3
                  ALLOC, CPU2
 10 .CPU2.istack  00000400  5001b700  8000e868  00017700  2**3
                  ALLOC, CPU2
 11 .CPU2.csa     00002000  5001bc00  8000e880  00017c00  2**6
                  ALLOC, CPU2
 12 .CPU1.ustack  00001000  6001a600  8000e868  00016600  2**3
                  ALLOC, CPU1
 13 .CPU1.istack  00000400  6001b700  8000e868  00017700  2**3
                  ALLOC, CPU1
 14 .CPU1.csa     00002000  6001bc00  8000e880  00017c00  2**6
                  ALLOC, CPU1
 15 .CPU0.ustack  00001000  70018600  8000e868  00018600  2**3
                  ALLOC, CPU0
 16 .CPU0.istack  00000400  70019700  8000e868  00015700  2**3
                  ALLOC, CPU0
 17 .CPU0.csa     00002000  70019c00  8000e880  00015c00  2**6
                  ALLOC, CPU0
 18 .comment      00000053  00000000  00000000  00014930  2**0
                  CONTENTS, READONLY
 19 .debug_aranges 00000ca8  00000000  00000000  00014988  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_info   000babe4  00000000  00000000  00015630  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_abbrev 0000b685  00000000  00000000  000d0214  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_line   0000d9a0  00000000  00000000  000db899  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_frame  000020e0  00000000  00000000  000e923c  2**2
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_str    00001ecb  00000000  00000000  000eb31c  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_loc    000138a3  00000000  00000000  000ed1e7  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_ranges 000012c8  00000000  00000000  00100a8a  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .version_info 0004c67a  00000000  00000000  00101d52  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
80000020 l    d  .startup	00000000 .startup
80000028 l    d  .rodata	00000000 .rodata
70000930 l    d  .bss	00000000 .bss
70000000 l    d  .data	00000000 .data
80001100 l    d  .traptab	00000000 .traptab
80001200 l    d  .ctors	00000000 .ctors
80001208 l    d  .dtors	00000000 .dtors
80002000 l    d  .inttab_cpu0	00000000 .inttab_cpu0
80004000 l    d  .text	00000000 .text
5001a600 l    d  .CPU2.ustack	00000000 .CPU2.ustack
5001b700 l    d  .CPU2.istack	00000000 .CPU2.istack
5001bc00 l    d  .CPU2.csa	00000000 .CPU2.csa
6001a600 l    d  .CPU1.ustack	00000000 .CPU1.ustack
6001b700 l    d  .CPU1.istack	00000000 .CPU1.istack
6001bc00 l    d  .CPU1.csa	00000000 .CPU1.csa
70018600 l    d  .CPU0.ustack	00000000 .CPU0.ustack
70019700 l    d  .CPU0.istack	00000000 .CPU0.istack
70019c00 l    d  .CPU0.csa	00000000 .CPU0.csa
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .version_info	00000000 .version_info
00000000 l    df *ABS*	00000000 ee_tc_cstart.c
00000000 l    df *ABS*	00000000 asw.c
00000000 l    df *ABS*	00000000 bsw.c
70000000 l     O .data	00000004 c.16159
00000000 l    df *ABS*	00000000 ee_applcfg.c
800000f0 l     O .rodata	0000001c osEE_tdb_ptr_array
800000e4 l     O .rodata	00000004 osEE_res_db_ptr_array
8000010c l     O .rodata	000000e0 osEE_tdb_array
70000028 l     O .data	00000030 osEE_sn_array
800000e8 l     O .rodata	00000008 osEE_res_db_array
70000bec l     O .bss	0000000c osEE_res_cb_array
800001ec l     O .rodata	00000008 osEE_sdb_array
70000bf8 l     O .bss	00000004 osEE_scb_array
70000058 l     O .data	0000008c osEE_tcb_array
00000000 l    df *ABS*	00000000 IfxVadc.c
800001f4 l     O .rodata	00000006 CSWTCH.25
00000000 l    df *ABS*	00000000 IfxVadc_cfg.c
00000000 l    df *ABS*	00000000 IfxAsclin_PinMap.c
00000000 l    df *ABS*	00000000 IfxAsclin_cfg.c
00000000 l    df *ABS*	00000000 IfxPort_cfg.c
00000000 l    df *ABS*	00000000 IfxScuCcu.c
700000e8 l     O .data	00000004 IfxScuCcu_xtalFrequency
80005eac l     F .text	00000034 IfxScuCcu_wait
80000ac8 l     O .rodata	00000024 IfxScuCcu_aDefaultPllConfigSteps
00000000 l    df *ABS*	00000000 IfxScu_PinMap.c
00000000 l    df *ABS*	00000000 IfxVadc_Adc.c
80000d64 l     O .rodata	00000040 IfxVadc_Adc_masterIndex
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 impure.c
70000504 l     O .data	00000424 impure_data
00000000 l    df *ABS*	00000000 vfprintf.c
80000e04 l     O .rodata	00000010 blanks.4035
80000df4 l     O .rodata	00000010 zeroes.4036
00000000 l    df *ABS*	00000000 dtoa.c
8000c180 l     F .text	0000011a quorem
00000000 l    df *ABS*	00000000 locale.c
80000e30 l     O .rodata	00000038 lconv
00000000 l    df *ABS*	00000000 mprec.c
80000e68 l     O .rodata	0000000c p05.2553
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_sbrk.c
70000928 l     O .data	00000004 heap_top.2289
00000000 l    df *ABS*	00000000 ee_tc_trapvec.c
00000000 l    df *ABS*	00000000 ee_tc_intvec.c
80008fba l     F .text	0000000e osEE_tc_isr2_wrapper
00000000 l    df *ABS*	00000000 IfxAsclin.c
00000000 l    df *ABS*	00000000 IfxAsclin_Asc.c
00000000 l    df *ABS*	00000000 IfxPort.c
00000000 l    df *ABS*	00000000 IfxScuEru.c
00000000 l    df *ABS*	00000000 IfxScuWdt.c
00000000 l    df *ABS*	00000000 Ifx_CircularBuffer.c
00000000 l    df *ABS*	00000000 Ifx_Fifo.c
00000000 l    df *ABS*	00000000 ee_tc_system.c
80008aea l     F .text	00000054 osEE_tc_stm_us_ticks
70000c00 l     O .bss	00000004 osEE_tc_stm_freq_khz
00000000 l    df *ABS*	00000000 ee_oo_api_osek.c
80008fc8 l     F .text	0000001e osEE_shutdown_os
00000000 l    df *ABS*	00000000 ee_oo_sched_entry_points.c
8000988c l     F .text	00000022 osEE_release_all_m
00000000 l    df *ABS*	00000000 ee_oo_scheduler.c
00000000 l    df *ABS*	00000000 ee_oo_kernel.c
00000000 l    df *ABS*	00000000 ee_oo_sched_partitioned.c
00000000 l    df *ABS*	00000000 ee_std_change_context.c
00000000 l    df *ABS*	00000000 ee_tc_hal.c
00000000 l    df *ABS*	00000000 ee_tc_ctx.c
80009d82 l     F .text	00000022 osEE_tc_change_context_from_task_end
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
80009f5a l     F .text	0000019c _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vsnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_exit.c
00000000 l    df *ABS*	00000000 libos.c
00000000 l    df *ABS*	00000000 libos_abort.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udivdi3.c
00000000 l    df *ABS*	00000000 umoddi3.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udiv6432.c
00000000 l    df *ABS*	00000000 Bsp.c
00000000 l    df *ABS*	00000000 CompilerGnuc.c
00000000 l    df *ABS*	00000000 IfxCpu.c
00000000 l    df *ABS*	00000000 IfxCpu_Irq.c
00000000 l    df *ABS*	00000000 IfxCpu_cfg.c
00000000 l    df *ABS*	00000000 IfxSrc.c
00000000 l    df *ABS*	00000000 IfxStdIf_DPipe.c
00000000 l    df *ABS*	00000000 IfxStm.c
00000000 l    df *ABS*	00000000 IfxStm_cfg.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 IfxScu_cfg.c
00000000 l    df *ABS*	00000000 IfxSrc_cfg.c
800003fc g     O .rodata	00000010 IfxAsclin1_TX_P33_12_OUT
800031c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_142
80002d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_105
70000008 g     O .data	00000020 osEE_ccb_var
70000c50 g     O .text	00000001 __HEAP
80003980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_204
800056a0 g     F .text	00000062 IfxAsclin_Asc_write
80004f3e g     F .text	0000000a IfxAsclin_Asc_getWriteEvent
80006fc8 g     F .text	00000032 IfxScuWdt_clearSafetyEndinit
80002c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_100
800071fc g     F .text	00000036 IfxScuWdt_setCpuEndinit
80000e74 g     O .rodata	00000028 __mprec_tinytens
80000b0c g     O .rodata	00000010 IfxScu_WDT1LCK_P20_7_OUT
80004150 g     F .text	000000e8 mdelay
8000a4fe g     F .text	0000001a .hidden __ashldi3
80006f5e g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogReload
800021e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_15
80009338 g     F .text	0000005a TerminateTask
80004fba g     F .text	00000006 IfxAsclin_Asc_resetSendCount
800001fc g     O .rodata	000000a0 IfxVadc_cfg_srcAddresses
70000be8 g     O .bss	00000004 osEE_kcb_var
800003ac g     O .rodata	00000010 IfxAsclin2_TX_P14_2_OUT
80002f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_123
80007fa6 g     F .text	00000020 Ifx_CircularBuffer_addDataIncr
80004a6a g     F .text	00000014 IfxVadc_setScan
8000dba0 g     F .text	00000040 .hidden __eqdf2
800055d0 g     F .text	00000088 IfxAsclin_Asc_initModuleConfig
80006ef2 g     F .text	00000038 IfxScuWdt_changeCpuWatchdogReload
800046dc g     F .text	00000010 IfxVadc_getQueueStatus
00000000 g       *ABS*	00000000 __HEAP_SIZE
8000825c g     F .text	00000176 Ifx_Fifo_read
80004ac4 g     F .text	0000001c IfxAsclin_disableModule
8000074c g     O .rodata	00000010 IfxAsclin3_RXC_P20_3_IN
80009962 g     F .text	00000022 osEE_idle_hook_wrapper
6001a600 g       .CPU1.ustack	00000000 __USTACK1_AREA_END
80003e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_242
80002300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_24
80003580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_172
8000867e g     F .text	0000046c osEE_tc_core0_start
800024c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_38
80008122 g     F .text	00000004 Ifx_Fifo_destroy
70019b00 g     O .CPU0.istack	00000000 __ISTACK0
80007436 g     F .text	00000108 IfxVadc_Adc_getChannelConfig
8000468c g     F .text	00000018 IfxVadc_getAdcAnalogFrequency
70000000 g       *ABS*	00000000 __DSPR0_START
80002be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_95
80002740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_58
80009de2 g     F .text	00000024 osEE_hal_save_ctx_and_ready2stacked
80002c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_97
80006768 g     F .text	00000012 IfxScuCcu_initErayPllConfig
80009caa g     F .text	00000028 osEE_change_context_from_running
80004f30 g     F .text	0000000e IfxAsclin_Asc_getWriteCount
8000076c g     O .rodata	00000010 IfxAsclin3_RXA_P15_7_IN
80006e88 g     F .text	00000032 IfxScuEru_setInterruptGatingPattern
8000507c g     F .text	00000014 IfxAsclin_Asc_clearTx
8000571e g     F .text	000000c6 IfxAsclin_Asc_stdIfDPipeInit
80002560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_43
8000ace2 g     F .text	00000002 __malloc_unlock
80004f1a g     F .text	0000000a IfxAsclin_Asc_getReadEvent
8000446c g     F .text	00000036 TimerISR
80008408 g     F .text	000000f0 Ifx_Fifo_canWriteCount
80007d6e g     F .text	000000e8 IfxVadc_Adc_initModule
800032e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_151
80002ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_118
80002c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_99
800045a6 g     F .text	0000003c IfxVadc_disablePostCalibration
80002680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_52
8000478a g     F .text	00000028 IfxVadc_getSrcAddress
800047d6 g     F .text	00000024 IfxVadc_initialiseAdcConverterClock
80004bee g     F .text	00000024 IfxAsclin_getOvsFrequency
80009752 g     F .text	00000096 SetEvent
8000753e g     F .text	00000038 IfxVadc_Adc_getChannelConversionTime
80003e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_244
80002380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_28
80006e4a g     F .text	00000012 IfxScuEru_setEventFlag
80003920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_201
800098ae g     F .text	0000000a osEE_scheduler_task_wrapper_restore
80000d14 g     O .rodata	00000010 IfxScu_EVRWUPA_P14_1_IN
8000051c g     O .rodata	00000010 IfxAsclin3_SLSO_P12_1_OUT
70019600 g     O .CPU0.ustack	00000000 __USTACK0
80003720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_185
8000d6e8 g     F .text	00000050 memmove
70018600 g       .CPU0.ustack	00000000 __USTACK0_AREA_END
8000cfae g     F .text	00000056 _Balloc
80000cf4 g     O .rodata	00000010 IfxScu_EXTCLK0_P23_1_OUT
80003b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_216
8000080c g     O .rodata	00000010 IfxAsclin1_RXE_P11_10_IN
800005ec g     O .rodata	00000010 IfxAsclin3_SCLK_P15_8_OUT
80006082 g     F .text	0000004a IfxScuCcu_getModuleFrequency
80003aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_213
800028e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_71
800061f4 g     F .text	000003be IfxScuCcu_init
8000dc20 g     F .text	00000040 .hidden __gtdf2
8000db84  w    F .text	0000000a __errno
800037e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_191
80003380 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_156
80009018 g     F .text	00000042 SuspendAllInterrupts
80002140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_10
80004fc0 g     F .text	00000008 IfxAsclin_Asc_canReadCount
80003180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_140
80002ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_103
00001000 g       *ABS*	00000000 __USTACK0_SIZE
800007ec g     O .rodata	00000010 IfxAsclin1_RXG_P02_3_IN
80009e50 g     F .text	00000066 osEE_hal_terminate_ctx
8000029c g     O .rodata	00000010 IfxAsclin3_TX_P32_3_OUT
800099f4 g     F .text	00000048 osEE_sn_priority_insert
80003480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_164
80003ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_215
80009660 g     F .text	00000078 GetTaskState
80007f64 g     F .text	00000020 Ifx_CircularBuffer_get32
80009aa6 g     F .text	00000022 osEE_task_event_set_mask
8000032c g     O .rodata	00000010 IfxAsclin3_TX_P11_1_OUT
8000075c g     O .rodata	00000010 IfxAsclin3_RXB_P11_0_IN
80007232 g     F .text	0000009e IfxScuWdt_initCpuWatchdog
80005984 g     F .text	00000092 IfxPort_setGroupModeOutput
80002080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_4
00000400 g       *ABS*	00000000 __ISTACK1_SIZE
80005dd2 g     F .text	00000072 IfxScuCcu_getPllFrequency
80002a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_82
70000c40 g     O .bss	00000004 errno
8000a472 g     F .text	0000001e .hidden __make_dp
80002e40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_114
0001a600 g       *ABS*	00000000 __USTACK1_OFFSET
800022a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_21
80001160 g       .traptab	00000000 osEE_tc_trap_context
800073b4 g     F .text	00000040 IfxScuWdt_enableWatchdogWithDebugger
80002ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_117
800006fc g     O .rodata	00000010 IfxAsclin3_RXG_P21_3_IN
8000089c g     O .rodata	00000010 IfxAsclin2_RTS_P33_4_OUT
8000055c g     O .rodata	00000010 IfxAsclin2_SLSO_P02_3_OUT
800027e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_63
8000a592 g     F .text	00000016 .hidden __make_fp
80003560 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_171
800042f8 g     F .text	0000007e initVADCChannels
800023c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_30
800002cc g     O .rodata	00000010 IfxAsclin3_TX_P22_0_OUT
800020c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_6
80003780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_188
80000bf4 g     O .rodata	00000014 IfxScu_REQ15_P14_1_IN
80000c6c g     O .rodata	00000014 IfxScu_REQ0_P15_4_IN
80002260 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_19
80006eba g     F .text	00000038 IfxScuWdt_changeCpuWatchdogPassword
8000981a g     F .text	00000058 ClearEvent
80006146 g     F .text	00000042 IfxScuCcu_getCpuFrequency
80003d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_232
800028a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_69
800098b8 g     F .text	000000aa osEE_scheduler_task_wrapper_run
80003f60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_251
800035c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_174
8000063c g     O .rodata	00000010 IfxAsclin3_SCLK_P00_0_OUT
80003700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_184
8000096c g     O .rodata	00000080 IfxPort_cfg_indexMap
80005222 g     F .text	000003ae IfxAsclin_Asc_initModule
80009c46 g     F .text	00000026 osEE_scheduler_task_preemption_point
8000cf92 g     F .text	0000001c memcpy
800021c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_14
80004000 g     F .text	0000001c FuncTask1
8000afdc g     F .text	000011a4 _svfprintf_r
8000a42a g     F .text	00000048 .hidden __floatsidf
80007576 g     F .text	0000023e IfxVadc_Adc_getGroupConfig
80006d1c g     F .text	00000026 IfxScuEru_enablePatternDetectionTrigger
80009a3c g     F .text	0000000e osEE_scheduler_rq_insert
80002940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_74
8000dca0 g     F .text	00000040 .hidden __ltdf2
80004780 g     F .text	0000000a IfxVadc_getScanStatus
80001210 g       .dtors	00000000 __DTOR_END__
8000677a g     F .text	00000076 IfxScuCcu_setCpuFrequency
80006e5c g     F .text	0000002c IfxScuEru_setFlagPatternDetection
80009cf2 g     F .text	00000026 osEE_idle_task_terminate
80000c58 g     O .rodata	00000014 IfxScu_REQ10_P14_3_IN
80003c80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_228
8000088c g     O .rodata	00000010 IfxAsclin3_RTS_P00_9_OUT
800006bc g     O .rodata	00000010 IfxAsclin1_SCLK_P20_10_OUT
8000d554 g     F .text	00000042 __fpclassifyd
800023a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_29
80006f2a g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogPassword
80003a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_211
80002340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_26
800070c4 g     F .text	0000005c IfxScuWdt_enableCpuWatchdog
80002540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_42
80009b80 g     F .text	0000003c osEE_scheduler_task_unblocked
80002960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_75
80003820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_193
800033c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_158
8000a82c g     F .text	0000000c malloc
80002cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_102
80006b8c g     F .text	00000028 IfxScuEru_clearInputChannelConfiguration
00000000 g       *ABS*	00000000 NULL
8000071c g     O .rodata	00000010 IfxAsclin3_RXF_P21_6_IN
80008ec8 g     F .text	0000001e osEE_tc_stm_set_sr0_next_match
80001140 g       .traptab	00000000 osEE_tc_trap_instruction
80000ec4 g     O .rodata	000000c8 __mprec_tens
70000004 g     O .data	00000004 g_vadcChannelIDs
80005064 g     F .text	00000008 IfxAsclin_Asc_canWriteCount
80009406 g     F .text	000000b2 GetResource
800003bc g     O .rodata	00000010 IfxAsclin2_TX_P10_5_OUT
800004ac g     O .rodata	00000010 IfxAsclin0_TX_P15_2_OUT
8000ad60 g     F .text	00000016 vsnprintf
80003ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_214
800029a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_77
800008ec g     O .rodata	00000010 IfxAsclin3_CTSA_P00_12_IN
800038a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_197
70000c38 g     O .bss	00000004 __malloc_top_pad
80004398 g     F .text	00000026 readADCValue
800067f0 g     F .text	0000008e IfxScuCcu_setGtmFrequency
80005b10 g     F .text	00000064 IfxPort_setPinModeLvdsHigh
80009e06 g     F .text	0000002c osEE_hal_ready2stacked
80002660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_51
80000bcc g     O .rodata	00000014 IfxScu_REQ1_P15_8_IN
800080d2 g     F .text	00000050 Ifx_CircularBuffer_write32
8000cf70 g     F .text	0000000a _localeconv_r
80003460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_163
8000401c g     F .text	0000001c FuncTask2
80004bb4 g     F .text	00000022 IfxAsclin_getIndex
8000d140 g     F .text	00000010 __i2b
80009392 g     F .text	00000074 Schedule
80004c12 g     F .text	00000016 IfxAsclin_getShiftFrequency
800077b4 g     F .text	000001ec IfxVadc_Adc_initChannel
80003f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_250
800002bc g     O .rodata	00000010 IfxAsclin3_TX_P22_1_OUT
80006a52 g     F .text	00000112 IfxScuCcu_switchToBackupClock
80003100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_136
800006dc g     O .rodata	00000010 IfxAsclin0_SCLK_P15_2_OUT
80007120 g     F .text	00000072 IfxScuWdt_enableSafetyWatchdog
80002060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_3
80003e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_240
8000ace4 g     F .text	0000001e _sbrk_r
8000046c g     O .rodata	00000010 IfxAsclin1_TX_P11_12_OUT
80000c8c g     O .rodata	0000000c IfxScu_HWCFG5_P10_6_IN
8000047c g     O .rodata	00000010 IfxAsclin1_TX_P02_2_OUT
80003040 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_130
80002b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_89
800025c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_46
70000950 g     O .bss	0000000c g_vadcGroup
80006cd0 g     F .text	00000026 IfxScuEru_enableAutoClear
800006cc g     O .rodata	00000010 IfxAsclin1_SCLK_P15_0_OUT
800027a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_61
80002800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_64
8000a6ba g     F .text	000000ac .hidden __unpack_d
00002700 g     O *ABS*	00000000 __TRICORE_DERIVATE_NAME__
80005bb6 g     F .text	0000003c IfxPort_setPinPadDriver
80003ec0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_246
80002480 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_36
8000042c g     O .rodata	00000010 IfxAsclin1_TX_P15_4_OUT
70000c34 g     O .bss	00000004 __malloc_max_sbrked_mem
80002a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_81
800011a0 g       .traptab	00000000 osEE_tc_trap_assertion
80002ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_93
80008000 g       *ABS*	00000000 __A1_MEM
80009f28 g     F .text	00000032 .hidden __extendsfdf2
80002700 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_56
80004b2a g     F .text	00000016 IfxAsclin_getAddress
8000a0f6 g     F .text	00000038 .hidden __adddf3
800091c4 g     F .text	0000001a GetActiveApplicationMode
800060cc g     F .text	0000007a IfxScuCcu_getSriFrequency
800030c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_134
8000905a g     F .text	00000026 ResumeAllInterrupts
800036c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_182
800038e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_199
800069d2 g     F .text	00000080 IfxScuCcu_setSriFrequency
8000ddce g     F .text	00000026 .hidden __umoddi3
80003740 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_186
70019c00 g     O .CPU0.csa	00000000 __CSA0
80003840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_194
800033e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_159
80003280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_148
80002180 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_12
800008bc g     O .rodata	00000010 IfxAsclin1_RTS_P23_1_OUT
80000db8 g     O .rodata	00000004 _global_impure_ptr
80006bdc g     F .text	00000036 IfxScuEru_connectTrigger
70000930 g     O .bss	00000020 g_vadcChannel
80006188 g     F .text	00000036 IfxScuCcu_getFsi2Frequency
8000d748 g     F .text	000003f0 _realloc_r
8000069c g     O .rodata	00000010 IfxAsclin1_SCLK_P33_12_OUT
80004c64 g     F .text	00000012 IfxAsclin_read16
800058b8 g     F .text	0000003c IfxPort_enableEmergencyStop
800002ec g     O .rodata	00000010 IfxAsclin3_TX_P20_3_OUT
80003fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_254
8000dd2e g     F .text	000000a0 .hidden __udivdi3
8000086c g     O .rodata	00000010 IfxAsclin0_RXB_P15_3_IN
800002fc g     O .rodata	00000010 IfxAsclin3_TX_P20_0_OUT
70008000 g       *ABS*	00000000 __A0_MEM
80009984 g     F .text	00000070 osEE_scheduler_core_rq_preempt_stk
800004bc g     O .rodata	00000010 IfxAsclin0_TX_P14_1_OUT
80000e9c g     O .rodata	00000028 __mprec_bigtens
8000db8e g     F .text	00000012 abort
8000a4cc g     F .text	00000032 .hidden __floatunsidf
80002aa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_85
8000d3a0 g     F .text	00000042 __mcmp
800038c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_198
80005090 g     F .text	0000001c IfxAsclin_Asc_read
800091de g     F .text	00000084 ActivateTask
80000c08 g     O .rodata	00000014 IfxScu_REQ14_P02_1_IN
80003300 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_152
80006c38 g     F .text	00000026 IfxScuEru_disableFallingEdgeDetection
80002040 g       .inttab_cpu0	00000000 osEE_tc_isr2_entry_2
80002de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_111
80008126 g     F .text	0000003a Ifx_Fifo_init
80002420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_33
70000c48  w    O .bss	00000004 _my_errno
800004fc g     O .rodata	00000010 IfxAsclin3_SLSO_P21_2_OUT
800057e4 g     F .text	00000030 IfxPort_getAddress
80003760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_187
00019c00 g       *ABS*	00000000 __CSA0_OFFSET
8000091c g     O .rodata	00000010 IfxAsclin1_CTSB_P32_4_IN
80009608 g     F .text	00000058 GetTaskID
800065c6 g     F .text	000001a2 IfxScuCcu_initErayPll
8000039c g     O .rodata	00000010 IfxAsclin2_TX_P14_3_OUT
80003de0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_239
8000033c g     O .rodata	00000010 IfxAsclin3_TX_P11_0_OUT
80000a74 g     O .rodata	00000054 IfxScuCcu_defaultClockConfig
0001bc00 g       *ABS*	00000000 __CSA1_OFFSET
80006d8e g     F .text	0000000e IfxScuEru_getAllEventFlagsStatus
80000cb0 g     O .rodata	0000000c IfxScu_HWCFG2EVR13_P14_2_IN
80009080 g     F .text	0000005c SuspendOSInterrupts
80003a40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_210
80006ffa g     F .text	0000005a IfxScuWdt_disableCpuWatchdog
8000a518 g     F .text	0000007a .hidden __unpack_f
80008e10 g     F .text	00000034 osEE_tc_stm_set_clockpersec
80003a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_208
80004376 g     F .text	00000022 initADC
800031e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_143
80002d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_106
80009c6c g     F .text	0000003e osEE_scheduler_task_set_running
b0008000 g     O *ABS*	00000000 _SMALL_DATA4_
80008ee6 g     F .text	0000008e osEE_tc_stm_set_sr1
8000073c g     O .rodata	00000010 IfxAsclin3_RXD_P32_2_IN
80004460 g     F .text	0000000c asclin0TxISR
8000061c g     O .rodata	00000010 IfxAsclin3_SCLK_P11_1_OUT
80007054 g     F .text	00000070 IfxScuWdt_disableSafetyWatchdog
80002c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_96
800073b0 g     F .text	00000004 IfxScuWdt_serviceSafetyWatchdog
8000079c g     O .rodata	00000010 IfxAsclin2_RXE_P33_8_IN
8000064c g     O .rodata	00000010 IfxAsclin2_SCLK_P33_9_OUT
8000d098 g     F .text	00000042 __hi0bits
80002760 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_59
8000083c g     O .rodata	00000010 IfxAsclin1_RXB_P15_5_IN
80002e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_115
8000040c g     O .rodata	00000010 IfxAsclin1_TX_P20_10_OUT
8000041c g     O .rodata	00000010 IfxAsclin1_TX_P15_5_OUT
8000dce0 g     F .text	0000004e .hidden __fixdfsi
80003160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_139
80009aea g     F .text	00000068 osEE_scheduler_task_activated
80005ee0 g     F .text	00000078 IfxScuCcu_getBbbFrequency
0001bc00 g       *ABS*	00000000 __CSA2_OFFSET
0001e000 g       *ABS*	00000000 __DSPR2_SIZE
8000034c g     O .rodata	00000010 IfxAsclin3_TX_P00_1_OUT
800004cc g     O .rodata	00000010 IfxAsclin0_TX_P14_0_OUT
80002f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_121
800061be g     F .text	00000036 IfxScuCcu_getFsiFrequency
80000b1c g     O .rodata	00000010 IfxScu_WDT0LCK_P20_8_OUT
80002100 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_8
80002580 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_44
80003d40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_234
800032a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_149
80006f92 g     F .text	00000036 IfxScuWdt_clearCpuEndinit
80002e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_113
80003320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_153
800025e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_47
800022e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_23
8000066c g     O .rodata	00000010 IfxAsclin2_SCLK_P14_2_OUT
80004d5a g     F .text	00000182 IfxAsclin_setBitTiming
80000cd4 g     O .rodata	00000010 IfxScu_EXTCLK1_P32_4_OUT
800004dc g     O .rodata	00000010 IfxAsclin3_SLSO_P33_1_OUT
8000030c g     O .rodata	00000010 IfxAsclin3_TX_P15_7_OUT
8000081c g     O .rodata	00000010 IfxAsclin1_RXD_P14_8_IN
80000c98 g     O .rodata	0000000c IfxScu_HWCFG4_P10_5_IN
800073f4 g     F .text	00000026 IfxVadc_Adc_deInitGroup
80009eb6 g     F .text	00000026 .hidden __lshrdi3
8000072c g     O .rodata	00000010 IfxAsclin3_RXE_P00_1_IN
800039a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_205
8000085c g     O .rodata	00000010 IfxAsclin0_RXD_P34_2_IN
800005bc g     O .rodata	00000010 IfxAsclin3_SCLK_P21_7_OUT
800079b6 g     F .text	0000038a IfxVadc_Adc_initGroup
8000d26a g     F .text	0000007c __pow5mult
70000960 g     O .bss	0000000c g_ERUconfig
80003fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_255
80002860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_67
80002e00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_112
80006c84 g     F .text	00000026 IfxScuEru_disableRisingEdgeDetection
8000057c g     O .rodata	00000010 IfxAsclin1_SLSO_P20_8_OUT
80009bbc g     F .text	0000008a osEE_scheduler_task_terminated
8000035c g     O .rodata	00000010 IfxAsclin3_TX_P00_0_OUT
80002460 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_35
800036a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_181
8000a766 g     F .text	000000c6 .hidden __pack_f
80003ea0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_245
80007fc6 g     F .text	0000005e Ifx_CircularBuffer_read8
800008ac g     O .rodata	00000010 IfxAsclin2_RTS_P10_8_OUT
00002700 g       *ABS*	00000000 __TRICORE_DERIVATE_MEMORY_MAP__
80003b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_219
80004038 g     F .text	0000000c FuncTask3
80002360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_27
800037a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_189
800071e2 g     F .text	0000001a IfxScuWdt_initConfig
80001200 g       .ctors	00000000 __CTOR_LIST__
80008d6c g     F .text	000000a4 osEE_tc_get_fsource
80004c76 g     F .text	00000012 IfxAsclin_read32
80000c30 g     O .rodata	00000014 IfxScu_REQ12_P11_10_IN
800072d0 g     F .text	00000004 IfxScuWdt_serviceCpuWatchdog
80003ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_247
800008dc g     O .rodata	00000010 IfxAsclin0_RTS_P14_7_OUT
80002ac0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_86
800007ac g     O .rodata	00000010 IfxAsclin2_RXD_P10_6_IN
80008e44 g     F .text	00000084 osEE_tc_stm_set_sr0
80000b2c g     O .rodata	00000014 IfxScu_REQ9_P20_0_IN
8000067c g     O .rodata	00000010 IfxAsclin2_SCLK_P10_6_OUT
80002e80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_116
80009e32 g     F .text	0000001e osEE_tc_change_context_from_isr2_end
80002a60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_83
8000cf7a g     F .text	00000018 memchr
80003400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_160
8000ae30 g     F .text	000001ac _free_r
80005658 g     F .text	00000048 IfxAsclin_Asc_initiateTransmission
80002220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_17
800023e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_31
80009872 g     F .text	00000018 GetISRID
80009da4 g     F .text	00000024 osEE_hal_save_ctx_and_restore_ctx
80001180 g       .traptab	00000000 osEE_tc_trap_bus
80004044 g     F .text	0000002a FuncTaskM
80005bf4 g     F .text	000000f8 IfxScuCcu_calculateSysPllDividers
800008fc g     O .rodata	00000010 IfxAsclin2_CTSB_P33_5_IN
700000f0 g     O .data	00000004 __malloc_sbrk_base
80000020 g     F .startup	00000006 _start
80003520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_169
80008160 g     F .text	00000022 Ifx_Fifo_create
80003f20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_249
800071b2 g     F .text	0000001c IfxScuWdt_getCpuWatchdogEndInit
00001000 g       *ABS*	00000000 __USTACK2_SIZE
800011e0 g       .traptab	00000000 osEE_tc_trap_nmi
800020a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_5
8000d2e6 g     F .text	000000ba __lshift
80003600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_176
8000065c g     O .rodata	00000010 IfxAsclin2_SCLK_P33_7_OUT
8000741a g     F .text	0000001c IfxVadc_Adc_disableModule
00002000 g       *ABS*	00000000 __CSA_SIZE
8000d596 g     F .text	000000f0 __ssprint_r
800046a4 g     F .text	0000001a IfxVadc_getAdcDigitalFrequency
5001bc00 g       .CPU2.csa	00000000 __CSA2
800034a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_165
80003c60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_227
7001bc00 g     O .CPU0.csa	00000000 __CSA0_END
80004528 g     F .text	00000038 IfxVadc_enableAccess
800027c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_62
8000d150 g     F .text	0000011a __multiply
00000001 g       *ABS*	00000000 _.
80006d9c g     F .text	00000012 IfxScuEru_getEventFlagStatus
8000053c g     O .rodata	00000010 IfxAsclin2_SLSO_P33_6_OUT
8000038c g     O .rodata	00000010 IfxAsclin2_TX_P32_5_OUT
800049f0 g     F .text	00000024 IfxVadc_selectPowerSupplyVoltage
80006c5e g     F .text	00000026 IfxScuEru_disablePatternDetectionTrigger
70000c08 g     O .bss	00000028 __malloc_current_mallinfo
8000d4ac g     F .text	000000a8 __d2b
80003c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_226
800037c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_190
80003360 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_155
800026c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_54
80002fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_125
80002b60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_91
80000b68 g     O .rodata	00000014 IfxScu_REQ6_P02_0_IN
80007f84 g     F .text	00000022 Ifx_CircularBuffer_get16
8000045c g     O .rodata	00000010 IfxAsclin1_TX_P14_10_OUT
80003680 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_180
80005d8e g     F .text	00000044 IfxScuCcu_getPllErayVcoFrequency
80001200 g       .ctors	00000000 __EH_FRAME_END__
80006c12 g     F .text	00000026 IfxScuEru_disableAutoClear
8000687e g     F .text	00000050 IfxScuCcu_setPll2ErayFrequency
6001bb00 g       .CPU1.istack	00000000 __ISTACK1
80003800 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_192
800033a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_157
80005fe8 g     F .text	00000022 IfxScuCcu_getBaud2Frequency
80003240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_146
80002da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_109
800005fc g     O .rodata	00000010 IfxAsclin3_SCLK_P15_6_OUT
8000ddf4 g     F .text	000000a6 .hidden __fpcmp_parts_d
80004b0e g     F .text	0000001c IfxAsclin_enableModule
0001a600 g       *ABS*	00000000 __USTACK2_OFFSET
80009a4a g     F .text	00000026 osEE_scheduler_core_pop_running
800021a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_13
80003f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_252
80009d18 g     F .text	0000006a osEE_cpu_startos
80003b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_218
80006d42 g     F .text	00000026 IfxScuEru_enableRisingEdgeDetection
800007dc g     O .rodata	00000010 IfxAsclin2_RXA_P14_3_IN
80003e20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_241
800029c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_78
80005814 g     F .text	00000022 IfxPort_getIndex
800030a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_133
800097e8 g     F .text	00000032 GetEvent
80005206 g     F .text	0000001c IfxAsclin_Asc_disableModule
80009edc g     F .text	0000004c .hidden __floatundisf
6001b600 g       .CPU1.ustack	00000000 __USTACK1
80004c88 g     F .text	00000012 IfxAsclin_read8
80009b52 g     F .text	0000002e osEE_scheduler_task_insert
80003be0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_223
80002620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_49
8000a312 g     F .text	00000118 .hidden __divdf3
80000d34 g     O .rodata	00000010 IfxScu_EMGSTOPA_P33_8_IN
80000ce4 g     O .rodata	00000010 IfxScu_EXTCLK1_P11_12_OUT
80005702 g     F .text	0000001c IfxAsclin_Asc_blockingWrite
80007e56 g     F .text	0000003a IfxVadc_Adc_initModuleConfig
700000f8 g     O .data	00000408 __malloc_av_
80002f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_120
800095a4 g     F .text	00000064 ShutdownOS
80003060 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_131
8000ad16 g     F .text	0000004a _vsnprintf_r
800035e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_175
70018600 g     O .CPU0.ustack	00000000 __USTACK0_END
80003900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_200
80002120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_9
8000a16e g     F .text	000001a4 .hidden __muldf3
80002500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_40
800006ec g     O .rodata	00000010 IfxAsclin0_SCLK_P14_0_OUT
80002520 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_41
80000d24 g     O .rodata	00000010 IfxScu_EMGSTOPB_P21_2_IN
8000ace0 g     F .text	00000002 __malloc_lock
8000db48 g     F .text	0000003c sbrk
80005cec g     F .text	0000000e IfxScuCcu_getOsc0Frequency
800044f0 g     F .text	00000038 IfxVadc_disableAccess
80000000 g       .startup	00000000 BootModeHeader0
800011c0 g       .traptab	00000000 osEE_tc_trap_system
80000ca4 g     O .rodata	0000000c IfxScu_HWCFG3_BMI_P14_3_IN
80004c50 g     F .text	00000014 IfxAsclin_getSrcPointerTx
800046ec g     F .text	00000094 IfxVadc_getResultBasedOnRequestSource
8000d686 g     F .text	00000062 _calloc_r
00002000 g       *ABS*	00000000 __CSA0_SIZE
8000600a g     F .text	00000078 IfxScuCcu_getSpbFrequency
80002820 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_65
800007cc g     O .rodata	00000010 IfxAsclin2_RXB_P02_1_IN
800045e2 g     F .text	000000aa IfxVadc_enableGroupSync
80006df6 g     F .text	00000012 IfxScuEru_getPatternDetectionResult
800024a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_37
800050ac g     F .text	0000009e IfxAsclin_Asc_isrTransmit
8000037c g     O .rodata	00000010 IfxAsclin2_TX_P33_8_OUT
80003d20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_233
80003960 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_203
8000d738 g     F .text	00000010 memset
800034e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_167
80002640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_50
800044a2 g     F .text	0000004c main
80007192 g     F .text	00000020 IfxScuWdt_getCpuWatchdogPassword
80006d68 g     F .text	00000026 IfxScuEru_enableTriggerPulse
80002200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_16
70000c30 g     O .bss	00000004 __malloc_max_total_mem
80003540 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_170
80004ae0 g     F .text	0000002e IfxAsclin_enableAscErrorFlags
8000de9a g     F .text	0000009c .hidden __udiv6432
00000400 g       *ABS*	00000000 __ISTACK_SIZE
80005fc8 g     F .text	00000020 IfxScuCcu_getBaud1Frequency
800025a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_45
80007ed2 g     F .text	00000092 IfxVadc_Adc_initExternalMultiplexerMode
80000be0 g     O .rodata	00000014 IfxScu_REQ16_P15_1_IN
7000096c g     O .bss	0000027c g_AsclinAsc
80002b00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_88
80000c80 g     O .rodata	0000000c IfxScu_HWCFG6_P14_4_IN
80009a70 g     F .text	00000018 osEE_task_activated
5001bb00 g       .CPU2.istack	00000000 __ISTACK2
800000c8 g     O .rodata	00000014 osEE_kdb_var
00018600 g       *ABS*	00000000 __USTACK0_OFFSET
800071ce g     F .text	00000014 IfxScuWdt_getSafetyWatchdogPassword
8000a490 g     F .text	0000003c .hidden __truncdfsf2
80003b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_220
80003020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_129
8000c29c g     F .text	00000cd2 _dtoa_r
0001b700 g       *ABS*	00000000 __ISTACK1_OFFSET
8000a846 g     F .text	0000049a _malloc_r
800004ec g     O .rodata	00000010 IfxAsclin3_SLSO_P21_6_OUT
80005b74 g     F .text	00000042 IfxPort_setPinModeLvdsMedium
800007bc g     O .rodata	00000010 IfxAsclin2_RXC_P02_10_IN
800039e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_207
800051e0 g     F .text	00000026 IfxAsclin_Asc_blockingRead
80003d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_235
800024e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_39
80002020 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_1
800005ac g     O .rodata	00000010 IfxAsclin3_SCLK_P32_3_OUT
80004f14 g     F .text	00000006 IfxAsclin_Asc_getReadCount
80002a00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_80
80008000 g       *ABS*	00000000 __A8_MEM
8000059c g     O .rodata	00000010 IfxAsclin3_SCLK_P33_2_OUT
b0008000 g       *ABS*	00000000 __A9_MEM
80004ef0 g     F .text	00000012 IfxAsclin_write32
80003ce0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_231
80003340 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_154
80002c40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_98
800040e2 g     F .text	0000006e printfSerial
80000da4 g     O .rodata	00000014 .hidden __thenan_df
8000ad76 g     F .text	000000ba _malloc_trim_r
80001208 g       .ctors	00000000 __CTOR_END__
80008000 g     O *ABS*	00000000 _SMALL_DATA2_
800003cc g     O .rodata	00000010 IfxAsclin2_TX_P02_9_OUT
800048f4 g     F .text	000000aa IfxVadc_getChannelConversionTime
50000000 g       *ABS*	00000000 __DSPR2_START
800028c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_70
80004560 g     F .text	00000046 IfxVadc_configExternalMultiplexerMode
800094b8 g     F .text	000000ec ReleaseResource
80007e90 g     F .text	00000042 IfxVadc_Adc_initExternalMultiplexerModeConfig
80004bd6 g     F .text	00000018 IfxAsclin_getPdFrequency
800046c2 g     F .text	0000001a IfxVadc_getBackgroundScanStatus
80003da0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_237
80001208 g       .dtors	00000000 __DTOR_LIST__
60000000 g       *ABS*	00000000 __DSPR1_START
80003c00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_224
800026a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_53
00001000 g       *ABS*	00000000 __USTACK1_SIZE
80002b40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_90
8000499e g     F .text	00000052 IfxVadc_resetKernel
800008cc g     O .rodata	00000010 IfxAsclin1_RTS_P20_6_OUT
80000cc8 g     O .rodata	0000000c IfxScu_HWCFG0DCLDO_P14_6_IN
8000dbe0 g     F .text	00000040 .hidden __nedf2
80004d08 g     F .text	00000052 IfxAsclin_setBaudrateBitFields
80003a20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_209
80003880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_196
80005e44 g     F .text	00000044 IfxScuCcu_getPllVcoFrequency
8000691e g     F .text	000000b4 IfxScuCcu_setSpbFrequency
80003220 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_145
80002d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_108
80006dd2 g     F .text	00000024 IfxScuEru_getOutputChannelConfiguration
80000afc g     O .rodata	00000010 IfxScu_WDT2LCK_P20_6_OUT
800009ec g     O .rodata	00000080 IfxPort_cfg_esrMasks
80002a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_84
8000070c g     O .rodata	00000010 IfxAsclin3_RXG_P21_2_IN
80004238 g     F .text	00000070 printState
80003500 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_168
8000506c g     F .text	00000010 IfxAsclin_Asc_clearRx
8000093c g     O .rodata	00000010 IfxAsclin0_CTSA_P14_9_IN
80002400 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_32
80003000 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_128
80000d54 g     O .rodata	00000010 IfxScu_DCDCSYNC_P32_2_OUT
8000588e g     F .text	0000002a IfxPort_setESR
8000050c g     O .rodata	00000010 IfxAsclin3_SLSO_P14_3_OUT
80003620 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_177
8000044c g     O .rodata	00000010 IfxAsclin1_TX_P15_0_OUT
80003120 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_137
80002900 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_72
8000092c g     O .rodata	00000010 IfxAsclin1_CTSA_P20_7_IN
80002600 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_48
80000ba4 g     O .rodata	00000014 IfxScu_REQ3_P10_3_IN
8000043c g     O .rodata	00000010 IfxAsclin1_TX_P15_1_OUT
70000500 g     O .data	00000004 _impure_ptr
80003660 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_179
80005836 g     F .text	00000028 IfxPort_resetESR
80004f48 g     F .text	00000072 IfxAsclin_Asc_isrError
800047b2 g     F .text	00000024 IfxVadc_initialiseAdcArbiterClock
80004c3c g     F .text	00000014 IfxAsclin_getSrcPointerRx
800036e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_183
8000049c g     O .rodata	00000010 IfxAsclin0_TX_P15_3_OUT
80003cc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_230
80004c28 g     F .text	00000014 IfxAsclin_getSrcPointerEr
00002000 g       *ABS*	00000000 __CSA1_SIZE
800022c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_22
800003ec g     O .rodata	00000010 IfxAsclin1_TX_P33_13_OUT
8000082c g     O .rodata	00000010 IfxAsclin1_RXC_P20_9_IN
80008fe6 g     F .text	00000016 DisableAllInterrupts
80008074 g     F .text	0000005e Ifx_CircularBuffer_write8
8000514a g     F .text	00000096 IfxAsclin_Asc_isrReceive
800058f4 g     F .text	00000090 IfxPort_setGroupModeInput
80008182 g     F .text	000000da Ifx_Fifo_canReadCount
00001000 g       *ABS*	00000000 __USTACK_SIZE
80009262 g     F .text	000000d6 ChainTask
80006e16 g     F .text	00000034 IfxScuEru_selectExternalInput
80006cf6 g     F .text	00000026 IfxScuEru_enableFallingEdgeDetection
80002ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_101
8000090c g     O .rodata	00000010 IfxAsclin2_CTSA_P10_7_IN
5001a600 g       .CPU2.ustack	00000000 __USTACK2_AREA_END
8000078c g     O .rodata	00000010 IfxAsclin2_RXF_P32_6_IN
80002fc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_126
8000060c g     O .rodata	00000010 IfxAsclin3_SCLK_P11_4_OUT
800065b2 g     F .text	00000014 IfxScuCcu_initConfig
80003b20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_217
80003ba0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_221
800002dc g     O .rodata	00000010 IfxAsclin3_TX_P21_7_OUT
80004824 g     F .text	00000066 IfxVadc_initializeFAdcI
8000054c g     O .rodata	00000010 IfxAsclin2_SLSO_P10_5_OUT
80000b40 g     O .rodata	00000014 IfxScu_REQ8_P33_7_IN
800002ac g     O .rodata	00000010 IfxAsclin3_TX_P32_2_OUT
80001100 g       .traptab	00000000 osEE_tc_trap_mmu
80008024 g     F .text	00000050 Ifx_CircularBuffer_read32
80002ae0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_87
80004fc8 g     F .text	0000009c IfxAsclin_Asc_flushTx
80008f92 g     F .text	00000028 osEE_tc_delay
8000062c g     O .rodata	00000010 IfxAsclin3_SCLK_P00_2_OUT
80000f8c g     O .rodata	00000000 __clear_table
80005d2a g     F .text	00000064 IfxScuCcu_getPllErayFrequency
800007fc g     O .rodata	00000010 IfxAsclin1_RXF_P33_13_IN
80009a88 g     F .text	0000001e osEE_task_end
800005dc g     O .rodata	00000010 IfxAsclin3_SCLK_P20_0_OUT
80002dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_110
80002f80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_124
80003bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_222
80002240 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_18
80002440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_34
8000084c g     O .rodata	00000010 IfxAsclin1_RXA_P15_1_IN
80001200 g       .ctors	00000000 __EH_FRAME_BEGIN__
8000052c g     O .rodata	00000010 IfxAsclin3_SLSO_P00_3_OUT
80002840 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_66
80003140 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_138
80003e60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_243
80005e88 g     F .text	00000024 IfxScuCcu_getSourceFrequency
8000048c g     O .rodata	00000010 IfxAsclin0_TX_P34_1_OUT
80000d44 g     O .rodata	00000010 IfxScu_DCDCSYNC_P33_13_OUT
80000c1c g     O .rodata	00000014 IfxScu_REQ13_P15_5_IN
80009cd2 g     F .text	00000020 osEE_change_context_from_task_end
800096d8 g     F .text	0000007a WaitEvent
8000585e g     F .text	00000030 IfxPort_disableEmergencyStop
80003fa0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_253
80003c20 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_225
8000031c g     O .rodata	00000010 IfxAsclin3_TX_P15_6_OUT
80002880 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_68
80007d40 g     F .text	0000002e IfxVadc_Adc_initGroupConfig
00000400 g       *ABS*	00000000 __ISTACK0_SIZE
80002980 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_76
5001b600 g       .CPU2.ustack	00000000 __USTACK2
80003940 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_202
80008f74 g     F .text	0000001e osEE_tc_stm_set_sr1_next_match
0001e000 g       *ABS*	00000000 __DSPR1_SIZE
80003260 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_147
80000020 g       .startup	00000000 BootModeIndex
800032c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_150
80003d80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_236
700000f4 g     O .data	00000004 __malloc_trim_threshold
800031a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_141
80002d00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_104
800046be g     F .text	00000004 IfxVadc_getAdcModuleFrequency
800084f8 g     F .text	00000186 Ifx_Fifo_write
8000d3e2 g     F .text	000000ca __mdiff
800020e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_7
80002920 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_73
80009ac8 g     F .text	00000022 osEE_activate_isr2
800079a0 g     F .text	00000016 IfxVadc_Adc_initChannelConfig
80004b40 g     F .text	00000074 IfxAsclin_getFaFrequency
800068ce g     F .text	00000050 IfxScuCcu_setPll2Frequency
80003dc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_238
80020000 g       .startup	00000000 BootModeHeader1
80008b3e g     F .text	0000022e osEE_tc_set_pll_fsource
800047fa g     F .text	0000002a IfxVadc_initializeFAdcD
80004070 g     F .text	00000072 UART_init
80005a16 g     F .text	000000a4 IfxPort_setGroupPadDriver
800026e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_55
0001c000 g       *ABS*	00000000 __DSPR0_SIZE
80002fe0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_127
80002b80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_92
80000d04 g     O .rodata	00000010 IfxScu_EVRWUPB_P15_1_IN
8000087c g     O .rodata	00000010 IfxAsclin0_RXA_P14_1_IN
80004f02 g     F .text	00000012 IfxAsclin_write8
80006e08 g     F .text	0000000e IfxScuEru_getWholePatternDetectionResult
80002320 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_25
800039c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_206
800029e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_79
80000ff4 g     O .rodata	00000000 __copy_table
00019700 g       *ABS*	00000000 __ISTACK0_OFFSET
80004edc g     F .text	00000014 IfxAsclin_write16
800083d2 g     F .text	00000036 Ifx_Fifo_clear
80000bb8 g     O .rodata	00000014 IfxScu_REQ2_P10_2_IN
00000400 g       *ABS*	00000000 __ISTACK2_SIZE
80002ee0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_119
8000db38 g     F .text	00000010 _exit
80002280 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_20
80001120 g       .traptab	00000000 osEE_tc_trap_protection
80001100 g     F .traptab	00000000 __TRAPTAB
80000c44 g     O .rodata	00000014 IfxScu_REQ11_P20_9_IN
00002000 g       *ABS*	00000000 __CSA2_SIZE
80006bb4 g     F .text	00000028 IfxScuEru_clearOutputChannelConfiguration
800035a0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_173
80006caa g     F .text	00000026 IfxScuEru_disableTriggerPulse
80007306 g     F .text	000000aa IfxScuWdt_initSafetyWatchdog
80004f24 g     F .text	00000006 IfxAsclin_Asc_getSendCount
8000ad02 g     F .text	00000014 strlen
80003860 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_195
0001b700 g       *ABS*	00000000 __ISTACK2_OFFSET
80004ce6 g     F .text	00000022 IfxAsclin_setClockSource
8000dc60 g     F .text	00000040 .hidden __gedf2
80000a6c g     O .rodata	00000008 IfxScuCcu_defaultErayPllConfig
800043be g     F .text	000000a2 initPeripheralsAndERU
8000077c g     O .rodata	00000010 IfxAsclin2_RXG_P02_0_IN
80002bc0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_94
80002720 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_57
80003420 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_161
800003dc g     O .rodata	00000010 IfxAsclin2_TX_P02_0_OUT
80002f40 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_122
80000b7c g     O .rodata	00000014 IfxScu_REQ5_P10_8_IN
80004a14 g     F .text	00000056 IfxVadc_setArbiterPriority
70000c50 g     O .text	00000001 __HEAP_END
8000056c g     O .rodata	00000010 IfxAsclin1_SLSO_P33_10_OUT
6001bc00 g       .CPU1.csa	00000000 __CSA1
80005f58 g     F .text	00000070 IfxScuCcu_getMaxFrequency
80008ffc g     F .text	0000001c EnableAllInterrupts
8000058c g     O .rodata	00000010 IfxAsclin1_SLSO_P14_3_OUT
80004a7e g     F .text	00000044 IfxVadc_startupCalibration
7000095c g     O .bss	00000004 g_vadc
80005aba g     F .text	00000056 IfxPort_setPinMode
80003640 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_178
80002780 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_60
80000b54 g     O .rodata	00000014 IfxScu_REQ7_P00_4_IN
80009dc8 g     F .text	0000001a osEE_hal_restore_ctx
800042c6 g     F .text	00000032 initVADCGroup
800005cc g     O .rodata	00000010 IfxAsclin3_SCLK_P21_5_OUT
8000a12e g     F .text	00000040 .hidden __subdf3
70008000 g     O *ABS*	00000000 _SMALL_DATA_
80004f2a g     F .text	00000006 IfxAsclin_Asc_getTxTimeStamp
8000488a g     F .text	0000006a IfxVadc_isPostCalibration
800042a8 g     F .text	0000001e initVADCModule
80003f00 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_248
80006b76 g     F .text	00000016 IfxScuEru_clearEventFlag
800072d4 g     F .text	00000032 IfxScuWdt_setSafetyEndinit
8000d0da g     F .text	00000066 __lo0bits
800034c0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_166
80002000 g     F .inttab_cpu0	00002000 __INTTAB0
8000036c g     O .rodata	00000010 IfxAsclin2_TX_P33_9_OUT
80003080 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_132
80005cfa g     F .text	00000030 IfxScuCcu_getOscFrequency
800090dc g     F .text	0000003c ResumeOSInterrupts
800030e0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_135
80004c9a g     F .text	0000004c IfxAsclin_resetModule
80006dae g     F .text	00000024 IfxScuEru_getInputChannelConfiguration
8000068c g     O .rodata	00000010 IfxAsclin2_SCLK_P02_4_OUT
80006b64 g     F .text	00000012 IfxScuEru_clearAllEventFlags
80003200 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_144
80002d60 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_107
80002160 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_11
800000dc g     O .rodata	00000008 osEE_cdb_var
8000a5a8 g     F .text	00000112 .hidden __pack_d
8000094c g     O .rodata	00000020 IfxAsclin_cfg_indexMap
80009118 g     F .text	000000ac StartOS
80003ca0 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_229
80000cbc g     O .rodata	0000000c IfxScu_HWCFG1EVR33_P14_5_IN
80000b90 g     O .rodata	00000014 IfxScu_REQ4_P10_7_IN
80003440 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_162
8000a838 g     F .text	0000000e free
80000aec g     O .rodata	00000010 IfxScu_WDTSLCK_P20_9_OUT
8000d016 g     F .text	00000082 __multadd
8000d004 g     F .text	00000012 _Bfree
800006ac g     O .rodata	00000010 IfxAsclin1_SCLK_P33_11_OUT
80008000 g     O *ABS*	00000000 _SMALL_DATA3_
80003a80 g       .inttab_cpu0	00000000 osEE_tc_isr_dummy_entry_212



Disassembly of section .startup:

80000020 <_start>:
#endif

void _start(void)
{
  /* asm instruction to jump to the core startup */
  osEE_tc_jump_abs(osEE_tc_core0_start);
80000020:	9d 80 3f 43 	ja 8000867e <osEE_tc_core0_start>
80000024:	00 90       	ret 

Disassembly of section .traptab:

80001100 <__TRAPTAB>:
80001100:	00 a0       	debug 
80001102:	1d ff ff ff 	j 80001100 <__TRAPTAB>
	...

80001120 <osEE_tc_trap_protection>:
80001120:	00 a0       	debug 
80001122:	1d ff ff ff 	j 80001120 <osEE_tc_trap_protection>
	...

80001140 <osEE_tc_trap_instruction>:
80001140:	00 a0       	debug 
80001142:	1d ff ff ff 	j 80001140 <osEE_tc_trap_instruction>
	...

80001160 <osEE_tc_trap_context>:
80001160:	00 a0       	debug 
80001162:	1d ff ff ff 	j 80001160 <osEE_tc_trap_context>
	...

80001180 <osEE_tc_trap_bus>:
80001180:	00 a0       	debug 
80001182:	1d ff ff ff 	j 80001180 <osEE_tc_trap_bus>
	...

800011a0 <osEE_tc_trap_assertion>:
800011a0:	00 a0       	debug 
800011a2:	1d ff ff ff 	j 800011a0 <osEE_tc_trap_assertion>
	...

800011c0 <osEE_tc_trap_system>:
800011c0:	00 a0       	debug 
800011c2:	1d ff ff ff 	j 800011c0 <osEE_tc_trap_system>
	...

800011e0 <osEE_tc_trap_nmi>:
800011e0:	00 a0       	debug 
800011e2:	1d ff ff ff 	j 800011e0 <osEE_tc_trap_nmi>
	...

Disassembly of section .ctors:

80001200 <__CTOR_LIST__>:
	...

Disassembly of section .dtors:

80001208 <__DTOR_LIST__>:
	...

Disassembly of section .inttab_cpu0:

80002000 <__INTTAB0>:
	...

80002020 <osEE_tc_isr_dummy_entry_1>:
80002020:	3c 00       	j 80002020 <osEE_tc_isr_dummy_entry_1>
	...

80002040 <osEE_tc_isr2_entry_2>:
80002040:	0d 00 00 02 	svlcx 
80002044:	82 14       	mov %d4,1
80002046:	1d 00 ba 37 	j 80008fba <osEE_tc_isr2_wrapper>
	...

80002060 <osEE_tc_isr_dummy_entry_3>:
80002060:	3c 00       	j 80002060 <osEE_tc_isr_dummy_entry_3>
	...

80002080 <osEE_tc_isr_dummy_entry_4>:
80002080:	3c 00       	j 80002080 <osEE_tc_isr_dummy_entry_4>
	...

800020a0 <osEE_tc_isr_dummy_entry_5>:
800020a0:	3c 00       	j 800020a0 <osEE_tc_isr_dummy_entry_5>
	...

800020c0 <osEE_tc_isr_dummy_entry_6>:
800020c0:	3c 00       	j 800020c0 <osEE_tc_isr_dummy_entry_6>
	...

800020e0 <osEE_tc_isr_dummy_entry_7>:
800020e0:	3c 00       	j 800020e0 <osEE_tc_isr_dummy_entry_7>
	...

80002100 <osEE_tc_isr_dummy_entry_8>:
80002100:	3c 00       	j 80002100 <osEE_tc_isr_dummy_entry_8>
	...

80002120 <osEE_tc_isr_dummy_entry_9>:
80002120:	3c 00       	j 80002120 <osEE_tc_isr_dummy_entry_9>
	...

80002140 <osEE_tc_isr_dummy_entry_10>:
80002140:	3c 00       	j 80002140 <osEE_tc_isr_dummy_entry_10>
	...

80002160 <osEE_tc_isr_dummy_entry_11>:
80002160:	3c 00       	j 80002160 <osEE_tc_isr_dummy_entry_11>
	...

80002180 <osEE_tc_isr_dummy_entry_12>:
80002180:	3c 00       	j 80002180 <osEE_tc_isr_dummy_entry_12>
	...

800021a0 <osEE_tc_isr_dummy_entry_13>:
800021a0:	3c 00       	j 800021a0 <osEE_tc_isr_dummy_entry_13>
	...

800021c0 <osEE_tc_isr_dummy_entry_14>:
800021c0:	3c 00       	j 800021c0 <osEE_tc_isr_dummy_entry_14>
	...

800021e0 <osEE_tc_isr_dummy_entry_15>:
800021e0:	3c 00       	j 800021e0 <osEE_tc_isr_dummy_entry_15>
	...

80002200 <osEE_tc_isr_dummy_entry_16>:
80002200:	3c 00       	j 80002200 <osEE_tc_isr_dummy_entry_16>
	...

80002220 <osEE_tc_isr_dummy_entry_17>:
80002220:	3c 00       	j 80002220 <osEE_tc_isr_dummy_entry_17>
	...

80002240 <osEE_tc_isr_dummy_entry_18>:
80002240:	3c 00       	j 80002240 <osEE_tc_isr_dummy_entry_18>
	...

80002260 <osEE_tc_isr2_entry_19>:
80002260:	0d 00 00 02 	svlcx 
80002264:	82 04       	mov %d4,0
80002266:	1d 00 aa 36 	j 80008fba <osEE_tc_isr2_wrapper>
	...

80002280 <osEE_tc_isr_dummy_entry_20>:
80002280:	3c 00       	j 80002280 <osEE_tc_isr_dummy_entry_20>
	...

800022a0 <osEE_tc_isr_dummy_entry_21>:
800022a0:	3c 00       	j 800022a0 <osEE_tc_isr_dummy_entry_21>
	...

800022c0 <osEE_tc_isr_dummy_entry_22>:
800022c0:	3c 00       	j 800022c0 <osEE_tc_isr_dummy_entry_22>
	...

800022e0 <osEE_tc_isr_dummy_entry_23>:
800022e0:	3c 00       	j 800022e0 <osEE_tc_isr_dummy_entry_23>
	...

80002300 <osEE_tc_isr_dummy_entry_24>:
80002300:	3c 00       	j 80002300 <osEE_tc_isr_dummy_entry_24>
	...

80002320 <osEE_tc_isr_dummy_entry_25>:
80002320:	3c 00       	j 80002320 <osEE_tc_isr_dummy_entry_25>
	...

80002340 <osEE_tc_isr_dummy_entry_26>:
80002340:	3c 00       	j 80002340 <osEE_tc_isr_dummy_entry_26>
	...

80002360 <osEE_tc_isr_dummy_entry_27>:
80002360:	3c 00       	j 80002360 <osEE_tc_isr_dummy_entry_27>
	...

80002380 <osEE_tc_isr_dummy_entry_28>:
80002380:	3c 00       	j 80002380 <osEE_tc_isr_dummy_entry_28>
	...

800023a0 <osEE_tc_isr_dummy_entry_29>:
800023a0:	3c 00       	j 800023a0 <osEE_tc_isr_dummy_entry_29>
	...

800023c0 <osEE_tc_isr_dummy_entry_30>:
800023c0:	3c 00       	j 800023c0 <osEE_tc_isr_dummy_entry_30>
	...

800023e0 <osEE_tc_isr_dummy_entry_31>:
800023e0:	3c 00       	j 800023e0 <osEE_tc_isr_dummy_entry_31>
	...

80002400 <osEE_tc_isr_dummy_entry_32>:
80002400:	3c 00       	j 80002400 <osEE_tc_isr_dummy_entry_32>
	...

80002420 <osEE_tc_isr_dummy_entry_33>:
80002420:	3c 00       	j 80002420 <osEE_tc_isr_dummy_entry_33>
	...

80002440 <osEE_tc_isr_dummy_entry_34>:
80002440:	3c 00       	j 80002440 <osEE_tc_isr_dummy_entry_34>
	...

80002460 <osEE_tc_isr_dummy_entry_35>:
80002460:	3c 00       	j 80002460 <osEE_tc_isr_dummy_entry_35>
	...

80002480 <osEE_tc_isr_dummy_entry_36>:
80002480:	3c 00       	j 80002480 <osEE_tc_isr_dummy_entry_36>
	...

800024a0 <osEE_tc_isr_dummy_entry_37>:
800024a0:	3c 00       	j 800024a0 <osEE_tc_isr_dummy_entry_37>
	...

800024c0 <osEE_tc_isr_dummy_entry_38>:
800024c0:	3c 00       	j 800024c0 <osEE_tc_isr_dummy_entry_38>
	...

800024e0 <osEE_tc_isr_dummy_entry_39>:
800024e0:	3c 00       	j 800024e0 <osEE_tc_isr_dummy_entry_39>
	...

80002500 <osEE_tc_isr_dummy_entry_40>:
80002500:	3c 00       	j 80002500 <osEE_tc_isr_dummy_entry_40>
	...

80002520 <osEE_tc_isr_dummy_entry_41>:
80002520:	3c 00       	j 80002520 <osEE_tc_isr_dummy_entry_41>
	...

80002540 <osEE_tc_isr_dummy_entry_42>:
80002540:	3c 00       	j 80002540 <osEE_tc_isr_dummy_entry_42>
	...

80002560 <osEE_tc_isr_dummy_entry_43>:
80002560:	3c 00       	j 80002560 <osEE_tc_isr_dummy_entry_43>
	...

80002580 <osEE_tc_isr_dummy_entry_44>:
80002580:	3c 00       	j 80002580 <osEE_tc_isr_dummy_entry_44>
	...

800025a0 <osEE_tc_isr_dummy_entry_45>:
800025a0:	3c 00       	j 800025a0 <osEE_tc_isr_dummy_entry_45>
	...

800025c0 <osEE_tc_isr_dummy_entry_46>:
800025c0:	3c 00       	j 800025c0 <osEE_tc_isr_dummy_entry_46>
	...

800025e0 <osEE_tc_isr_dummy_entry_47>:
800025e0:	3c 00       	j 800025e0 <osEE_tc_isr_dummy_entry_47>
	...

80002600 <osEE_tc_isr_dummy_entry_48>:
80002600:	3c 00       	j 80002600 <osEE_tc_isr_dummy_entry_48>
	...

80002620 <osEE_tc_isr_dummy_entry_49>:
80002620:	3c 00       	j 80002620 <osEE_tc_isr_dummy_entry_49>
	...

80002640 <osEE_tc_isr_dummy_entry_50>:
80002640:	3c 00       	j 80002640 <osEE_tc_isr_dummy_entry_50>
	...

80002660 <osEE_tc_isr_dummy_entry_51>:
80002660:	3c 00       	j 80002660 <osEE_tc_isr_dummy_entry_51>
	...

80002680 <osEE_tc_isr_dummy_entry_52>:
80002680:	3c 00       	j 80002680 <osEE_tc_isr_dummy_entry_52>
	...

800026a0 <osEE_tc_isr_dummy_entry_53>:
800026a0:	3c 00       	j 800026a0 <osEE_tc_isr_dummy_entry_53>
	...

800026c0 <osEE_tc_isr_dummy_entry_54>:
800026c0:	3c 00       	j 800026c0 <osEE_tc_isr_dummy_entry_54>
	...

800026e0 <osEE_tc_isr_dummy_entry_55>:
800026e0:	3c 00       	j 800026e0 <osEE_tc_isr_dummy_entry_55>
	...

80002700 <osEE_tc_isr_dummy_entry_56>:
80002700:	3c 00       	j 80002700 <osEE_tc_isr_dummy_entry_56>
	...

80002720 <osEE_tc_isr_dummy_entry_57>:
80002720:	3c 00       	j 80002720 <osEE_tc_isr_dummy_entry_57>
	...

80002740 <osEE_tc_isr_dummy_entry_58>:
80002740:	3c 00       	j 80002740 <osEE_tc_isr_dummy_entry_58>
	...

80002760 <osEE_tc_isr_dummy_entry_59>:
80002760:	3c 00       	j 80002760 <osEE_tc_isr_dummy_entry_59>
	...

80002780 <osEE_tc_isr_dummy_entry_60>:
80002780:	3c 00       	j 80002780 <osEE_tc_isr_dummy_entry_60>
	...

800027a0 <osEE_tc_isr_dummy_entry_61>:
800027a0:	3c 00       	j 800027a0 <osEE_tc_isr_dummy_entry_61>
	...

800027c0 <osEE_tc_isr_dummy_entry_62>:
800027c0:	3c 00       	j 800027c0 <osEE_tc_isr_dummy_entry_62>
	...

800027e0 <osEE_tc_isr_dummy_entry_63>:
800027e0:	3c 00       	j 800027e0 <osEE_tc_isr_dummy_entry_63>
	...

80002800 <osEE_tc_isr_dummy_entry_64>:
80002800:	3c 00       	j 80002800 <osEE_tc_isr_dummy_entry_64>
	...

80002820 <osEE_tc_isr_dummy_entry_65>:
80002820:	3c 00       	j 80002820 <osEE_tc_isr_dummy_entry_65>
	...

80002840 <osEE_tc_isr_dummy_entry_66>:
80002840:	3c 00       	j 80002840 <osEE_tc_isr_dummy_entry_66>
	...

80002860 <osEE_tc_isr_dummy_entry_67>:
80002860:	3c 00       	j 80002860 <osEE_tc_isr_dummy_entry_67>
	...

80002880 <osEE_tc_isr_dummy_entry_68>:
80002880:	3c 00       	j 80002880 <osEE_tc_isr_dummy_entry_68>
	...

800028a0 <osEE_tc_isr_dummy_entry_69>:
800028a0:	3c 00       	j 800028a0 <osEE_tc_isr_dummy_entry_69>
	...

800028c0 <osEE_tc_isr_dummy_entry_70>:
800028c0:	3c 00       	j 800028c0 <osEE_tc_isr_dummy_entry_70>
	...

800028e0 <osEE_tc_isr_dummy_entry_71>:
800028e0:	3c 00       	j 800028e0 <osEE_tc_isr_dummy_entry_71>
	...

80002900 <osEE_tc_isr_dummy_entry_72>:
80002900:	3c 00       	j 80002900 <osEE_tc_isr_dummy_entry_72>
	...

80002920 <osEE_tc_isr_dummy_entry_73>:
80002920:	3c 00       	j 80002920 <osEE_tc_isr_dummy_entry_73>
	...

80002940 <osEE_tc_isr_dummy_entry_74>:
80002940:	3c 00       	j 80002940 <osEE_tc_isr_dummy_entry_74>
	...

80002960 <osEE_tc_isr_dummy_entry_75>:
80002960:	3c 00       	j 80002960 <osEE_tc_isr_dummy_entry_75>
	...

80002980 <osEE_tc_isr_dummy_entry_76>:
80002980:	3c 00       	j 80002980 <osEE_tc_isr_dummy_entry_76>
	...

800029a0 <osEE_tc_isr_dummy_entry_77>:
800029a0:	3c 00       	j 800029a0 <osEE_tc_isr_dummy_entry_77>
	...

800029c0 <osEE_tc_isr_dummy_entry_78>:
800029c0:	3c 00       	j 800029c0 <osEE_tc_isr_dummy_entry_78>
	...

800029e0 <osEE_tc_isr_dummy_entry_79>:
800029e0:	3c 00       	j 800029e0 <osEE_tc_isr_dummy_entry_79>
	...

80002a00 <osEE_tc_isr_dummy_entry_80>:
80002a00:	3c 00       	j 80002a00 <osEE_tc_isr_dummy_entry_80>
	...

80002a20 <osEE_tc_isr_dummy_entry_81>:
80002a20:	3c 00       	j 80002a20 <osEE_tc_isr_dummy_entry_81>
	...

80002a40 <osEE_tc_isr_dummy_entry_82>:
80002a40:	3c 00       	j 80002a40 <osEE_tc_isr_dummy_entry_82>
	...

80002a60 <osEE_tc_isr_dummy_entry_83>:
80002a60:	3c 00       	j 80002a60 <osEE_tc_isr_dummy_entry_83>
	...

80002a80 <osEE_tc_isr_dummy_entry_84>:
80002a80:	3c 00       	j 80002a80 <osEE_tc_isr_dummy_entry_84>
	...

80002aa0 <osEE_tc_isr_dummy_entry_85>:
80002aa0:	3c 00       	j 80002aa0 <osEE_tc_isr_dummy_entry_85>
	...

80002ac0 <osEE_tc_isr_dummy_entry_86>:
80002ac0:	3c 00       	j 80002ac0 <osEE_tc_isr_dummy_entry_86>
	...

80002ae0 <osEE_tc_isr_dummy_entry_87>:
80002ae0:	3c 00       	j 80002ae0 <osEE_tc_isr_dummy_entry_87>
	...

80002b00 <osEE_tc_isr_dummy_entry_88>:
80002b00:	3c 00       	j 80002b00 <osEE_tc_isr_dummy_entry_88>
	...

80002b20 <osEE_tc_isr_dummy_entry_89>:
80002b20:	3c 00       	j 80002b20 <osEE_tc_isr_dummy_entry_89>
	...

80002b40 <osEE_tc_isr_dummy_entry_90>:
80002b40:	3c 00       	j 80002b40 <osEE_tc_isr_dummy_entry_90>
	...

80002b60 <osEE_tc_isr_dummy_entry_91>:
80002b60:	3c 00       	j 80002b60 <osEE_tc_isr_dummy_entry_91>
	...

80002b80 <osEE_tc_isr_dummy_entry_92>:
80002b80:	3c 00       	j 80002b80 <osEE_tc_isr_dummy_entry_92>
	...

80002ba0 <osEE_tc_isr_dummy_entry_93>:
80002ba0:	3c 00       	j 80002ba0 <osEE_tc_isr_dummy_entry_93>
	...

80002bc0 <osEE_tc_isr_dummy_entry_94>:
80002bc0:	3c 00       	j 80002bc0 <osEE_tc_isr_dummy_entry_94>
	...

80002be0 <osEE_tc_isr_dummy_entry_95>:
80002be0:	3c 00       	j 80002be0 <osEE_tc_isr_dummy_entry_95>
	...

80002c00 <osEE_tc_isr_dummy_entry_96>:
80002c00:	3c 00       	j 80002c00 <osEE_tc_isr_dummy_entry_96>
	...

80002c20 <osEE_tc_isr_dummy_entry_97>:
80002c20:	3c 00       	j 80002c20 <osEE_tc_isr_dummy_entry_97>
	...

80002c40 <osEE_tc_isr_dummy_entry_98>:
80002c40:	3c 00       	j 80002c40 <osEE_tc_isr_dummy_entry_98>
	...

80002c60 <osEE_tc_isr_dummy_entry_99>:
80002c60:	3c 00       	j 80002c60 <osEE_tc_isr_dummy_entry_99>
	...

80002c80 <osEE_tc_isr_dummy_entry_100>:
80002c80:	3c 00       	j 80002c80 <osEE_tc_isr_dummy_entry_100>
	...

80002ca0 <osEE_tc_isr_dummy_entry_101>:
80002ca0:	3c 00       	j 80002ca0 <osEE_tc_isr_dummy_entry_101>
	...

80002cc0 <osEE_tc_isr_dummy_entry_102>:
80002cc0:	3c 00       	j 80002cc0 <osEE_tc_isr_dummy_entry_102>
	...

80002ce0 <osEE_tc_isr_dummy_entry_103>:
80002ce0:	3c 00       	j 80002ce0 <osEE_tc_isr_dummy_entry_103>
	...

80002d00 <osEE_tc_isr_dummy_entry_104>:
80002d00:	3c 00       	j 80002d00 <osEE_tc_isr_dummy_entry_104>
	...

80002d20 <osEE_tc_isr_dummy_entry_105>:
80002d20:	3c 00       	j 80002d20 <osEE_tc_isr_dummy_entry_105>
	...

80002d40 <osEE_tc_isr_dummy_entry_106>:
80002d40:	3c 00       	j 80002d40 <osEE_tc_isr_dummy_entry_106>
	...

80002d60 <osEE_tc_isr_dummy_entry_107>:
80002d60:	3c 00       	j 80002d60 <osEE_tc_isr_dummy_entry_107>
	...

80002d80 <osEE_tc_isr_dummy_entry_108>:
80002d80:	3c 00       	j 80002d80 <osEE_tc_isr_dummy_entry_108>
	...

80002da0 <osEE_tc_isr_dummy_entry_109>:
80002da0:	3c 00       	j 80002da0 <osEE_tc_isr_dummy_entry_109>
	...

80002dc0 <osEE_tc_isr_dummy_entry_110>:
80002dc0:	3c 00       	j 80002dc0 <osEE_tc_isr_dummy_entry_110>
	...

80002de0 <osEE_tc_isr_dummy_entry_111>:
80002de0:	3c 00       	j 80002de0 <osEE_tc_isr_dummy_entry_111>
	...

80002e00 <osEE_tc_isr_dummy_entry_112>:
80002e00:	3c 00       	j 80002e00 <osEE_tc_isr_dummy_entry_112>
	...

80002e20 <osEE_tc_isr_dummy_entry_113>:
80002e20:	3c 00       	j 80002e20 <osEE_tc_isr_dummy_entry_113>
	...

80002e40 <osEE_tc_isr_dummy_entry_114>:
80002e40:	3c 00       	j 80002e40 <osEE_tc_isr_dummy_entry_114>
	...

80002e60 <osEE_tc_isr_dummy_entry_115>:
80002e60:	3c 00       	j 80002e60 <osEE_tc_isr_dummy_entry_115>
	...

80002e80 <osEE_tc_isr_dummy_entry_116>:
80002e80:	3c 00       	j 80002e80 <osEE_tc_isr_dummy_entry_116>
	...

80002ea0 <osEE_tc_isr_dummy_entry_117>:
80002ea0:	3c 00       	j 80002ea0 <osEE_tc_isr_dummy_entry_117>
	...

80002ec0 <osEE_tc_isr_dummy_entry_118>:
80002ec0:	3c 00       	j 80002ec0 <osEE_tc_isr_dummy_entry_118>
	...

80002ee0 <osEE_tc_isr_dummy_entry_119>:
80002ee0:	3c 00       	j 80002ee0 <osEE_tc_isr_dummy_entry_119>
	...

80002f00 <osEE_tc_isr_dummy_entry_120>:
80002f00:	3c 00       	j 80002f00 <osEE_tc_isr_dummy_entry_120>
	...

80002f20 <osEE_tc_isr_dummy_entry_121>:
80002f20:	3c 00       	j 80002f20 <osEE_tc_isr_dummy_entry_121>
	...

80002f40 <osEE_tc_isr_dummy_entry_122>:
80002f40:	3c 00       	j 80002f40 <osEE_tc_isr_dummy_entry_122>
	...

80002f60 <osEE_tc_isr_dummy_entry_123>:
80002f60:	3c 00       	j 80002f60 <osEE_tc_isr_dummy_entry_123>
	...

80002f80 <osEE_tc_isr_dummy_entry_124>:
80002f80:	3c 00       	j 80002f80 <osEE_tc_isr_dummy_entry_124>
	...

80002fa0 <osEE_tc_isr_dummy_entry_125>:
80002fa0:	3c 00       	j 80002fa0 <osEE_tc_isr_dummy_entry_125>
	...

80002fc0 <osEE_tc_isr_dummy_entry_126>:
80002fc0:	3c 00       	j 80002fc0 <osEE_tc_isr_dummy_entry_126>
	...

80002fe0 <osEE_tc_isr_dummy_entry_127>:
80002fe0:	3c 00       	j 80002fe0 <osEE_tc_isr_dummy_entry_127>
	...

80003000 <osEE_tc_isr_dummy_entry_128>:
80003000:	3c 00       	j 80003000 <osEE_tc_isr_dummy_entry_128>
	...

80003020 <osEE_tc_isr_dummy_entry_129>:
80003020:	3c 00       	j 80003020 <osEE_tc_isr_dummy_entry_129>
	...

80003040 <osEE_tc_isr_dummy_entry_130>:
80003040:	3c 00       	j 80003040 <osEE_tc_isr_dummy_entry_130>
	...

80003060 <osEE_tc_isr_dummy_entry_131>:
80003060:	3c 00       	j 80003060 <osEE_tc_isr_dummy_entry_131>
	...

80003080 <osEE_tc_isr_dummy_entry_132>:
80003080:	3c 00       	j 80003080 <osEE_tc_isr_dummy_entry_132>
	...

800030a0 <osEE_tc_isr_dummy_entry_133>:
800030a0:	3c 00       	j 800030a0 <osEE_tc_isr_dummy_entry_133>
	...

800030c0 <osEE_tc_isr_dummy_entry_134>:
800030c0:	3c 00       	j 800030c0 <osEE_tc_isr_dummy_entry_134>
	...

800030e0 <osEE_tc_isr_dummy_entry_135>:
800030e0:	3c 00       	j 800030e0 <osEE_tc_isr_dummy_entry_135>
	...

80003100 <osEE_tc_isr_dummy_entry_136>:
80003100:	3c 00       	j 80003100 <osEE_tc_isr_dummy_entry_136>
	...

80003120 <osEE_tc_isr_dummy_entry_137>:
80003120:	3c 00       	j 80003120 <osEE_tc_isr_dummy_entry_137>
	...

80003140 <osEE_tc_isr_dummy_entry_138>:
80003140:	3c 00       	j 80003140 <osEE_tc_isr_dummy_entry_138>
	...

80003160 <osEE_tc_isr_dummy_entry_139>:
80003160:	3c 00       	j 80003160 <osEE_tc_isr_dummy_entry_139>
	...

80003180 <osEE_tc_isr_dummy_entry_140>:
80003180:	3c 00       	j 80003180 <osEE_tc_isr_dummy_entry_140>
	...

800031a0 <osEE_tc_isr_dummy_entry_141>:
800031a0:	3c 00       	j 800031a0 <osEE_tc_isr_dummy_entry_141>
	...

800031c0 <osEE_tc_isr_dummy_entry_142>:
800031c0:	3c 00       	j 800031c0 <osEE_tc_isr_dummy_entry_142>
	...

800031e0 <osEE_tc_isr_dummy_entry_143>:
800031e0:	3c 00       	j 800031e0 <osEE_tc_isr_dummy_entry_143>
	...

80003200 <osEE_tc_isr_dummy_entry_144>:
80003200:	3c 00       	j 80003200 <osEE_tc_isr_dummy_entry_144>
	...

80003220 <osEE_tc_isr_dummy_entry_145>:
80003220:	3c 00       	j 80003220 <osEE_tc_isr_dummy_entry_145>
	...

80003240 <osEE_tc_isr_dummy_entry_146>:
80003240:	3c 00       	j 80003240 <osEE_tc_isr_dummy_entry_146>
	...

80003260 <osEE_tc_isr_dummy_entry_147>:
80003260:	3c 00       	j 80003260 <osEE_tc_isr_dummy_entry_147>
	...

80003280 <osEE_tc_isr_dummy_entry_148>:
80003280:	3c 00       	j 80003280 <osEE_tc_isr_dummy_entry_148>
	...

800032a0 <osEE_tc_isr_dummy_entry_149>:
800032a0:	3c 00       	j 800032a0 <osEE_tc_isr_dummy_entry_149>
	...

800032c0 <osEE_tc_isr_dummy_entry_150>:
800032c0:	3c 00       	j 800032c0 <osEE_tc_isr_dummy_entry_150>
	...

800032e0 <osEE_tc_isr_dummy_entry_151>:
800032e0:	3c 00       	j 800032e0 <osEE_tc_isr_dummy_entry_151>
	...

80003300 <osEE_tc_isr_dummy_entry_152>:
80003300:	3c 00       	j 80003300 <osEE_tc_isr_dummy_entry_152>
	...

80003320 <osEE_tc_isr_dummy_entry_153>:
80003320:	3c 00       	j 80003320 <osEE_tc_isr_dummy_entry_153>
	...

80003340 <osEE_tc_isr_dummy_entry_154>:
80003340:	3c 00       	j 80003340 <osEE_tc_isr_dummy_entry_154>
	...

80003360 <osEE_tc_isr_dummy_entry_155>:
80003360:	3c 00       	j 80003360 <osEE_tc_isr_dummy_entry_155>
	...

80003380 <osEE_tc_isr_dummy_entry_156>:
80003380:	3c 00       	j 80003380 <osEE_tc_isr_dummy_entry_156>
	...

800033a0 <osEE_tc_isr_dummy_entry_157>:
800033a0:	3c 00       	j 800033a0 <osEE_tc_isr_dummy_entry_157>
	...

800033c0 <osEE_tc_isr_dummy_entry_158>:
800033c0:	3c 00       	j 800033c0 <osEE_tc_isr_dummy_entry_158>
	...

800033e0 <osEE_tc_isr_dummy_entry_159>:
800033e0:	3c 00       	j 800033e0 <osEE_tc_isr_dummy_entry_159>
	...

80003400 <osEE_tc_isr_dummy_entry_160>:
80003400:	3c 00       	j 80003400 <osEE_tc_isr_dummy_entry_160>
	...

80003420 <osEE_tc_isr_dummy_entry_161>:
80003420:	3c 00       	j 80003420 <osEE_tc_isr_dummy_entry_161>
	...

80003440 <osEE_tc_isr_dummy_entry_162>:
80003440:	3c 00       	j 80003440 <osEE_tc_isr_dummy_entry_162>
	...

80003460 <osEE_tc_isr_dummy_entry_163>:
80003460:	3c 00       	j 80003460 <osEE_tc_isr_dummy_entry_163>
	...

80003480 <osEE_tc_isr_dummy_entry_164>:
80003480:	3c 00       	j 80003480 <osEE_tc_isr_dummy_entry_164>
	...

800034a0 <osEE_tc_isr_dummy_entry_165>:
800034a0:	3c 00       	j 800034a0 <osEE_tc_isr_dummy_entry_165>
	...

800034c0 <osEE_tc_isr_dummy_entry_166>:
800034c0:	3c 00       	j 800034c0 <osEE_tc_isr_dummy_entry_166>
	...

800034e0 <osEE_tc_isr_dummy_entry_167>:
800034e0:	3c 00       	j 800034e0 <osEE_tc_isr_dummy_entry_167>
	...

80003500 <osEE_tc_isr_dummy_entry_168>:
80003500:	3c 00       	j 80003500 <osEE_tc_isr_dummy_entry_168>
	...

80003520 <osEE_tc_isr_dummy_entry_169>:
80003520:	3c 00       	j 80003520 <osEE_tc_isr_dummy_entry_169>
	...

80003540 <osEE_tc_isr_dummy_entry_170>:
80003540:	3c 00       	j 80003540 <osEE_tc_isr_dummy_entry_170>
	...

80003560 <osEE_tc_isr_dummy_entry_171>:
80003560:	3c 00       	j 80003560 <osEE_tc_isr_dummy_entry_171>
	...

80003580 <osEE_tc_isr_dummy_entry_172>:
80003580:	3c 00       	j 80003580 <osEE_tc_isr_dummy_entry_172>
	...

800035a0 <osEE_tc_isr_dummy_entry_173>:
800035a0:	3c 00       	j 800035a0 <osEE_tc_isr_dummy_entry_173>
	...

800035c0 <osEE_tc_isr_dummy_entry_174>:
800035c0:	3c 00       	j 800035c0 <osEE_tc_isr_dummy_entry_174>
	...

800035e0 <osEE_tc_isr_dummy_entry_175>:
800035e0:	3c 00       	j 800035e0 <osEE_tc_isr_dummy_entry_175>
	...

80003600 <osEE_tc_isr_dummy_entry_176>:
80003600:	3c 00       	j 80003600 <osEE_tc_isr_dummy_entry_176>
	...

80003620 <osEE_tc_isr_dummy_entry_177>:
80003620:	3c 00       	j 80003620 <osEE_tc_isr_dummy_entry_177>
	...

80003640 <osEE_tc_isr_dummy_entry_178>:
80003640:	3c 00       	j 80003640 <osEE_tc_isr_dummy_entry_178>
	...

80003660 <osEE_tc_isr_dummy_entry_179>:
80003660:	3c 00       	j 80003660 <osEE_tc_isr_dummy_entry_179>
	...

80003680 <osEE_tc_isr_dummy_entry_180>:
80003680:	3c 00       	j 80003680 <osEE_tc_isr_dummy_entry_180>
	...

800036a0 <osEE_tc_isr_dummy_entry_181>:
800036a0:	3c 00       	j 800036a0 <osEE_tc_isr_dummy_entry_181>
	...

800036c0 <osEE_tc_isr_dummy_entry_182>:
800036c0:	3c 00       	j 800036c0 <osEE_tc_isr_dummy_entry_182>
	...

800036e0 <osEE_tc_isr_dummy_entry_183>:
800036e0:	3c 00       	j 800036e0 <osEE_tc_isr_dummy_entry_183>
	...

80003700 <osEE_tc_isr_dummy_entry_184>:
80003700:	3c 00       	j 80003700 <osEE_tc_isr_dummy_entry_184>
	...

80003720 <osEE_tc_isr_dummy_entry_185>:
80003720:	3c 00       	j 80003720 <osEE_tc_isr_dummy_entry_185>
	...

80003740 <osEE_tc_isr_dummy_entry_186>:
80003740:	3c 00       	j 80003740 <osEE_tc_isr_dummy_entry_186>
	...

80003760 <osEE_tc_isr_dummy_entry_187>:
80003760:	3c 00       	j 80003760 <osEE_tc_isr_dummy_entry_187>
	...

80003780 <osEE_tc_isr_dummy_entry_188>:
80003780:	3c 00       	j 80003780 <osEE_tc_isr_dummy_entry_188>
	...

800037a0 <osEE_tc_isr_dummy_entry_189>:
800037a0:	3c 00       	j 800037a0 <osEE_tc_isr_dummy_entry_189>
	...

800037c0 <osEE_tc_isr_dummy_entry_190>:
800037c0:	3c 00       	j 800037c0 <osEE_tc_isr_dummy_entry_190>
	...

800037e0 <osEE_tc_isr_dummy_entry_191>:
800037e0:	3c 00       	j 800037e0 <osEE_tc_isr_dummy_entry_191>
	...

80003800 <osEE_tc_isr_dummy_entry_192>:
80003800:	3c 00       	j 80003800 <osEE_tc_isr_dummy_entry_192>
	...

80003820 <osEE_tc_isr_dummy_entry_193>:
80003820:	3c 00       	j 80003820 <osEE_tc_isr_dummy_entry_193>
	...

80003840 <osEE_tc_isr_dummy_entry_194>:
80003840:	3c 00       	j 80003840 <osEE_tc_isr_dummy_entry_194>
	...

80003860 <osEE_tc_isr_dummy_entry_195>:
80003860:	3c 00       	j 80003860 <osEE_tc_isr_dummy_entry_195>
	...

80003880 <osEE_tc_isr_dummy_entry_196>:
80003880:	3c 00       	j 80003880 <osEE_tc_isr_dummy_entry_196>
	...

800038a0 <osEE_tc_isr_dummy_entry_197>:
800038a0:	3c 00       	j 800038a0 <osEE_tc_isr_dummy_entry_197>
	...

800038c0 <osEE_tc_isr_dummy_entry_198>:
800038c0:	3c 00       	j 800038c0 <osEE_tc_isr_dummy_entry_198>
	...

800038e0 <osEE_tc_isr_dummy_entry_199>:
800038e0:	3c 00       	j 800038e0 <osEE_tc_isr_dummy_entry_199>
	...

80003900 <osEE_tc_isr_dummy_entry_200>:
80003900:	3c 00       	j 80003900 <osEE_tc_isr_dummy_entry_200>
	...

80003920 <osEE_tc_isr_dummy_entry_201>:
80003920:	3c 00       	j 80003920 <osEE_tc_isr_dummy_entry_201>
	...

80003940 <osEE_tc_isr_dummy_entry_202>:
80003940:	3c 00       	j 80003940 <osEE_tc_isr_dummy_entry_202>
	...

80003960 <osEE_tc_isr_dummy_entry_203>:
80003960:	3c 00       	j 80003960 <osEE_tc_isr_dummy_entry_203>
	...

80003980 <osEE_tc_isr_dummy_entry_204>:
80003980:	3c 00       	j 80003980 <osEE_tc_isr_dummy_entry_204>
	...

800039a0 <osEE_tc_isr_dummy_entry_205>:
800039a0:	3c 00       	j 800039a0 <osEE_tc_isr_dummy_entry_205>
	...

800039c0 <osEE_tc_isr_dummy_entry_206>:
800039c0:	3c 00       	j 800039c0 <osEE_tc_isr_dummy_entry_206>
	...

800039e0 <osEE_tc_isr_dummy_entry_207>:
800039e0:	3c 00       	j 800039e0 <osEE_tc_isr_dummy_entry_207>
	...

80003a00 <osEE_tc_isr_dummy_entry_208>:
80003a00:	3c 00       	j 80003a00 <osEE_tc_isr_dummy_entry_208>
	...

80003a20 <osEE_tc_isr_dummy_entry_209>:
80003a20:	3c 00       	j 80003a20 <osEE_tc_isr_dummy_entry_209>
	...

80003a40 <osEE_tc_isr_dummy_entry_210>:
80003a40:	3c 00       	j 80003a40 <osEE_tc_isr_dummy_entry_210>
	...

80003a60 <osEE_tc_isr_dummy_entry_211>:
80003a60:	3c 00       	j 80003a60 <osEE_tc_isr_dummy_entry_211>
	...

80003a80 <osEE_tc_isr_dummy_entry_212>:
80003a80:	3c 00       	j 80003a80 <osEE_tc_isr_dummy_entry_212>
	...

80003aa0 <osEE_tc_isr_dummy_entry_213>:
80003aa0:	3c 00       	j 80003aa0 <osEE_tc_isr_dummy_entry_213>
	...

80003ac0 <osEE_tc_isr_dummy_entry_214>:
80003ac0:	3c 00       	j 80003ac0 <osEE_tc_isr_dummy_entry_214>
	...

80003ae0 <osEE_tc_isr_dummy_entry_215>:
80003ae0:	3c 00       	j 80003ae0 <osEE_tc_isr_dummy_entry_215>
	...

80003b00 <osEE_tc_isr_dummy_entry_216>:
80003b00:	3c 00       	j 80003b00 <osEE_tc_isr_dummy_entry_216>
	...

80003b20 <osEE_tc_isr_dummy_entry_217>:
80003b20:	3c 00       	j 80003b20 <osEE_tc_isr_dummy_entry_217>
	...

80003b40 <osEE_tc_isr_dummy_entry_218>:
80003b40:	3c 00       	j 80003b40 <osEE_tc_isr_dummy_entry_218>
	...

80003b60 <osEE_tc_isr_dummy_entry_219>:
80003b60:	3c 00       	j 80003b60 <osEE_tc_isr_dummy_entry_219>
	...

80003b80 <osEE_tc_isr_dummy_entry_220>:
80003b80:	3c 00       	j 80003b80 <osEE_tc_isr_dummy_entry_220>
	...

80003ba0 <osEE_tc_isr_dummy_entry_221>:
80003ba0:	3c 00       	j 80003ba0 <osEE_tc_isr_dummy_entry_221>
	...

80003bc0 <osEE_tc_isr_dummy_entry_222>:
80003bc0:	3c 00       	j 80003bc0 <osEE_tc_isr_dummy_entry_222>
	...

80003be0 <osEE_tc_isr_dummy_entry_223>:
80003be0:	3c 00       	j 80003be0 <osEE_tc_isr_dummy_entry_223>
	...

80003c00 <osEE_tc_isr_dummy_entry_224>:
80003c00:	3c 00       	j 80003c00 <osEE_tc_isr_dummy_entry_224>
	...

80003c20 <osEE_tc_isr_dummy_entry_225>:
80003c20:	3c 00       	j 80003c20 <osEE_tc_isr_dummy_entry_225>
	...

80003c40 <osEE_tc_isr_dummy_entry_226>:
80003c40:	3c 00       	j 80003c40 <osEE_tc_isr_dummy_entry_226>
	...

80003c60 <osEE_tc_isr_dummy_entry_227>:
80003c60:	3c 00       	j 80003c60 <osEE_tc_isr_dummy_entry_227>
	...

80003c80 <osEE_tc_isr_dummy_entry_228>:
80003c80:	3c 00       	j 80003c80 <osEE_tc_isr_dummy_entry_228>
	...

80003ca0 <osEE_tc_isr_dummy_entry_229>:
80003ca0:	3c 00       	j 80003ca0 <osEE_tc_isr_dummy_entry_229>
	...

80003cc0 <osEE_tc_isr_dummy_entry_230>:
80003cc0:	3c 00       	j 80003cc0 <osEE_tc_isr_dummy_entry_230>
	...

80003ce0 <osEE_tc_isr_dummy_entry_231>:
80003ce0:	3c 00       	j 80003ce0 <osEE_tc_isr_dummy_entry_231>
	...

80003d00 <osEE_tc_isr_dummy_entry_232>:
80003d00:	3c 00       	j 80003d00 <osEE_tc_isr_dummy_entry_232>
	...

80003d20 <osEE_tc_isr_dummy_entry_233>:
80003d20:	3c 00       	j 80003d20 <osEE_tc_isr_dummy_entry_233>
	...

80003d40 <osEE_tc_isr_dummy_entry_234>:
80003d40:	3c 00       	j 80003d40 <osEE_tc_isr_dummy_entry_234>
	...

80003d60 <osEE_tc_isr_dummy_entry_235>:
80003d60:	3c 00       	j 80003d60 <osEE_tc_isr_dummy_entry_235>
	...

80003d80 <osEE_tc_isr_dummy_entry_236>:
80003d80:	3c 00       	j 80003d80 <osEE_tc_isr_dummy_entry_236>
	...

80003da0 <osEE_tc_isr_dummy_entry_237>:
80003da0:	3c 00       	j 80003da0 <osEE_tc_isr_dummy_entry_237>
	...

80003dc0 <osEE_tc_isr_dummy_entry_238>:
80003dc0:	3c 00       	j 80003dc0 <osEE_tc_isr_dummy_entry_238>
	...

80003de0 <osEE_tc_isr_dummy_entry_239>:
80003de0:	3c 00       	j 80003de0 <osEE_tc_isr_dummy_entry_239>
	...

80003e00 <osEE_tc_isr_dummy_entry_240>:
80003e00:	3c 00       	j 80003e00 <osEE_tc_isr_dummy_entry_240>
	...

80003e20 <osEE_tc_isr_dummy_entry_241>:
80003e20:	3c 00       	j 80003e20 <osEE_tc_isr_dummy_entry_241>
	...

80003e40 <osEE_tc_isr_dummy_entry_242>:
80003e40:	3c 00       	j 80003e40 <osEE_tc_isr_dummy_entry_242>
	...

80003e60 <osEE_tc_isr_dummy_entry_243>:
80003e60:	3c 00       	j 80003e60 <osEE_tc_isr_dummy_entry_243>
	...

80003e80 <osEE_tc_isr_dummy_entry_244>:
80003e80:	3c 00       	j 80003e80 <osEE_tc_isr_dummy_entry_244>
	...

80003ea0 <osEE_tc_isr_dummy_entry_245>:
80003ea0:	3c 00       	j 80003ea0 <osEE_tc_isr_dummy_entry_245>
	...

80003ec0 <osEE_tc_isr_dummy_entry_246>:
80003ec0:	3c 00       	j 80003ec0 <osEE_tc_isr_dummy_entry_246>
	...

80003ee0 <osEE_tc_isr_dummy_entry_247>:
80003ee0:	3c 00       	j 80003ee0 <osEE_tc_isr_dummy_entry_247>
	...

80003f00 <osEE_tc_isr_dummy_entry_248>:
80003f00:	3c 00       	j 80003f00 <osEE_tc_isr_dummy_entry_248>
	...

80003f20 <osEE_tc_isr_dummy_entry_249>:
80003f20:	3c 00       	j 80003f20 <osEE_tc_isr_dummy_entry_249>
	...

80003f40 <osEE_tc_isr_dummy_entry_250>:
80003f40:	3c 00       	j 80003f40 <osEE_tc_isr_dummy_entry_250>
	...

80003f60 <osEE_tc_isr_dummy_entry_251>:
80003f60:	3c 00       	j 80003f60 <osEE_tc_isr_dummy_entry_251>
	...

80003f80 <osEE_tc_isr_dummy_entry_252>:
80003f80:	3c 00       	j 80003f80 <osEE_tc_isr_dummy_entry_252>
	...

80003fa0 <osEE_tc_isr_dummy_entry_253>:
80003fa0:	3c 00       	j 80003fa0 <osEE_tc_isr_dummy_entry_253>
	...

80003fc0 <osEE_tc_isr_dummy_entry_254>:
80003fc0:	3c 00       	j 80003fc0 <osEE_tc_isr_dummy_entry_254>
	...

80003fe0 <osEE_tc_isr_dummy_entry_255>:
80003fe0:	3c 00       	j 80003fe0 <osEE_tc_isr_dummy_entry_255>
	...

Disassembly of section .text:

80004000 <FuncTask1>:
{
    TaskType id;
    //printfSerial("Task1 Begins...");
    //printState(Task1);
    //printState(Task2);
    mdelay(2000);
80004000:	3b 00 7d 40 	mov %d4,2000
80004004:	6d 00 a6 00 	call 80004150 <mdelay>
    ActivateTask(Task2);
80004008:	82 34       	mov %d4,3
8000400a:	6d 00 ea 28 	call 800091de <ActivateTask>
    //printState(Task1);
    //printState(Task2);
    mdelay(4000);
8000400e:	3b 00 fa 40 	mov %d4,4000
80004012:	6d 00 9f 00 	call 80004150 <mdelay>
    //GetTaskID(&id);
    //printfSerial("Task ID = %d...", id);
    //printfSerial("Task1 Finishes...");
    ChainTask(TaskM);
80004016:	82 54       	mov %d4,5
80004018:	1d 00 25 29 	j 80009262 <ChainTask>

8000401c <FuncTask2>:
{
    TaskType id;
    //printfSerial("Task2 Begins...");
    //printState(Task1);
    //printState(Task2);
    mdelay(4000);
8000401c:	3b 00 fa 40 	mov %d4,4000
80004020:	6d 00 98 00 	call 80004150 <mdelay>
    ActivateTask(Task3);
80004024:	82 44       	mov %d4,4
80004026:	6d 00 dc 28 	call 800091de <ActivateTask>
    mdelay(2000);
8000402a:	3b 00 7d 40 	mov %d4,2000
8000402e:	6d 00 91 00 	call 80004150 <mdelay>
    //GetTaskID(&id);
    //printfSerial("Task ID = %d...", id);
    //printfSerial("Task2 Finishes...");
    ChainTask(TaskM);
80004032:	82 54       	mov %d4,5
80004034:	1d 00 17 29 	j 80009262 <ChainTask>

80004038 <FuncTask3>:

TASK(Task3)
{   
    TaskType id;
    //printfSerial("Task3 Begins...");
    mdelay(3000);
80004038:	3b 80 bb 40 	mov %d4,3000
8000403c:	6d 00 8a 00 	call 80004150 <mdelay>
    //GetTaskID(&id);
    //printfSerial("Task ID = %d...", id);
    //printfSerial("Task3 Finishes...");
    TerminateTask();
80004040:	1d 00 7c 29 	j 80009338 <TerminateTask>

80004044 <FuncTaskM>:
}

TASK(TaskM){
80004044:	20 10       	sub.a %sp,16

    TaskType id;
    printState(Task1);
80004046:	82 24       	mov %d4,2
80004048:	6d 00 f8 00 	call 80004238 <printState>
    printState(Task2);
8000404c:	82 34       	mov %d4,3
8000404e:	6d 00 f5 00 	call 80004238 <printState>
    GetTaskID(&id);
80004052:	d9 a4 0c 00 	lea %a4,[%sp]12
80004056:	6d 00 d9 2a 	call 80009608 <GetTaskID>
    printfSerial("ID : %d", id);
8000405a:	58 03       	ld.w %d15,[%sp]12
8000405c:	91 00 00 48 	movh.a %a4,32768
80004060:	78 00       	st.w [%sp]0,%d15
80004062:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <_start+0x8>>
80004066:	6d 00 3e 00 	call 800040e2 <printfSerial>
    TerminateTask();
8000406a:	1d 00 67 29 	j 80009338 <TerminateTask>
	...

80004070 <UART_init>:
                                        IfxVadc_ChannelId_6,  /* AN38: channel 6 of group 4                         */
                                        IfxVadc_ChannelId_7}; /* AN39: channel 7 of group 4                         */


void UART_init(void)
{
80004070:	20 60       	sub.a %sp,96

    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);
80004072:	d9 a4 24 00 	lea %a4,[%sp]36
80004076:	c5 f5 80 40 	lea %a5,f0000900 <_SMALL_DATA4_+0x3fff8900>
    ascConfig.baudrate.prescaler    = 1;
8000407a:	82 1f       	mov %d15,1

void UART_init(void)
{

    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);
8000407c:	6d 00 aa 0a 	call 800055d0 <IfxAsclin_Asc_initModuleConfig>
    ascConfig.baudrate.prescaler    = 1;
80004080:	f9 af 2c 00 	st.h [%sp]44,%d15
    ascConfig.baudrate.baudrate     = 115200;
80004084:	7b 10 7e f4 	movh %d15,18401
80004088:	78 0a       	st.w [%sp]40,%d15
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;
8000408a:	82 3f       	mov %d15,3
8000408c:	e9 af 2e 00 	st.b [%sp]46,%d15

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;
80004090:	da 13       	mov %d15,19
80004092:	f9 af 00 10 	st.h [%sp]64,%d15


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80004096:	4d c0 e1 ff 	mfcr %d15,$core_id
    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
8000409a:	7b 00 00 28 	movh %d2,32768
8000409e:	60 23       	mov.a %a3,%d2
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800040a0:	37 0f 63 f0 	extr.u %d15,%d15,0,3
800040a4:	d9 af 04 00 	lea %a15,[%sp]4
800040a8:	40 f4       	mov.aa %a4,%a15
800040aa:	d9 32 30 00 	lea %a2,[%a3]48
    ascConfig.baudrate.baudrate     = 115200;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
800040ae:	e9 af 06 10 	st.b [%sp]70,%d15
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
800040b2:	a0 33       	mov.a %a3,3
800040b4:	09 22 48 01 	ld.d %e2,[%a2+]8
800040b8:	89 42 48 01 	st.d [%a4+]8,%e2
800040bc:	fc 3c       	loop %a3,800040b4 <UART_init+0x44>

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
800040be:	7b 00 00 f7 	movh %d15,28672
800040c2:	1b cf 96 f0 	addi %d15,%d15,2412
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
800040c6:	91 00 00 47 	movh.a %a4,28672

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
800040ca:	78 14       	st.w [%sp]80,%d15
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
800040cc:	d9 44 80 f0 	lea %a4,[%a4]3008 <70000bc0 <g_AsclinAsc+0x254>>
    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
800040d0:	3b 20 10 f0 	mov %d15,258
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
800040d4:	d9 a5 24 00 	lea %a5,[%sp]36
    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
800040d8:	f9 af 0e 10 	st.h [%sp]78,%d15
        &IfxAsclin3_RXD_P32_2_IN, IfxPort_InputMode_pullUp,        /* Rx pin */
        NULL_PTR,                     IfxPort_OutputMode_pushPull,     /* RTS pin not used */
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
800040dc:	f8 12       	st.a [%sp]72,%a15
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
800040de:	1d 00 a2 08 	j 80005222 <IfxAsclin_Asc_initModule>

800040e2 <printfSerial>:
    //printf("Asclin Asc is initialised\n");
}


void printfSerial(const char *fmt,...)
{
800040e2:	20 e8       	sub.a %sp,232
800040e4:	40 4f       	mov.aa %a15,%a4
    EnableAllInterrupts();
800040e6:	6d 00 8b 27 	call 80008ffc <EnableAllInterrupts>
    char buf[LEN_BUF];
    va_list args;
    va_start (args, fmt );
    vsnprintf(buf, LEN_BUF, fmt, args);
800040ea:	40 f5       	mov.aa %a5,%a15
800040ec:	d9 a4 28 10 	lea %a4,[%sp]104
800040f0:	3b 00 08 40 	mov %d4,128
800040f4:	d9 a6 28 30 	lea %a6,[%sp]232
800040f8:	6d 00 34 36 	call 8000ad60 <vsnprintf>
    va_end (args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinAsc.count = strlen(buf);
800040fc:	d9 a4 28 10 	lea %a4,[%sp]104
80004100:	6d 00 01 36 	call 8000ad02 <strlen>
80004104:	91 00 00 f7 	movh.a %a15,28672
80004108:	d9 ff ac 50 	lea %a15,[%a15]2412 <7000096c <g_AsclinAsc>>
8000410c:	f9 f2 3a 90 	st.h [%a15]634 <7000027a <__malloc_av_+0x182>>,%d2
    unsigned int i =0;
80004110:	82 0f       	mov %d15,0
    for(; i<strlen(buf);i++) {
80004112:	d9 a4 28 10 	lea %a4,[%sp]104
80004116:	6d 00 f6 35 	call 8000ad02 <strlen>
8000411a:	7f 2f 0c 80 	jge.u %d15,%d2,80004132 <printfSerial+0x50>
        txData[i] = buf[i];
8000411e:	d9 a3 04 00 	lea %a3,[%sp]4
80004122:	10 32       	addsc.a %a2,%a3,%d15,0
80004124:	d9 a3 28 10 	lea %a3,[%sp]104
80004128:	10 3f       	addsc.a %a15,%a3,%d15,0
    va_end (args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinAsc.count = strlen(buf);
    unsigned int i =0;
    for(; i<strlen(buf);i++) {
8000412a:	c2 1f       	add %d15,1
        txData[i] = buf[i];
8000412c:	08 02       	ld.bu %d2,[%a15]0
8000412e:	34 22       	st.b [%a2],%d2
80004130:	3c f1       	j 80004112 <printfSerial+0x30>
    }
    /* Transmit data */
    IfxAsclin_Asc_write(&g_AsclinAsc.drivers.asc, txData, &g_AsclinAsc.count, TIME_INFINITE);
80004132:	91 00 00 47 	movh.a %a4,28672
80004136:	91 00 00 67 	movh.a %a6,28672
8000413a:	82 f4       	mov %d4,-1
8000413c:	d9 44 80 f0 	lea %a4,[%a4]3008 <70000bc0 <g_AsclinAsc+0x254>>
80004140:	d9 a5 04 00 	lea %a5,[%sp]4 <70000bc0 <g_AsclinAsc+0x254>>
80004144:	d9 66 a6 f0 	lea %a6,[%a6]3046 <70000be6 <g_AsclinAsc+0x27a>>
80004148:	9b 04 00 58 	addih %d5,%d4,32768
8000414c:	1d 00 aa 0a 	j 800056a0 <IfxAsclin_Asc_write>

80004150 <mdelay>:

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004150:	85 fa 10 00 	ld.w %d10,f0000010 <_SMALL_DATA4_+0x3fff8010>
}

void mdelay(unsigned long delay_ms)
{
80004154:	02 4b       	mov %d11,%d4
    result |= ((uint64)stm->CAP.U) << 32;
80004156:	85 fc 2c 00 	ld.w %d12,f000002c <_SMALL_DATA4_+0x3fff802c>
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
8000415a:	6d 00 97 0e 	call 80005e88 <IfxScuCcu_getSourceFrequency>
8000415e:	91 30 00 ff 	movh.a %a15,61443
80004162:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80004166:	4c f0       	ld.w %d15,[%a15]0

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004168:	53 1a 40 80 	mul.u %e8,%d10,1
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
8000416c:	0b ac 10 48 	mov %e4,%d12,%d10
80004170:	37 0f 64 f4 	extr.u %d15,%d15,8,4
80004174:	a6 95       	or %d5,%d9
80004176:	02 28       	mov %d8,%d2
80004178:	6d 00 b2 2e 	call 80009edc <__floatundisf>
8000417c:	4b 0f 41 f1 	itof %d15,%d15
80004180:	7b a0 47 a4 	movh %d10,17530
80004184:	4b f8 51 f0 	div.f %d15,%d8,%d15
80004188:	40 fc       	mov.aa %a12,%a15
8000418a:	40 fd       	mov.aa %a13,%a15
8000418c:	4b af 51 f0 	div.f %d15,%d15,%d10
80004190:	4b f2 51 20 	div.f %d2,%d2,%d15
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004194:	02 ae       	mov %d14,%d10
    IfxAsclin_Asc_write(&g_AsclinAsc.drivers.asc, txData, &g_AsclinAsc.count, TIME_INFINITE);
}

void mdelay(unsigned long delay_ms)
{
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004196:	4b 02 71 f1 	ftouz %d15,%d2
8000419a:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000419e:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
800041a2:	6d 00 73 0e 	call 80005e88 <IfxScuCcu_getSourceFrequency>
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
800041a6:	3b 40 01 40 	mov %d4,20
800041aa:	4b 4b 11 42 	div.u %e4,%d11,%d4
800041ae:	48 02       	ld.w %d2,[%a15]0
}

void mdelay(unsigned long delay_ms)
{
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
    unsigned long period_ms = 20, cnt = 0;
800041b0:	82 0b       	mov %d11,0
    while (cnt < (delay_ms / period_ms)) {
800041b2:	02 4d       	mov %d13,%d4
800041b4:	5f db 41 00 	jeq %d11,%d13,80004236 <mdelay+0xe6>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800041b8:	85 fc 10 00 	ld.w %d12,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800041bc:	85 fe 2c 08 	ld.a %a14,f000002c <_SMALL_DATA4_+0x3fff802c>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800041c0:	53 1c 40 80 	mul.u %e8,%d12,1
800041c4:	6d 00 62 0e 	call 80005e88 <IfxScuCcu_getSourceFrequency>
800041c8:	54 c3       	ld.w %d3,[%a12]
    result |= ((uint64)stm->CAP.U) << 32;
800041ca:	80 e5       	mov.d %d5,%a14
800041cc:	37 03 64 34 	extr.u %d3,%d3,8,4
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
800041d0:	02 c4       	mov %d4,%d12
800041d2:	a6 95       	or %d5,%d9
800041d4:	60 3f       	mov.a %a15,%d3
800041d6:	02 28       	mov %d8,%d2
800041d8:	6d 00 82 2e 	call 80009edc <__floatundisf>
800041dc:	80 f4       	mov.d %d4,%a15
800041de:	4b 04 41 31 	itof %d3,%d4
800041e2:	4b 38 51 80 	div.f %d8,%d8,%d3
800041e6:	4b a8 51 80 	div.f %d8,%d8,%d10
800041ea:	4b 82 51 20 	div.f %d2,%d2,%d8
800041ee:	4b 02 71 21 	ftouz %d2,%d2
        if (current_ms - prev_ms >= period_ms) {
800041f2:	a2 f2       	sub %d2,%d15
800041f4:	8b 42 61 22 	lt.u %d2,%d2,20
800041f8:	df 02 de ff 	jne %d2,0,800041b4 <mdelay+0x64>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800041fc:	85 fc 10 00 	ld.w %d12,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80004200:	85 ff 2c 08 	ld.a %a15,f000002c <_SMALL_DATA4_+0x3fff802c>
80004204:	6d 00 42 0e 	call 80005e88 <IfxScuCcu_getSourceFrequency>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004208:	53 1c 40 80 	mul.u %e8,%d12,1
8000420c:	4c d0       	ld.w %d15,[%a13]0
    result |= ((uint64)stm->CAP.U) << 32;
8000420e:	80 f5       	mov.d %d5,%a15
80004210:	37 0f 64 f4 	extr.u %d15,%d15,8,4
            cnt++;
            prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004214:	02 c4       	mov %d4,%d12
80004216:	a6 95       	or %d5,%d9
80004218:	02 28       	mov %d8,%d2
8000421a:	6d 00 61 2e 	call 80009edc <__floatundisf>
8000421e:	4b 0f 41 f1 	itof %d15,%d15
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
        if (current_ms - prev_ms >= period_ms) {
            cnt++;
80004222:	c2 1b       	add %d11,1
80004224:	4b f8 51 f0 	div.f %d15,%d8,%d15
            prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004228:	4b ef 51 f0 	div.f %d15,%d15,%d14
8000422c:	4b f2 51 20 	div.f %d2,%d2,%d15
80004230:	4b 02 71 f1 	ftouz %d15,%d2
80004234:	3c c0       	j 800041b4 <mdelay+0x64>
        }
    }
}
80004236:	00 90       	ret 

80004238 <printState>:

void printState(TaskType id){
80004238:	20 10       	sub.a %sp,16
    TaskStateType state;

    if(GetTaskState(id, &state) == E_OK){
8000423a:	d9 a4 0f 00 	lea %a4,[%sp]15
            prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
        }
    }
}

void printState(TaskType id){
8000423e:	02 4f       	mov %d15,%d4
    TaskStateType state;

    if(GetTaskState(id, &state) == E_OK){
80004240:	6d 00 10 2a 	call 80009660 <GetTaskState>
80004244:	df 02 31 80 	jne %d2,0,800042a6 <printState+0x6e>
        switch(state){
80004248:	39 a2 0f 00 	ld.bu %d2,[%sp]15
8000424c:	ff 52 2d 80 	jge.u %d2,5,800042a6 <printState+0x6e>
80004250:	91 00 00 f8 	movh.a %a15,32768
80004254:	d9 ff 20 94 	lea %a15,[%a15]16992 <80004260 <printState+0x28>>
80004258:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
8000425c:	dc 0f       	ji %a15
8000425e:	00 00       	nop 
80004260:	1d 00 0a 00 	j 80004274 <printState+0x3c>
80004264:	1d 00 0e 00 	j 80004280 <printState+0x48>
80004268:	1d 00 1f 00 	j 800042a6 <printState+0x6e>
8000426c:	1d 00 10 00 	j 8000428c <printState+0x54>
80004270:	1d 00 14 00 	j 80004298 <printState+0x60>
            case SUSPENDED:
                printfSerial("%d: suspended...", id);
80004274:	91 00 00 48 	movh.a %a4,32768
80004278:	78 00       	st.w [%sp]0,%d15
8000427a:	d9 44 10 10 	lea %a4,[%a4]80 <80000050 <_start+0x30>>
8000427e:	3c 12       	j 800042a2 <printState+0x6a>
                break;
            case READY:
                printfSerial("%d: ready...", id);
80004280:	91 00 00 48 	movh.a %a4,32768
80004284:	78 00       	st.w [%sp]0,%d15
80004286:	d9 44 21 10 	lea %a4,[%a4]97 <80000061 <_start+0x41>>
8000428a:	3c 0c       	j 800042a2 <printState+0x6a>
                break;
            case WAITING:
                printfSerial("%d: waiting...", id);
8000428c:	91 00 00 48 	movh.a %a4,32768
80004290:	78 00       	st.w [%sp]0,%d15
80004292:	d9 44 2e 10 	lea %a4,[%a4]110 <8000006e <_start+0x4e>>
80004296:	3c 06       	j 800042a2 <printState+0x6a>
                break;
            case RUNNING:
                printfSerial("%d: running...", id);
80004298:	91 00 00 48 	movh.a %a4,32768
8000429c:	78 00       	st.w [%sp]0,%d15
8000429e:	d9 44 3d 10 	lea %a4,[%a4]125 <8000007d <_start+0x5d>>
800042a2:	6d ff 20 ff 	call 800040e2 <printfSerial>
800042a6:	00 90       	ret 

800042a8 <initVADCModule>:
    IfxVadc_Adc_startBackgroundScan(&g_vadc);
}

/* Function to initialize the VADC module with default parameters */
void initVADCModule(void)
{
800042a8:	20 28       	sub.a %sp,40
    IfxVadc_Adc_Config adcConf;                                         /* Define a configuration structure         */
    IfxVadc_Adc_initModuleConfig(&adcConf, &MODULE_VADC);               /* Fill it with default values              */
800042aa:	d9 a4 04 00 	lea %a4,[%sp]4
800042ae:	91 20 00 5f 	movh.a %a5,61442
800042b2:	6d 00 d2 1d 	call 80007e56 <IfxVadc_Adc_initModuleConfig>
    IfxVadc_Adc_initModule(&g_vadc, &adcConf);                          /* Apply the configuration                  */
800042b6:	91 00 00 47 	movh.a %a4,28672
800042ba:	d9 44 9c 50 	lea %a4,[%a4]2396 <7000095c <g_vadc>>
800042be:	d9 a5 04 00 	lea %a5,[%sp]4 <7000095c <g_vadc>>
800042c2:	1d 00 56 1d 	j 80007d6e <IfxVadc_Adc_initModule>

800042c6 <initVADCGroup>:
}

/* Function to initialize the VADC group */
void initVADCGroup(void)
{
800042c6:	20 38       	sub.a %sp,56
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */
800042c8:	91 00 00 57 	movh.a %a5,28672
800042cc:	40 a4       	mov.aa %a4,%sp
800042ce:	d9 55 9c 50 	lea %a5,[%a5]2396 <7000095c <g_vadc>>
800042d2:	6d 00 37 1d 	call 80007d40 <IfxVadc_Adc_initGroupConfig>

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
800042d6:	82 4f       	mov %d15,4
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
800042d8:	91 00 00 47 	movh.a %a4,28672
void initVADCGroup(void)
{
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
800042dc:	2c a4       	st.b [%sp]4,%d15
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */
800042de:	2c a5       	st.b [%sp]5,%d15
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
800042e0:	d9 44 90 50 	lea %a4,[%a4]2384 <70000950 <g_vadcGroup>>

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
800042e4:	82 1f       	mov %d15,1
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
800042e6:	40 a5       	mov.aa %a5,%sp

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
800042e8:	e9 af 35 00 	st.b [%sp]53,%d15
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;
800042ec:	e9 af 28 00 	st.b [%sp]40,%d15

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
800042f0:	e9 af 2c 00 	st.b [%sp]44,%d15

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
800042f4:	1d 00 61 1b 	j 800079b6 <IfxVadc_Adc_initGroup>

800042f8 <initVADCChannels>:
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
800042f8:	91 00 00 e7 	movh.a %a14,28672

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
800042fc:	7b 00 00 b7 	movh %d11,28672
80004300:	7b 00 00 a7 	movh %d10,28672
}


IFX_INLINE void IfxVadc_Adc_setBackgroundScan(IfxVadc_Adc *vadc, IfxVadc_Adc_Group *group, uint32 channels, uint32 mask)
{
    IfxVadc_setBackgroundScan(vadc->vadc, group->groupId, channels, mask);
80004304:	91 00 00 d7 	movh.a %a13,28672
    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
}

/* Function to initialize the VADC used channels */
void initVADCChannels(void)
{
80004308:	20 60       	sub.a %sp,96
8000430a:	82 0f       	mov %d15,0
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
8000430c:	d9 ee 90 50 	lea %a14,[%a14]2384 <70000950 <g_vadcGroup>>

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004310:	1b 4b 00 b0 	addi %d11,%d11,4
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */
80004314:	82 19       	mov %d9,1
80004316:	1b 0a 93 a0 	addi %d10,%d10,2352
8000431a:	d9 dd 9c 50 	lea %a13,[%a13]2396
8000431e:	53 8f 21 80 	mul %d8,%d15,24
80004322:	40 ac       	mov.aa %a12,%sp
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
80004324:	40 e5       	mov.aa %a5,%a14
80004326:	60 82       	mov.a %a2,%d8

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004328:	d9 af 20 10 	lea %a15,[%sp]96
8000432c:	30 2c       	add.a %a12,%a2
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
8000432e:	40 c4       	mov.aa %a4,%a12
80004330:	6d 00 38 1b 	call 800079a0 <IfxVadc_Adc_initChannelConfig>

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004334:	60 83       	mov.a %a3,%d8
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
80004336:	40 c5       	mov.aa %a5,%a12
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004338:	30 3f       	add.a %a15,%a3
8000433a:	60 b3       	mov.a %a3,%d11
8000433c:	10 32       	addsc.a %a2,%a3,%d15,0
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
8000433e:	e9 ff ef ef 	st.b [%a15]-81,%d15
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004342:	14 22       	ld.bu %d2,[%a2]
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
80004344:	60 a2       	mov.a %a2,%d10
80004346:	d0 24       	addsc.a %a4,%a2,%d15,3
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004348:	e9 f2 ec ef 	st.b [%a15]-84,%d2
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */
8000434c:	e9 f9 e2 ef 	st.b [%a15]-94,%d9


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
80004350:	6d 00 32 1a 	call 800077b4 <IfxVadc_Adc_initChannel>
80004354:	d4 d2       	ld.a %a2,[%a13]
80004356:	39 e2 08 00 	ld.bu %d2,[%a14]8 <70000008 <osEE_ccb_var>>
8000435a:	c2 1f       	add %d15,1
8000435c:	01 22 02 26 	addsc.a %a2,%a2,%d2,2

        /* Add the channel to background scan */
        unsigned chnEnableBit = (1 << adcChannelConf[chn].channelId);   /* Set the the corresponding input channel  */
80004360:	79 f2 ec ef 	ld.b %d2,[%a15]-84
}


IFX_INLINE void IfxVadc_setBackgroundScan(Ifx_VADC *vadc, IfxVadc_GroupId groupId, uint32 channels, uint32 mask)
{
    channels                = (vadc->BRSSEL[groupId].U & ~mask) | channels;
80004364:	19 23 00 60 	ld.w %d3,[%a2]384
80004368:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
    vadc->BRSSEL[groupId].U = channels;
8000436c:	59 22 00 60 	st.w [%a2]384,%d2
void initVADCChannels(void)
{
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
80004370:	df 4f d7 ff 	jne %d15,4,8000431e <initVADCChannels+0x26>
        unsigned mask = chnEnableBit;                                   /* of the respective group to be added in   */
        IfxVadc_Adc_setBackgroundScan(&g_vadc, &g_vadcGroup, chnEnableBit, mask); /* the background scan sequence.  */

    }

}
80004374:	00 90       	ret 

80004376 <initADC>:
}


IFX_INLINE void IfxVadc_Adc_startBackgroundScan(IfxVadc_Adc *vadc)
{
    IfxVadc_startBackgroundScan(vadc->vadc);
80004376:	91 00 00 f7 	movh.a %a15,28672


/* Function to initialize the VADC module */
void initADC(void)
{
    initVADCModule();                                                   /* Initialize the VADC module               */
8000437a:	6d ff 97 ff 	call 800042a8 <initVADCModule>
    initVADCGroup();                                                    /* Initialize the VADC group                */
8000437e:	6d ff a4 ff 	call 800042c6 <initVADCGroup>
    initVADCChannels();                                                 /* Initialize the used channels             */
80004382:	6d ff bb ff 	call 800042f8 <initVADCChannels>
80004386:	99 ff 9c 50 	ld.a %a15,[%a15]2396 <7000095c <g_vadc>>
}


IFX_INLINE void IfxVadc_startBackgroundScan(Ifx_VADC *vadc)
{
    vadc->BRSMR.B.LDEV = 1;     /* execute Load event to start the conversion */
8000438a:	19 ff 04 80 	ld.w %d15,[%a15]516 <7000095c <g_vadc>>
8000438e:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
80004392:	59 ff 04 80 	st.w [%a15]516,%d15
80004396:	00 90       	ret 

80004398 <readADCValue>:
}


IFX_INLINE Ifx_VADC_RES IfxVadc_Adc_getResult(IfxVadc_Adc_Channel *channel)
{
    return IfxVadc_getResult(channel->group->group, channel->resultreg);
80004398:	91 00 00 f7 	movh.a %a15,28672
8000439c:	d9 ff b0 40 	lea %a15,[%a15]2352 <70000930 <g_vadcChannel>>
800043a0:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
800043a4:	c8 12       	ld.a %a2,[%a15]4
800043a6:	0c f1       	ld.bu %d15,[%a15]1
800043a8:	99 22 04 00 	ld.a %a2,[%a2]4

IFX_INLINE Ifx_VADC_RES IfxVadc_getResult(Ifx_VADC_G *group, uint32 resultIdx)
{
    Ifx_VADC_RES tmpResult;

    tmpResult.U = group->RES[resultIdx].U;
800043ac:	1b 0f 0a f0 	addi %d15,%d15,160
800043b0:	90 2f       	addsc.a %a15,%a2,%d15,2
800043b2:	4c f0       	ld.w %d15,[%a15]0
800043b4:	37 0f 70 20 	extr.u %d2,%d15,0,16
{
    Ifx_VADC_RES conversionResult;
    do
    {
        conversionResult = IfxVadc_Adc_getResult(&g_vadcChannel[channel]);
    } while(!conversionResult.B.VF);
800043b8:	ff 0f fd 7f 	jge %d15,0,800043b2 <readADCValue+0x1a>

    return conversionResult.B.RESULT;
}
800043bc:	00 90       	ret 

800043be <initPeripheralsAndERU>:

void initPeripheralsAndERU(void)
{
    /* Initialize pins which are used to trigger and visualize the interrupt and set the default states */
    IfxPort_setPinMode(TRIGGER_PIN, IfxPort_Mode_inputPullUp);              /* Initialize TRIGGER_PIN port pin  */
800043be:	91 40 00 4f 	movh.a %a4,61444
800043c2:	d9 44 00 0e 	lea %a4,[%a4]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
800043c6:	82 74       	mov %d4,7
800043c8:	3b 00 01 50 	mov %d5,16
800043cc:	6d 00 77 0b 	call 80005aba <IfxPort_setPinMode>


    /* Trigger pin */
    g_ERUconfig.reqPin = REQ_IN; /* Select external request pin */
800043d0:	91 00 00 f8 	movh.a %a15,32768
800043d4:	d9 ff a8 d0 	lea %a15,[%a15]2920 <80000b68 <IfxScu_REQ6_P02_0_IN>>
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
800043d8:	c8 24       	ld.a %a4,[%a15]8
800043da:	91 00 00 d7 	movh.a %a13,28672
800043de:	08 c4       	ld.bu %d4,[%a15]12
800043e0:	3b 80 00 50 	mov %d5,8
800043e4:	b5 df a0 50 	st.a [%a13]2400 <70000960 <g_ERUconfig>>,%a15
800043e8:	6d 00 69 0b 	call 80005aba <IfxPort_setPinMode>
/******************************************************************************/

IFX_INLINE void IfxScuEru_initReqPin(IfxScu_Req_In *req, IfxPort_InputMode inputMode)
{
    IfxPort_setPinModeInput(req->pin.port, req->pin.pinIndex, inputMode);
    IfxScuEru_selectExternalInput((IfxScuEru_InputChannel)req->channelId, (IfxScuEru_ExternalInputSelection)req->select);
800043ec:	39 f5 10 00 	ld.bu %d5,[%a15]16 <80000010 <BootModeHeader0+0x10>>
800043f0:	08 44       	ld.bu %d4,[%a15]4
800043f2:	6d 00 12 15 	call 80006e16 <IfxScuEru_selectExternalInput>
     * This function will also configure the input multiplexers of the ERU (Register EXISx)
     */
    IfxScuEru_initReqPin(g_ERUconfig.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_ERUconfig.inputChannel = (IfxScuEru_InputChannel) g_ERUconfig.reqPin->channelId;
800043f6:	99 df a0 50 	ld.a %a15,[%a13]2400 <70000960 <g_ERUconfig>>
    /* Initialize pins which are used to trigger and visualize the interrupt and set the default states */
    IfxPort_setPinMode(TRIGGER_PIN, IfxPort_Mode_inputPullUp);              /* Initialize TRIGGER_PIN port pin  */


    /* Trigger pin */
    g_ERUconfig.reqPin = REQ_IN; /* Select external request pin */
800043fa:	d9 dc a0 50 	lea %a12,[%a13]2400 <70000960 <g_ERUconfig>>
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */

    /* Signal destination */
    g_ERUconfig.outputChannel = IfxScuEru_OutputChannel_0;                  /* OGU channel 0                    */
800043fe:	82 0f       	mov %d15,0
     * This function will also configure the input multiplexers of the ERU (Register EXISx)
     */
    IfxScuEru_initReqPin(g_ERUconfig.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_ERUconfig.inputChannel = (IfxScuEru_InputChannel) g_ERUconfig.reqPin->channelId;
80004400:	08 44       	ld.bu %d4,[%a15]4
80004402:	e9 c4 04 00 	st.b [%a12]4 <70000004 <g_vadcChannelIDs>>,%d4

    /* Input channel configuration */
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */
80004406:	6d 00 78 14 	call 80006cf6 <IfxScuEru_enableFallingEdgeDetection>
    /* Event from input ETL0 triggers output OGU0 (signal TRx0) */
    g_ERUconfig.triggerSelect = IfxScuEru_InputNodePointer_0;

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_ERUconfig.inputChannel);
8000440a:	39 c4 04 00 	ld.bu %d4,[%a12]4
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */

    /* Signal destination */
    g_ERUconfig.outputChannel = IfxScuEru_OutputChannel_0;                  /* OGU channel 0                    */
8000440e:	2c c6       	st.b [%a12]6,%d15
    /* Event from input ETL0 triggers output OGU0 (signal TRx0) */
    g_ERUconfig.triggerSelect = IfxScuEru_InputNodePointer_0;
80004410:	2c c5       	st.b [%a12]5,%d15

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_ERUconfig.inputChannel);
80004412:	6d 00 ab 14 	call 80006d68 <IfxScuEru_enableTriggerPulse>
    /* Determination of output channel for trigger event (Register INPx) */
    IfxScuEru_connectTrigger(g_ERUconfig.inputChannel, g_ERUconfig.triggerSelect);
80004416:	39 c4 04 00 	ld.bu %d4,[%a12]4
8000441a:	39 c5 05 00 	ld.bu %d5,[%a12]5
8000441e:	6d 00 df 13 	call 80006bdc <IfxScuEru_connectTrigger>

    /* Configure Output channels, OutputGating Unit OGU (Register IGPy) */
    IfxScuEru_setInterruptGatingPattern(g_ERUconfig.outputChannel, IfxScuEru_InterruptGatingPattern_alwaysActive);
80004422:	39 c4 06 00 	ld.bu %d4,[%a12]6
80004426:	82 15       	mov %d5,1
80004428:	6d 00 30 15 	call 80006e88 <IfxScuEru_setInterruptGatingPattern>

    /* Service request configuration */
    /* Get source pointer depending on outputChannel (SRC_SCUERU0 for outputChannel0) */
    g_ERUconfig.src = &MODULE_SRC.SCU.SCU.ERU[(int) g_ERUconfig.outputChannel % 4];
8000442c:	0c c6       	ld.bu %d15,[%a12]6
8000442e:	16 03       	and %d15,3
80004430:	06 2f       	sh %d15,2
80004432:	60 f2       	mov.a %a2,%d15
80004434:	d9 2f d4 38 	lea %a15,[%a2]-29484
80004438:	11 4f 00 ff 	addih.a %a15,%a15,61444
8000443c:	ec c2       	st.a [%a12]8,%a15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
8000443e:	4c f0       	ld.w %d15,[%a15]0
80004440:	b7 af 08 f0 	insert %d15,%d15,10,0,8
80004444:	68 0f       	st.w [%a15]0,%d15
    src->B.TOS  = typOfService;
80004446:	4c f0       	ld.w %d15,[%a15]0
80004448:	b7 0f 82 f5 	insert %d15,%d15,0,11,2
8000444c:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
8000444e:	4c f0       	ld.w %d15,[%a15]0
80004450:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80004454:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80004456:	4c f0       	ld.w %d15,[%a15]0
80004458:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000445c:	68 0f       	st.w [%a15]0,%d15
8000445e:	00 90       	ret 

80004460 <asclin0TxISR>:
    IfxSrc_enable(g_ERUconfig.src);
}

ISR(asclin0TxISR)
{
    IfxAsclin_Asc_isrTransmit(&g_AsclinAsc.drivers.asc);
80004460:	91 00 00 47 	movh.a %a4,28672
80004464:	d9 44 80 f0 	lea %a4,[%a4]3008 <70000bc0 <g_AsclinAsc+0x254>>
80004468:	1d 00 22 06 	j 800050ac <IfxAsclin_Asc_isrTransmit>

8000446c <TimerISR>:
}

ISR2(TimerISR)
{
    static long c = -1;
    osEE_tc_stm_set_sr0_next_match(1000000U);
8000446c:	7b f0 00 40 	movh %d4,15
{
    IfxAsclin_Asc_isrTransmit(&g_AsclinAsc.drivers.asc);
}

ISR2(TimerISR)
{
80004470:	20 08       	sub.a %sp,8
    static long c = -1;
    osEE_tc_stm_set_sr0_next_match(1000000U);
80004472:	1b 04 24 44 	addi %d4,%d4,16960
    if( c== 0)
80004476:	91 00 00 f7 	movh.a %a15,28672
}

ISR2(TimerISR)
{
    static long c = -1;
    osEE_tc_stm_set_sr0_next_match(1000000U);
8000447a:	6d 00 27 25 	call 80008ec8 <osEE_tc_stm_set_sr0_next_match>
    if( c== 0)
8000447e:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
80004482:	ee 04       	jnz %d15,8000448a <TimerISR+0x1e>
        ActivateTask(Task1);
80004484:	82 24       	mov %d4,2
80004486:	6d 00 ac 26 	call 800091de <ActivateTask>
    printfSerial("\n%4ld: ", c++);
8000448a:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
8000448e:	91 00 00 48 	movh.a %a4,32768
80004492:	78 00       	st.w [%sp]0,%d15
80004494:	d9 44 0c 20 	lea %a4,[%a4]140 <8000008c <_start+0x6c>>
80004498:	c2 1f       	add %d15,1
8000449a:	59 ff 00 00 	st.w [%a15]0 <70000000 <__DSPR0_START>>,%d15
8000449e:	1d ff 22 fe 	j 800040e2 <printfSerial>

800044a2 <main>:
}

int main(void)
{
    osEE_tc_stm_set_clockpersec();
800044a2:	6d 00 b7 24 	call 80008e10 <osEE_tc_stm_set_clockpersec>
    osEE_tc_stm_set_sr0(1000000U, 1U);
800044a6:	7b f0 00 40 	movh %d4,15
800044aa:	82 15       	mov %d5,1
800044ac:	1b 04 24 44 	addi %d4,%d4,16960
800044b0:	6d 00 ca 24 	call 80008e44 <osEE_tc_stm_set_sr0>

    UART_init();
800044b4:	6d ff de fd 	call 80004070 <UART_init>
    initADC();
800044b8:	6d ff 5f ff 	call 80004376 <initADC>
    initPeripheralsAndERU();
800044bc:	6d ff 81 ff 	call 800043be <initPeripheralsAndERU>

    printfSerial("\n...............\n");
800044c0:	91 00 00 48 	movh.a %a4,32768
800044c4:	d9 44 14 20 	lea %a4,[%a4]148 <80000094 <_start+0x74>>
800044c8:	6d ff 0d fe 	call 800040e2 <printfSerial>
    printfSerial("...OS Starts...\n");
800044cc:	91 00 00 48 	movh.a %a4,32768
800044d0:	d9 44 26 20 	lea %a4,[%a4]166 <800000a6 <_start+0x86>>
800044d4:	6d ff 07 fe 	call 800040e2 <printfSerial>
    printfSerial("...............\n");
800044d8:	91 00 00 48 	movh.a %a4,32768
800044dc:	d9 44 37 20 	lea %a4,[%a4]183 <800000b7 <_start+0x97>>
800044e0:	6d ff 01 fe 	call 800040e2 <printfSerial>

    StartOS(OSDEFAULTAPPMODE);
800044e4:	82 04       	mov %d4,0
800044e6:	6d 00 19 26 	call 80009118 <StartOS>
    return 0;
}
800044ea:	82 02       	mov %d2,0
800044ec:	00 90       	ret 
	...

800044f0 <IfxVadc_disableAccess>:
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
800044f0:	02 4f       	mov %d15,%d4
800044f2:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
800044f4:	6d 00 6d 16 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(passwd);
800044f8:	02 24       	mov %d4,%d2
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
800044fa:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
800044fc:	6d 00 66 15 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80004500:	8b 0f a2 22 	ge.u %d2,%d15,32
80004504:	f6 28       	jnz %d2,80004514 <IfxVadc_disableAccess+0x24>
    {
        vadc->ACCPROT0.U |= (0x00000001 << protectionSet);
80004506:	19 f2 08 20 	ld.w %d2,[%a15]136
8000450a:	d7 12 01 ff 	insert %d15,%d2,1,%d15,1
8000450e:	59 ff 08 20 	st.w [%a15]136,%d15
80004512:	3c 08       	j 80004522 <IfxVadc_disableAccess+0x32>
    }
    else
    {
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
80004514:	19 f2 0c 20 	ld.w %d2,[%a15]140
80004518:	16 1f       	and %d15,31
8000451a:	d7 12 01 ff 	insert %d15,%d2,1,%d15,1
8000451e:	59 ff 0c 20 	st.w [%a15]140,%d15
    }

    IfxScuWdt_setSafetyEndinit(passwd);
80004522:	02 84       	mov %d4,%d8
80004524:	1d 00 d8 16 	j 800072d4 <IfxScuWdt_setSafetyEndinit>

80004528 <IfxVadc_enableAccess>:
    }
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80004528:	02 4f       	mov %d15,%d4
8000452a:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
8000452c:	6d 00 51 16 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(passwd);
80004530:	02 24       	mov %d4,%d2
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80004532:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80004534:	6d 00 4a 15 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80004538:	8b 0f a2 22 	ge.u %d2,%d15,32
8000453c:	f6 28       	jnz %d2,8000454c <IfxVadc_enableAccess+0x24>
    {
        vadc->ACCPROT0.U &= ~(0x00000001 << protectionSet);
8000453e:	19 f2 08 20 	ld.w %d2,[%a15]136
80004542:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80004546:	59 ff 08 20 	st.w [%a15]136,%d15
8000454a:	3c 08       	j 8000455a <IfxVadc_enableAccess+0x32>
    }
    else
    {
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
8000454c:	19 f2 0c 20 	ld.w %d2,[%a15]140
80004550:	16 1f       	and %d15,31
80004552:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80004556:	59 ff 0c 20 	st.w [%a15]140,%d15
    }

    IfxScuWdt_setSafetyEndinit(passwd);
8000455a:	02 84       	mov %d4,%d8
8000455c:	1d 00 bc 16 	j 800072d4 <IfxScuWdt_setSafetyEndinit>

80004560 <IfxVadc_configExternalMultiplexerMode>:

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
80004560:	82 0f       	mov %d15,0
80004562:	b7 1f 81 ff 	insert %d15,%d15,1,31,1
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
80004566:	39 a3 04 00 	ld.bu %d3,[%sp]4
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
8000456a:	37 4f 02 fd 	insert %d15,%d15,%d4,26,2
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
8000456e:	14 a2       	ld.bu %d2,[%sp]
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
80004570:	67 3f 1e f0 	ins.t %d15,%d15,30,%d3,0
    emuxctr.B.EMUXCH   = channels;
80004574:	37 5f 0a f8 	insert %d15,%d15,%d5,16,10
    emuxctr.B.EMUXSET  = startChannel;
80004578:	37 6f 03 f0 	insert %d15,%d15,%d6,0,3
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
8000457c:	3b f0 00 40 	mov %d4,15
    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
80004580:	67 7f 1c f0 	ins.t %d15,%d15,28,%d7,0
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
80004584:	40 5f       	mov.aa %a15,%a5
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
80004586:	67 2f 1d f0 	ins.t %d15,%d15,29,%d2,0
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
8000458a:	40 4c       	mov.aa %a12,%a4
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
8000458c:	6d ff ce ff 	call 80004528 <IfxVadc_enableAccess>
    vadcG->EMUXCTR.U   = emuxctr.U;
80004590:	59 ff 30 50 	st.w [%a15]368,%d15
    emuxctr.B.EMXWC    = 0;
80004594:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
    vadcG->EMUXCTR.U   = emuxctr.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
80004598:	40 c4       	mov.aa %a4,%a12
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
    vadcG->EMUXCTR.U   = emuxctr.U;
    emuxctr.B.EMXWC    = 0;
    vadcG->EMUXCTR.U   = emuxctr.U;
8000459a:	59 ff 30 50 	st.w [%a15]368,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
8000459e:	3b f0 00 40 	mov %d4,15
800045a2:	1d ff a7 ff 	j 800044f0 <IfxVadc_disableAccess>

800045a6 <IfxVadc_disablePostCalibration>:
    IfxScuWdt_setSafetyEndinit(passwd);
}


void IfxVadc_disablePostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group, boolean disable)
{
800045a6:	40 4f       	mov.aa %a15,%a4
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
800045a8:	ff 84 1c 80 	jge.u %d4,8,800045e0 <IfxVadc_disablePostCalibration+0x3a>
800045ac:	02 4f       	mov %d15,%d4
    {
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800045ae:	3b f0 01 40 	mov %d4,31
800045b2:	02 58       	mov %d8,%d5
800045b4:	6d ff ba ff 	call 80004528 <IfxVadc_enableAccess>

        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
800045b8:	1b 0f 01 40 	addi %d4,%d15,16

        if (disable == TRUE)
        {
            vadc->GLOBCFG.U |= mask;
800045bc:	19 f2 00 20 	ld.w %d2,[%a15]128
{
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
    {
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);

        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
800045c0:	82 1f       	mov %d15,1
800045c2:	0f 4f 00 f0 	sh %d15,%d15,%d4

        if (disable == TRUE)
800045c6:	df 18 04 80 	jne %d8,1,800045ce <IfxVadc_disablePostCalibration+0x28>
        {
            vadc->GLOBCFG.U |= mask;
800045ca:	a6 2f       	or %d15,%d2
800045cc:	3c 03       	j 800045d2 <IfxVadc_disablePostCalibration+0x2c>
        }
        else
        {
            vadc->GLOBCFG.U &= ~mask;
800045ce:	0f f2 e0 f0 	andn %d15,%d2,%d15
800045d2:	59 ff 00 20 	st.w [%a15]128,%d15
        }

        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800045d6:	40 f4       	mov.aa %a4,%a15
800045d8:	3b f0 01 40 	mov %d4,31
800045dc:	1d ff 8a ff 	j 800044f0 <IfxVadc_disableAccess>
800045e0:	00 90       	ret 

800045e2 <IfxVadc_enableGroupSync>:
    IfxScuWdt_setSafetyEndinit(passwd);
}


void IfxVadc_enableGroupSync(Ifx_VADC *vadc, uint32 ccu6Num)
{
800045e2:	40 4f       	mov.aa %a15,%a4
800045e4:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800045e6:	6d 00 d6 15 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
800045ea:	02 24       	mov %d4,%d2
}


void IfxVadc_enableGroupSync(Ifx_VADC *vadc, uint32 ccu6Num)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800045ec:	02 29       	mov %d9,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
800045ee:	6d 00 d2 14 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800045f2:	40 f4       	mov.aa %a4,%a15
800045f4:	3b f0 01 40 	mov %d4,31
    IfxScuWdt_clearCpuEndinit(passwd);

    // VADC Config: enable ADC group sync
    {
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
800045f8:	19 ff 00 20 	ld.w %d15,[%a15]128
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800045fc:	6d ff 96 ff 	call 80004528 <IfxVadc_enableAccess>

    // VADC Config: enable ADC group sync
    {
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
80004600:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
        vadcGlobCfg.B.DCMSB = 1;
80004604:	b7 1f 81 f3 	insert %d15,%d15,1,7,1

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
        vadc->GLOBCFG.U = vadcGlobCfg.U;
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004608:	40 f4       	mov.aa %a4,%a15
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
        vadc->GLOBCFG.U = vadcGlobCfg.U;
8000460a:	59 ff 00 20 	st.w [%a15]128,%d15
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
8000460e:	3b f0 01 40 	mov %d4,31
80004612:	6d ff 6f ff 	call 800044f0 <IfxVadc_disableAccess>
    }

    if (ccu6Num == 0)
80004616:	df 08 1a 80 	jne %d8,0,8000464a <IfxVadc_enableGroupSync+0x68>
    {
        // CCU60 Config
        CCU60_CLC.U = 0;
8000461a:	a5 f8 80 82 	st.w f0002a00 <_SMALL_DATA4_+0x3fffaa00>,%d8

        if (CCU60_CLC.U)
8000461e:	85 ff 80 82 	ld.w %d15,f0002a00 <_SMALL_DATA4_+0x3fffaa00>
        {}

        CCU60_T13PR.U          = 4;                                                                  // results in  4+1 clock periods (100MHz)  = 20MHz
80004622:	82 4f       	mov %d15,4
80004624:	a5 ff 94 92 	st.w f0002a54 <_SMALL_DATA4_+0x3fffaa54>,%d15
        CCU60_CC63SR.U         = 4;                                                                  // configures duty cycle of 40ns low and 10ns high
80004628:	a5 ff 9c 92 	st.w f0002a5c <_SMALL_DATA4_+0x3fffaa5c>,%d15
        CCU60_MODCTR.B.ECT13O  = 1;                                                                  // bit ECT130 = 1 serves to route  CC63ST signals out to  COUT63
8000462c:	85 ff 80 a2 	ld.w %d15,f0002a80 <_SMALL_DATA4_+0x3fffaa80>
80004630:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
80004634:	a5 ff 80 a2 	st.w f0002a80 <_SMALL_DATA4_+0x3fffaa80>,%d15
        CCU60_TCTR4.U          = (1 << IFX_CCU6_TCTR4_T13STR_OFF) | (1 << IFX_CCU6_TCTR4_T13RS_OFF); // set bit T13STR  & T13RS  -> enable shadow transfer & start timer T13
80004638:	3b 00 20 f4 	mov %d15,16896
8000463c:	a5 ff b8 92 	st.w f0002a78 <_SMALL_DATA4_+0x3fffaa78>,%d15
        CCU60_MOSEL.B.TRIG1SEL = 0;                                                                  // CCU60_COUT63 routed to output signal CCU6061 TRIG1
80004640:	85 ff 8c 82 	ld.w %d15,f0002a0c <_SMALL_DATA4_+0x3fffaa0c>
80004644:	8f 8f c3 f1 	andn %d15,%d15,56
80004648:	3c 1d       	j 80004682 <IfxVadc_enableGroupSync+0xa0>
    }
    else if (ccu6Num == 1)
8000464a:	df 18 1e 80 	jne %d8,1,80004686 <IfxVadc_enableGroupSync+0xa4>
    {
        // CCU60 + CCU61 Config
        CCU60_CLC.U = 0;
8000464e:	82 0f       	mov %d15,0
80004650:	a5 ff 80 82 	st.w f0002a00 <_SMALL_DATA4_+0x3fffaa00>,%d15
        CCU61_CLC.U = 0;
80004654:	a5 ff 80 c2 	st.w f0002b00 <_SMALL_DATA4_+0x3fffab00>,%d15

        if (CCU61_CLC.U)
80004658:	85 ff 80 c2 	ld.w %d15,f0002b00 <_SMALL_DATA4_+0x3fffab00>
        {}

        CCU61_T13PR.U          = 4;                                                                  // results in  4+1 clock periods (100MHz)  = 20MHz
8000465c:	82 4f       	mov %d15,4
8000465e:	a5 ff 94 d2 	st.w f0002b54 <_SMALL_DATA4_+0x3fffab54>,%d15
        CCU61_CC63SR.U         = 4;                                                                  // configures duty cycle of 40ns low and 10ns high
80004662:	a5 ff 9c d2 	st.w f0002b5c <_SMALL_DATA4_+0x3fffab5c>,%d15
        CCU61_MODCTR.B.ECT13O  = 1;                                                                  // bit ECT130 = 1 serves to route  CC63ST signals out to  COUT63
80004666:	85 ff 80 e2 	ld.w %d15,f0002b80 <_SMALL_DATA4_+0x3fffab80>
8000466a:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000466e:	a5 ff 80 e2 	st.w f0002b80 <_SMALL_DATA4_+0x3fffab80>,%d15
        CCU61_TCTR4.U          = (1 << IFX_CCU6_TCTR4_T13STR_OFF) | (1 << IFX_CCU6_TCTR4_T13RS_OFF); // set bit T13STR  & T13RS  -> enable shadow transfer & start timer T13
80004672:	3b 00 20 f4 	mov %d15,16896
80004676:	a5 ff b8 d2 	st.w f0002b78 <_SMALL_DATA4_+0x3fffab78>,%d15
        CCU60_MOSEL.B.TRIG1SEL = 1;                                                                  // CCU61_COUT63 routed to output signal CCU6061 TRIG1
8000467a:	85 ff 8c 82 	ld.w %d15,f0002a0c <_SMALL_DATA4_+0x3fffaa0c>
8000467e:	b7 1f 83 f1 	insert %d15,%d15,1,3,3
80004682:	a5 ff 8c 82 	st.w f0002a0c <_SMALL_DATA4_+0x3fffaa0c>,%d15
    }

    IfxScuWdt_setCpuEndinit(passwd);
80004686:	02 94       	mov %d4,%d9
80004688:	1d 00 ba 15 	j 800071fc <IfxScuWdt_setCpuEndinit>

8000468c <IfxVadc_getAdcAnalogFrequency>:
}


float32 IfxVadc_getAdcAnalogFrequency(Ifx_VADC *vadc)
{
8000468c:	40 4f       	mov.aa %a15,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVA);
8000468e:	6d 00 be 0c 	call 8000600a <IfxScuCcu_getSpbFrequency>
80004692:	19 ff 00 20 	ld.w %d15,[%a15]128
80004696:	16 1f       	and %d15,31
80004698:	c2 1f       	add %d15,1
8000469a:	4b 0f 41 f1 	itof %d15,%d15
}
8000469e:	4b f2 51 20 	div.f %d2,%d2,%d15
800046a2:	00 90       	ret 

800046a4 <IfxVadc_getAdcDigitalFrequency>:


float32 IfxVadc_getAdcDigitalFrequency(Ifx_VADC *vadc)
{
800046a4:	40 4f       	mov.aa %a15,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVD);
800046a6:	6d 00 b2 0c 	call 8000600a <IfxScuCcu_getSpbFrequency>
800046aa:	19 ff 00 20 	ld.w %d15,[%a15]128
800046ae:	37 0f 62 f4 	extr.u %d15,%d15,8,2
800046b2:	c2 1f       	add %d15,1
800046b4:	4b 0f 41 f1 	itof %d15,%d15
}
800046b8:	4b f2 51 20 	div.f %d2,%d2,%d15
800046bc:	00 90       	ret 

800046be <IfxVadc_getAdcModuleFrequency>:


float32 IfxVadc_getAdcModuleFrequency(void)
{
    return IfxScuCcu_getSpbFrequency();
800046be:	1d 00 a6 0c 	j 8000600a <IfxScuCcu_getSpbFrequency>

800046c2 <IfxVadc_getBackgroundScanStatus>:
}


IfxVadc_Status IfxVadc_getBackgroundScanStatus(Ifx_VADC *vadc)
{
800046c2:	82 0f       	mov %d15,0
800046c4:	a0 7f       	mov.a %a15,7
    IfxVadc_Status status = IfxVadc_Status_noError;
    uint8          i;

    for (i = 0; i < IFXVADC_NUM_ADC_GROUPS; i++)
    {
        if (vadc->BRSPND[i].U)
800046c6:	1b 0f 07 20 	addi %d2,%d15,112
800046ca:	01 42 02 26 	addsc.a %a2,%a4,%d2,2
800046ce:	54 22       	ld.w %d2,[%a2]
800046d0:	f6 24       	jnz %d2,800046d8 <IfxVadc_getBackgroundScanStatus+0x16>
800046d2:	c2 1f       	add %d15,1
IfxVadc_Status IfxVadc_getBackgroundScanStatus(Ifx_VADC *vadc)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    uint8          i;

    for (i = 0; i < IFXVADC_NUM_ADC_GROUPS; i++)
800046d4:	fc f9       	loop %a15,800046c6 <IfxVadc_getBackgroundScanStatus+0x4>
800046d6:	00 90       	ret 
    {
        if (vadc->BRSPND[i].U)
        {
            return IfxVadc_Status_channelsStillPending;
800046d8:	82 62       	mov %d2,6
            continue;
        }
    }

    return status;
}
800046da:	00 90       	ret 

800046dc <IfxVadc_getQueueStatus>:
IfxVadc_Status IfxVadc_getQueueStatus(Ifx_VADC_G *group)
{
    IfxVadc_Status status = IfxVadc_Status_noError;

    /* just fill level is checked */
    if (0x7 == group->QSR0.B.FILL)
800046dc:	19 42 08 20 	ld.w %d2,[%a4]136
800046e0:	8f f2 00 21 	and %d2,%d2,15
    {
        status = IfxVadc_Status_queueFull;
    }
    else
    {
        status = IfxVadc_Status_noError;
800046e4:	8b 72 00 22 	eq %d2,%d2,7
    }

    return status;
}
800046e8:	06 22       	sh %d2,2
800046ea:	00 90       	ret 

800046ec <IfxVadc_getResultBasedOnRequestSource>:
Ifx_VADC_RES IfxVadc_getResultBasedOnRequestSource(Ifx_VADC *vadc, Ifx_VADC_G *group, IfxVadc_ChannelId channel, IfxVadc_RequestSource sourceType)
{
    sint32       sourceResultRegister = -1;
    Ifx_VADC_RES tmpResult;

    switch (sourceType)
800046ec:	df 15 09 00 	jeq %d5,1,800046fe <IfxVadc_getResultBasedOnRequestSource+0x12>
800046f0:	76 54       	jz %d5,800046f8 <IfxVadc_getResultBasedOnRequestSource+0xc>
800046f2:	df 25 0b 00 	jeq %d5,2,80004708 <IfxVadc_getResultBasedOnRequestSource+0x1c>
800046f6:	3c 39       	j 80004768 <IfxVadc_getResultBasedOnRequestSource+0x7c>
    {
    case IfxVadc_RequestSource_queue:
        sourceResultRegister = group->QCTRL0.B.SRCRESREG;
800046f8:	19 5f 00 20 	ld.w %d15,[%a5]128
800046fc:	3c 03       	j 80004702 <IfxVadc_getResultBasedOnRequestSource+0x16>
        break;

    case IfxVadc_RequestSource_scan:
        sourceResultRegister = group->ASCTRL.B.SRCRESREG;
800046fe:	19 5f 20 20 	ld.w %d15,[%a5]160
80004702:	16 0f       	and %d15,15
    case IfxVadc_RequestSource_background:
        sourceResultRegister = vadc->BRSCTRL.B.SRCRESREG;
        break;
    }

    if (sourceResultRegister > 0)
80004704:	ee 39       	jnz %d15,80004776 <IfxVadc_getResultBasedOnRequestSource+0x8a>
80004706:	3c 31       	j 80004768 <IfxVadc_getResultBasedOnRequestSource+0x7c>
    case IfxVadc_RequestSource_scan:
        sourceResultRegister = group->ASCTRL.B.SRCRESREG;
        break;

    case IfxVadc_RequestSource_background:
        sourceResultRegister = vadc->BRSCTRL.B.SRCRESREG;
80004708:	19 4f 00 80 	ld.w %d15,[%a4]512
8000470c:	16 0f       	and %d15,15
        break;
    }

    if (sourceResultRegister > 0)
8000470e:	ee 34       	jnz %d15,80004776 <IfxVadc_getResultBasedOnRequestSource+0x8a>

        return tmpResult;
    }
    else
    {
        if ((sourceType == IfxVadc_RequestSource_background) && (group->CHCTR[channel].B.RESTBS == 1))
80004710:	1b 04 06 f0 	addi %d15,%d4,96
80004714:	90 5f       	addsc.a %a15,%a5,%d15,2
80004716:	4c f0       	ld.w %d15,[%a15]0
80004718:	ef 4f 28 00 	jz.t %d15,20,80004768 <IfxVadc_getResultBasedOnRequestSource+0x7c>
        {
            tmpResult.B.VF     = vadc->GLOBRES.B.VF;
8000471c:	19 42 00 c0 	ld.w %d2,[%a4]768
80004720:	82 0f       	mov %d15,0
80004722:	67 2f 9f ff 	ins.t %d15,%d15,31,%d2,31
            tmpResult.B.FCR    = vadc->GLOBRES.B.FCR;
80004726:	19 42 00 c0 	ld.w %d2,[%a4]768
8000472a:	67 2f 1e ff 	ins.t %d15,%d15,30,%d2,30
            tmpResult.B.CRS    = vadc->GLOBRES.B.CRS;
8000472e:	19 42 00 c0 	ld.w %d2,[%a4]768
80004732:	37 02 62 2e 	extr.u %d2,%d2,28,2
80004736:	37 2f 02 fe 	insert %d15,%d15,%d2,28,2
            tmpResult.B.EMUX   = vadc->GLOBRES.B.EMUX;
8000473a:	19 42 00 c0 	ld.w %d2,[%a4]768
8000473e:	37 02 e3 2c 	extr.u %d2,%d2,25,3
80004742:	37 2f 83 fc 	insert %d15,%d15,%d2,25,3
            tmpResult.B.CHNR   = vadc->GLOBRES.B.CHNR;
80004746:	19 42 00 c0 	ld.w %d2,[%a4]768
8000474a:	37 02 65 2a 	extr.u %d2,%d2,20,5
8000474e:	37 2f 05 fa 	insert %d15,%d15,%d2,20,5
            tmpResult.B.DRC    = vadc->GLOBRES.B.GNR; //The bitfields are the same but interpretation is different. TODO- define a generic result register type.
80004752:	19 42 00 c0 	ld.w %d2,[%a4]768
80004756:	37 02 64 28 	extr.u %d2,%d2,16,4
8000475a:	37 2f 04 f8 	insert %d15,%d15,%d2,16,4
            tmpResult.B.RESULT = vadc->GLOBRES.B.RESULT;
8000475e:	19 42 00 c0 	ld.w %d2,[%a4]768
80004762:	37 2f 10 20 	insert %d2,%d15,%d2,0,16

            return tmpResult;
80004766:	00 90       	ret 
        }
        else
        {
            tmpResult.U = group->RES[group->CHCTR[channel].B.RESREG].U;
80004768:	1b 04 06 40 	addi %d4,%d4,96
8000476c:	01 54 02 f6 	addsc.a %a15,%a5,%d4,2
80004770:	4c f0       	ld.w %d15,[%a15]0
80004772:	37 0f 64 f8 	extr.u %d15,%d15,16,4
80004776:	1b 0f 0a f0 	addi %d15,%d15,160
8000477a:	90 55       	addsc.a %a5,%a5,%d15,2
8000477c:	54 52       	ld.w %d2,[%a5]

            return tmpResult;
8000477e:	00 90       	ret 

80004780 <IfxVadc_getScanStatus>:

IfxVadc_Status IfxVadc_getScanStatus(Ifx_VADC_G *group)
{
    IfxVadc_Status status = IfxVadc_Status_noError;

    if (group->ASPND.U)
80004780:	19 42 2c 20 	ld.w %d2,[%a4]172
    }
    else
    {
        return status;
    }
}
80004784:	ab 62 a0 22 	seln %d2,%d2,%d2,6
80004788:	00 90       	ret 

8000478a <IfxVadc_getSrcAddress>:

volatile Ifx_SRC_SRCR *IfxVadc_getSrcAddress(IfxVadc_GroupId group, IfxVadc_SrcNr index)
{
    Ifx_SRC_SRCR *base;

    if (IfxVadc_SrcNr_shared0 <= index)
8000478a:	bf 45 0a 80 	jlt.u %d5,4,8000479e <IfxVadc_getSrcAddress+0x14>
    {
        index -= 4;
8000478e:	9a c5       	add %d15,%d5,-4
80004790:	8f ff 0f 51 	and %d5,%d15,255

        if ((group & 0x1) != 0)
80004794:	8f 14 00 41 	and %d4,%d4,1
        {
            group = IfxVadc_GroupId_global1;    /* Shared interrupt common 1 is used */
80004798:	da 08       	mov %d15,8
8000479a:	ab 9f a0 44 	seln %d4,%d4,%d15,9
    else
    {
        /* do nothing */
    }

    base = (Ifx_SRC_SRCR *)IfxVadc_cfg_srcAddresses[(group * 4) + index];
8000479e:	13 44 20 45 	madd %d4,%d5,%d4,4
800047a2:	91 00 00 f8 	movh.a %a15,32768
800047a6:	d9 ff 3c 70 	lea %a15,[%a15]508 <800001fc <IfxVadc_cfg_srcAddresses>>
800047aa:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2

    return &(base[0]);
}
800047ae:	c8 02       	ld.a %a2,[%a15]0
800047b0:	00 90       	ret 

800047b2 <IfxVadc_initialiseAdcArbiterClock>:


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
800047b2:	19 4f 00 20 	ld.w %d15,[%a4]128
    return &(base[0]);
}


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
800047b6:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
800047b8:	37 4f 02 f4 	insert %d15,%d15,%d4,8,2
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800047bc:	3b f0 01 40 	mov %d4,31
800047c0:	6d ff b4 fe 	call 80004528 <IfxVadc_enableAccess>
void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
800047c4:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800047c8:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
800047ca:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800047ce:	3b f0 01 40 	mov %d4,31
800047d2:	1d ff 8f fe 	j 800044f0 <IfxVadc_disableAccess>

800047d6 <IfxVadc_initialiseAdcConverterClock>:


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
800047d6:	19 4f 00 20 	ld.w %d15,[%a4]128
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
}


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
800047da:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
800047dc:	37 4f 05 f0 	insert %d15,%d15,%d4,0,5
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800047e0:	3b f0 01 40 	mov %d4,31
800047e4:	6d ff a2 fe 	call 80004528 <IfxVadc_enableAccess>
void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
800047e8:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800047ec:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
800047ee:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800047f2:	3b f0 01 40 	mov %d4,31
800047f6:	1d ff 7d fe 	j 800044f0 <IfxVadc_disableAccess>

800047fa <IfxVadc_initializeFAdcD>:
}


uint32 IfxVadc_initializeFAdcD(Ifx_VADC *vadc, uint32 fAdcD)
{
800047fa:	02 4f       	mov %d15,%d4
800047fc:	40 4f       	mov.aa %a15,%a4
    uint32 divD;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
800047fe:	6d 00 06 0c 	call 8000600a <IfxScuCcu_getSpbFrequency>
80004802:	4b 02 71 21 	ftouz %d2,%d2

    divD   = (fadc / fAdcD - 1);
80004806:	4b f2 11 42 	div.u %e4,%d2,%d15
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000480a:	82 3f       	mov %d15,3
8000480c:	c2 f4       	add %d4,-1
8000480e:	0b f4 90 41 	min.u %d4,%d4,%d15

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
80004812:	1b 14 00 80 	addi %d8,%d4,1
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
80004816:	40 f4       	mov.aa %a4,%a15

    divD   = (fadc / fAdcD - 1);

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
80004818:	4b 82 11 82 	div.u %e8,%d2,%d8
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
8000481c:	6d ff cb ff 	call 800047b2 <IfxVadc_initialiseAdcArbiterClock>
    return result;
}
80004820:	02 82       	mov %d2,%d8
80004822:	00 90       	ret 

80004824 <IfxVadc_initializeFAdcI>:


uint32 IfxVadc_initializeFAdcI(Ifx_VADC *vadc, uint32 fAdcI)
{
80004824:	02 4f       	mov %d15,%d4
80004826:	40 4f       	mov.aa %a15,%a4
    uint32 divA;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
80004828:	6d 00 f1 0b 	call 8000600a <IfxScuCcu_getSpbFrequency>
8000482c:	4b 02 71 21 	ftouz %d2,%d2

    /*    DivA = min(max(0, Fadc / FAdcI - 1), 0x3F); */
    divA   = (fadc << 2) / fAdcI;
80004830:	8f 22 00 40 	sh %d4,%d2,2
80004834:	4b f4 11 42 	div.u %e4,%d4,%d15
80004838:	3b f0 01 50 	mov %d5,31

    divA   = (divA + 2) >> 2; /* Round to nearest integer */
8000483c:	c2 24       	add %d4,2
8000483e:	06 e4       	sh %d4,-2
    divA   = __minu(divA - 1, 0x1Fu);
80004840:	c2 f4       	add %d4,-1
80004842:	0b 54 90 41 	min.u %d4,%d4,%d5
    result = fadc / (divA + 1);
80004846:	1b 14 00 30 	addi %d3,%d4,1
8000484a:	4b 32 11 62 	div.u %e6,%d2,%d3
8000484e:	02 6f       	mov %d15,%d6

    if (result > IFXVADC_ANALOG_FREQUENCY_MAX)
80004850:	7b 10 13 60 	movh %d6,305
80004854:	1b 16 d0 62 	addi %d6,%d6,11521
80004858:	3f 6f 08 80 	jlt.u %d15,%d6,80004868 <IfxVadc_initializeFAdcI+0x44>
8000485c:	0b 53 90 41 	min.u %d4,%d3,%d5
    {
        divA   = __minu(divA + 1, 0x1Fu);

        result = fadc / (divA + 1);
80004860:	9a 14       	add %d15,%d4,1
80004862:	4b f2 11 22 	div.u %e2,%d2,%d15
80004866:	02 2f       	mov %d15,%d2
    else
    {
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
80004868:	1b 0f ee 25 	addi %d2,%d15,24288
8000486c:	7b a0 12 30 	movh %d3,298
80004870:	9b 82 ff 2f 	addih %d2,%d2,65528
80004874:	1b 13 be 38 	addi %d3,%d3,-29727
80004878:	7f 32 06 80 	jge.u %d2,%d3,80004884 <IfxVadc_initializeFAdcI+0x60>
    {
        result = 0;             /* Min / Max FAdcI frequency */
    }
    else
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
8000487c:	40 f4       	mov.aa %a4,%a15
8000487e:	6d ff ac ff 	call 800047d6 <IfxVadc_initialiseAdcConverterClock>
80004882:	3c 02       	j 80004886 <IfxVadc_initializeFAdcI+0x62>
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
    {
        result = 0;             /* Min / Max FAdcI frequency */
80004884:	82 0f       	mov %d15,0
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
    }

    return result;
}
80004886:	02 f2       	mov %d2,%d15
80004888:	00 90       	ret 

8000488a <IfxVadc_isPostCalibration>:
        break;
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
        break;
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
        break;
    default: pcEnabled                = FALSE;
8000488a:	82 02       	mov %d2,0

boolean IfxVadc_isPostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group)
{
    boolean pcEnabled;

    switch (group)
8000488c:	ff 84 33 80 	jge.u %d4,8,800048f2 <IfxVadc_isPostCalibration+0x68>
80004890:	91 00 00 f8 	movh.a %a15,32768
80004894:	d9 ff a4 24 	lea %a15,[%a15]18596 <800048a4 <IfxVadc_isPostCalibration+0x1a>>
80004898:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
        break;
    case IfxVadc_GroupId_5: pcEnabled = vadc->GLOBCFG.B.DPCAL5 == 0;
        break;
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
        break;
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
8000489c:	19 42 00 20 	ld.w %d2,[%a4]128

boolean IfxVadc_isPostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group)
{
    boolean pcEnabled;

    switch (group)
800048a0:	dc 0f       	ji %a15
800048a2:	00 00       	nop 
800048a4:	1d 00 10 00 	j 800048c4 <IfxVadc_isPostCalibration+0x3a>
800048a8:	1d 00 11 00 	j 800048ca <IfxVadc_isPostCalibration+0x40>
800048ac:	1d 00 12 00 	j 800048d0 <IfxVadc_isPostCalibration+0x46>
800048b0:	1d 00 13 00 	j 800048d6 <IfxVadc_isPostCalibration+0x4c>
800048b4:	1d 00 14 00 	j 800048dc <IfxVadc_isPostCalibration+0x52>
800048b8:	1d 00 15 00 	j 800048e2 <IfxVadc_isPostCalibration+0x58>
800048bc:	1d 00 16 00 	j 800048e8 <IfxVadc_isPostCalibration+0x5e>
800048c0:	1d 00 17 00 	j 800048ee <IfxVadc_isPostCalibration+0x64>
    {
    case IfxVadc_GroupId_0: pcEnabled = vadc->GLOBCFG.B.DPCAL0 == 0;
800048c4:	07 22 10 28 	nand.t %d2,%d2,16,%d2,16
        break;
800048c8:	00 90       	ret 
    case IfxVadc_GroupId_1: pcEnabled = vadc->GLOBCFG.B.DPCAL1 == 0;
800048ca:	07 22 91 28 	nand.t %d2,%d2,17,%d2,17
        break;
800048ce:	00 90       	ret 
    case IfxVadc_GroupId_2: pcEnabled = vadc->GLOBCFG.B.DPCAL2 == 0;
800048d0:	07 22 12 29 	nand.t %d2,%d2,18,%d2,18
        break;
800048d4:	00 90       	ret 
    case IfxVadc_GroupId_3: pcEnabled = vadc->GLOBCFG.B.DPCAL3 == 0;
800048d6:	07 22 93 29 	nand.t %d2,%d2,19,%d2,19
        break;
800048da:	00 90       	ret 
    case IfxVadc_GroupId_4: pcEnabled = vadc->GLOBCFG.B.DPCAL4 == 0;
800048dc:	07 22 14 2a 	nand.t %d2,%d2,20,%d2,20
        break;
800048e0:	00 90       	ret 
    case IfxVadc_GroupId_5: pcEnabled = vadc->GLOBCFG.B.DPCAL5 == 0;
800048e2:	07 22 95 2a 	nand.t %d2,%d2,21,%d2,21
        break;
800048e6:	00 90       	ret 
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
800048e8:	07 22 16 2b 	nand.t %d2,%d2,22,%d2,22
        break;
800048ec:	00 90       	ret 
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
800048ee:	07 22 97 2b 	nand.t %d2,%d2,23,%d2,23
    default: pcEnabled                = FALSE;
        break;
    }

    return pcEnabled;
}
800048f2:	00 90       	ret 

800048f4 <IfxVadc_getChannelConversionTime>:
    return status;
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
800048f4:	02 40       	mov %d0,%d4
800048f6:	02 68       	mov %d8,%d6
800048f8:	02 7a       	mov %d10,%d7
800048fa:	14 a4       	ld.bu %d4,[%sp]
    IfxVadc_ChannelResolution resolution;
    uint32                    n;

    uint32                    inputClassNum;

    if (inputClass <= IfxVadc_InputClasses_group1)
800048fc:	ff 25 08 80 	jge.u %d5,2,8000490c <IfxVadc_getChannelConversionTime+0x18>
    {
        inputClassNum = inputClass;
        stcs          = vadcG->ICLASS[inputClassNum].B.STCS;
80004900:	8f 80 00 f0 	sh %d15,%d0,8
80004904:	42 f5       	add %d5,%d15
80004906:	1b 85 12 50 	addi %d5,%d5,296
8000490a:	3c 03       	j 80004910 <IfxVadc_getChannelConversionTime+0x1c>
        resolution    = (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
8000490c:	1b 65 02 50 	addi %d5,%d5,38
80004910:	01 45 02 f6 	addsc.a %a15,%a4,%d5,2
80004914:	4c f0       	ld.w %d15,[%a15]0
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
80004916:	48 03       	ld.w %d3,[%a15]0
        resolution    = (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
80004918:	16 1f       	and %d15,31
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
    }

    if (stcs > 16)
8000491a:	8b 1f 61 22 	lt.u %d2,%d15,17
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
8000491e:	37 03 63 34 	extr.u %d3,%d3,8,3
    }

    if (stcs > 16)
80004922:	f6 24       	jnz %d2,8000492a <IfxVadc_getChannelConversionTime+0x36>
    {
        stcs = (stcs - 15) * 16; // Reference for the logic: Table 28-4 of TC29xB User Manual v1.3
80004924:	1b 1f ff ff 	addi %d15,%d15,-15
80004928:	06 4f       	sh %d15,4
8000492a:	ff 63 35 80 	jge.u %d3,6,80004994 <IfxVadc_getChannelConversionTime+0xa0>
8000492e:	91 00 00 f8 	movh.a %a15,32768
80004932:	d9 ff 34 70 	lea %a15,[%a15]500 <800001f4 <CSWTCH.25>>
80004936:	01 f3 00 f6 	addsc.a %a15,%a15,%d3,0
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
    float32                   conversionTime = 0.0;
8000493a:	82 02       	mov %d2,0
8000493c:	08 09       	ld.bu %d9,[%a15]0
        break;
    default: n                                  = 0;
        break;
    }

    if (conversionMode == IfxVadc_ConversionType_Compatible)
8000493e:	df 04 2f 80 	jne %d4,0,8000499c <IfxVadc_getChannelConversionTime+0xa8>
    {
        if (resolution != IfxVadc_ChannelResolution_10bitFast)
80004942:	df 53 0d 00 	jeq %d3,5,8000495c <IfxVadc_getChannelConversionTime+0x68>
        {
            /* Standard conversion */
            uint32 pc = IfxVadc_isPostCalibration(vadc, group) ? 2 : 0;
80004946:	02 04       	mov %d4,%d0
80004948:	6d ff a1 ff 	call 8000488a <IfxVadc_isPostCalibration>
8000494c:	92 24       	add %d4,%d15,2
8000494e:	ab 22 a0 22 	seln %d2,%d2,%d2,2
80004952:	42 94       	add %d4,%d9
            conversionTime = (float32)(2 + stcs + n + pc) / analogFrequency + 2.0 / moduleFrequency;
80004954:	42 24       	add %d4,%d2
80004956:	4b 04 41 41 	itof %d4,%d4
8000495a:	3c 04       	j 80004962 <IfxVadc_getChannelConversionTime+0x6e>
        }
        else
        {
            /* Fast compare mode */
            conversionTime = (float32)(2 + stcs + 2) / analogFrequency + 2.0 / moduleFrequency;
8000495c:	c2 4f       	add %d15,4
8000495e:	4b 0f 41 41 	itof %d4,%d15
80004962:	4b 84 51 40 	div.f %d4,%d4,%d8
80004966:	6d 00 e1 2a 	call 80009f28 <__extendsfdf2>
8000496a:	02 a4       	mov %d4,%d10
8000496c:	0b 23 10 88 	mov %e8,%d3,%d2
80004970:	6d 00 dc 2a 	call 80009f28 <__extendsfdf2>
80004974:	b7 00 21 4f 	imask %e4,0,30,1
80004978:	0b 23 10 68 	mov %e6,%d3,%d2
8000497c:	6d 00 cb 2c 	call 8000a312 <__divdf3>
80004980:	0b 89 10 48 	mov %e4,%d9,%d8
80004984:	0b 23 10 68 	mov %e6,%d3,%d2
80004988:	6d 00 b7 2b 	call 8000a0f6 <__adddf3>
8000498c:	0b 23 10 48 	mov %e4,%d3,%d2
80004990:	1d 00 80 2d 	j 8000a490 <__truncdfsf2>
        break;
    default: n                                  = 0;
        break;
    }

    if (conversionMode == IfxVadc_ConversionType_Compatible)
80004994:	82 09       	mov %d9,0
80004996:	df 04 d8 7f 	jeq %d4,0,80004946 <IfxVadc_getChannelConversionTime+0x52>
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
    float32                   conversionTime = 0.0;
8000499a:	82 02       	mov %d2,0
    {
        // do nothing
    }

    return conversionTime;
}
8000499c:	00 90       	ret 

8000499e <IfxVadc_resetKernel>:
    return pcEnabled;
}


void IfxVadc_resetKernel(Ifx_VADC *vadc)
{
8000499e:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800049a0:	6d 00 f9 13 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
800049a4:	02 24       	mov %d4,%d2
}


void IfxVadc_resetKernel(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800049a6:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
800049a8:	6d 00 f5 12 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800049ac:	3b f0 01 40 	mov %d4,31
800049b0:	40 f4       	mov.aa %a4,%a15
800049b2:	6d ff bb fd 	call 80004528 <IfxVadc_enableAccess>
    vadc->KRST1.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
800049b6:	48 c2       	ld.w %d2,[%a15]48
    vadc->KRST0.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
800049b8:	02 f4       	mov %d4,%d15
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->KRST1.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
800049ba:	8f 12 40 21 	or %d2,%d2,1
800049be:	68 c2       	st.w [%a15]48,%d2
    vadc->KRST0.B.RST = 1;
800049c0:	48 d2       	ld.w %d2,[%a15]52
800049c2:	8f 12 40 21 	or %d2,%d2,1
800049c6:	68 d2       	st.w [%a15]52,%d2
    IfxScuWdt_setCpuEndinit(passwd);
800049c8:	6d 00 1a 14 	call 800071fc <IfxScuWdt_setCpuEndinit>

    while (vadc->KRST0.B.RSTSTAT == 0)  /* Wait until reset is executed */
800049cc:	48 d2       	ld.w %d2,[%a15]52
800049ce:	6f 12 ff 7f 	jz.t %d2,1,800049cc <IfxVadc_resetKernel+0x2e>

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
800049d2:	02 f4       	mov %d4,%d15
800049d4:	6d 00 df 12 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
    vadc->KRSTCLR.B.CLR = 1;    /* Clear Kernel reset status bit */
800049d8:	48 b2       	ld.w %d2,[%a15]44
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800049da:	3b f0 01 40 	mov %d4,31
    while (vadc->KRST0.B.RSTSTAT == 0)  /* Wait until reset is executed */

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    vadc->KRSTCLR.B.CLR = 1;    /* Clear Kernel reset status bit */
800049de:	8f 12 40 21 	or %d2,%d2,1
800049e2:	68 b2       	st.w [%a15]44,%d2
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800049e4:	40 f4       	mov.aa %a4,%a15
800049e6:	6d ff 85 fd 	call 800044f0 <IfxVadc_disableAccess>
    IfxScuWdt_setCpuEndinit(passwd);
800049ea:	02 f4       	mov %d4,%d15
800049ec:	1d 00 08 14 	j 800071fc <IfxScuWdt_setCpuEndinit>

800049f0 <IfxVadc_selectPowerSupplyVoltage>:


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
800049f0:	19 4f 00 20 	ld.w %d15,[%a4]128
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
800049f4:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
800049f6:	67 4f 0e f0 	ins.t %d15,%d15,14,%d4,0
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800049fa:	3b f0 01 40 	mov %d4,31
800049fe:	6d ff 95 fd 	call 80004528 <IfxVadc_enableAccess>
void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
    tempGLOBCFG.B.DIVWC = 1;
80004a02:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a06:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80004a08:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a0c:	3b f0 01 40 	mov %d4,31
80004a10:	1d ff 70 fd 	j 800044f0 <IfxVadc_disableAccess>

80004a14 <IfxVadc_setArbiterPriority>:
}


void IfxVadc_setArbiterPriority(Ifx_VADC_G *vadcG, boolean slotEnable, IfxVadc_RequestSlotPriority prio, IfxVadc_RequestSlotStartMode mode, IfxVadc_RequestSource slot)
{
80004a14:	1b 87 01 f0 	addi %d15,%d7,24
    if (slotEnable != FALSE)
80004a18:	df 04 23 00 	jeq %d4,0,80004a5e <IfxVadc_setArbiterPriority+0x4a>
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
80004a1c:	19 42 04 00 	ld.w %d2,[%a4]4
80004a20:	0f f4 00 40 	sh %d4,%d4,%d15
80004a24:	a6 24       	or %d4,%d2
80004a26:	59 44 04 00 	st.w [%a4]4,%d4
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
80004a2a:	19 42 04 00 	ld.w %d2,[%a4]4
80004a2e:	06 27       	sh %d7,2
80004a30:	82 3f       	mov %d15,3
80004a32:	0f 7f 00 f0 	sh %d15,%d15,%d7
80004a36:	0f f2 e0 f0 	andn %d15,%d2,%d15
80004a3a:	6c 41       	st.w [%a4]4,%d15
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */
80004a3c:	4c 41       	ld.w %d15,[%a4]4
80004a3e:	0f 75 00 50 	sh %d5,%d5,%d7
80004a42:	a6 f5       	or %d5,%d15
80004a44:	59 45 04 00 	st.w [%a4]4,%d5

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80004a48:	4c 41       	ld.w %d15,[%a4]4
80004a4a:	c2 37       	add %d7,3
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
80004a4c:	76 64       	jz %d6,80004a54 <IfxVadc_setArbiterPriority+0x40>
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80004a4e:	d7 1f 01 77 	insert %d7,%d15,1,%d7,1
80004a52:	3c 03       	j 80004a58 <IfxVadc_setArbiterPriority+0x44>
        }
        else
        {
            vadcG->ARBPR.U &= ~(0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)));  /* Set Wait for Start mode */
80004a54:	d7 0f 01 77 	insert %d7,%d15,0,%d7,1
80004a58:	59 47 04 00 	st.w [%a4]4,%d7
80004a5c:	00 90       	ret 
        }
    }
    else
    {
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_ASEN0_MSK << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot));  /* disable Slot */
80004a5e:	19 44 04 00 	ld.w %d4,[%a4]4
80004a62:	d7 04 01 ff 	insert %d15,%d4,0,%d15,1
80004a66:	6c 41       	st.w [%a4]4,%d15
80004a68:	00 90       	ret 

80004a6a <IfxVadc_setScan>:

void IfxVadc_setScan(Ifx_VADC_G *group, uint32 channels, uint32 mask)
{
    /* select channels which should take part in the scan sequence */
    /* the mask allows to specify the channels which should be enabled/disabled */
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
80004a6a:	19 4f 28 20 	ld.w %d15,[%a4]168
80004a6e:	26 54       	and %d4,%d5
80004a70:	0f 5f e0 f0 	andn %d15,%d15,%d5
80004a74:	0f 4f a0 50 	or %d5,%d15,%d4
80004a78:	59 45 28 20 	st.w [%a4]168,%d5
80004a7c:	00 90       	ret 

80004a7e <IfxVadc_startupCalibration>:
{
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a7e:	3b f0 01 40 	mov %d4,31
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
}


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80004a82:	40 4f       	mov.aa %a15,%a4
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a84:	6d ff 52 fd 	call 80004528 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_initiateStartupCalibration(Ifx_VADC *vadc)
{
    vadc->GLOBCFG.B.SUCAL = 1;
80004a88:	19 ff 00 20 	ld.w %d15,[%a15]128
    /* Set SUCAL bit */
    IfxVadc_initiateStartupCalibration(vadc);
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a8c:	40 f4       	mov.aa %a4,%a15
80004a8e:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
80004a92:	3b f0 01 40 	mov %d4,31
80004a96:	59 ff 00 20 	st.w [%a15]128,%d15
80004a9a:	6d ff 2b fd 	call 800044f0 <IfxVadc_disableAccess>
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
}


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80004a9e:	82 02       	mov %d2,0

    /* Wait for hardware self-test and calibration to complete */
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;
80004aa0:	82 0f       	mov %d15,0
80004aa2:	a0 72       	mov.a %a2,7


IFX_INLINE uint8 IfxVadc_getAdcCalibrationActiveState(Ifx_VADC *vadc, uint8 adcCalGroupNum)
{
    uint8 status;
    status = vadc->G[adcCalGroupNum].ARBCFG.B.CAL;
80004aa4:	8f a2 00 30 	sh %d3,%d2,10
80004aa8:	01 f3 00 36 	addsc.a %a3,%a15,%d3,0
80004aac:	c2 12       	add %d2,1
80004aae:	19 33 40 20 	ld.w %d3,[%a3]1152
80004ab2:	37 03 61 3e 	extr.u %d3,%d3,28,1

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
        {
            if (IfxVadc_getAdcCalibrationActiveState(vadc, adcCalGroupNum) != 0)     /* Check ADC Calibration Flag CAL */
            {
                calibrationRunning = TRUE;
80004ab6:	ab 1f a0 f3 	seln %d15,%d3,%d15,1
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80004aba:	fc 25       	loop %a2,80004aa4 <IfxVadc_startupCalibration+0x26>
            else
            {
                /* do nothing */
            }
        }
    } while (calibrationRunning == TRUE); /* wait until calibration of all calibrated kernels are done */
80004abc:	df 1f f1 7f 	jeq %d15,1,80004a9e <IfxVadc_startupCalibration+0x20>
}
80004ac0:	00 90       	ret 
	...

80004ac4 <IfxAsclin_disableModule>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
80004ac4:	40 4f       	mov.aa %a15,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004ac6:	6d 00 66 13 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);            /* clears the endinit protection*/
80004aca:	02 24       	mov %d4,%d2
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004acc:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);            /* clears the endinit protection*/
80004ace:	6d 00 62 12 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setDisableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 1;
80004ad2:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setDisableModuleRequest(asclin); /* disables the module*/
    IfxScuWdt_setCpuEndinit(psw);              /* sets the endinit protection back on*/
80004ad4:	02 f4       	mov %d4,%d15
80004ad6:	8f 12 40 21 	or %d2,%d2,1
80004ada:	68 02       	st.w [%a15]0,%d2
80004adc:	1d 00 90 13 	j 800071fc <IfxScuWdt_setCpuEndinit>

80004ae0 <IfxAsclin_enableAscErrorFlags>:
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
80004ae0:	7b 10 00 f0 	movh %d15,1
80004ae4:	ab 0f 80 44 	sel %d4,%d4,%d15,0
80004ae8:	19 4f 00 10 	ld.w %d15,[%a4]64
80004aec:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
80004af0:	a6 f4       	or %d4,%d15
80004af2:	59 44 00 10 	st.w [%a4]64,%d4
}


IFX_INLINE void IfxAsclin_enableRxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
80004af6:	7b 00 40 f0 	movh %d15,1024
80004afa:	ab 0f 80 55 	sel %d5,%d5,%d15,0
80004afe:	19 4f 00 10 	ld.w %d15,[%a4]64
80004b02:	b7 0f 01 fd 	insert %d15,%d15,0,26,1
80004b06:	a6 f5       	or %d5,%d15
80004b08:	59 45 00 10 	st.w [%a4]64,%d5
80004b0c:	00 90       	ret 

80004b0e <IfxAsclin_enableModule>:
    IfxAsclin_enableRxFifoOverflowFlag(asclin, rfoEnable);  /* enables Rx fifo Overflow error*/
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
80004b0e:	40 4f       	mov.aa %a15,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004b10:	6d 00 41 13 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80004b14:	02 24       	mov %d4,%d2
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004b16:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80004b18:	6d 00 3d 12 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setEnableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 0;
80004b1c:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setEnableModuleRequest(asclin); /* enables the module*/
    IfxScuWdt_setCpuEndinit(psw);             /* sets the endinit protection back on*/
80004b1e:	02 f4       	mov %d4,%d15
80004b20:	8f 12 c0 21 	andn %d2,%d2,1
80004b24:	68 02       	st.w [%a15]0,%d2
80004b26:	1d 00 6b 13 	j 800071fc <IfxScuWdt_setCpuEndinit>

80004b2a <IfxAsclin_getAddress>:
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
    }
    else
    {
        module = NULL_PTR;
80004b2a:	a0 02       	mov.a %a2,0

Ifx_ASCLIN *IfxAsclin_getAddress(IfxAsclin_Index asclin)
{
    Ifx_ASCLIN *module;

    if (asclin < IFXASCLIN_NUM_MODULES)
80004b2c:	ff 44 09 00 	jge %d4,4,80004b3e <IfxAsclin_getAddress+0x14>
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
80004b30:	91 00 00 f8 	movh.a %a15,32768
80004b34:	d9 ff 8c 50 	lea %a15,[%a15]2380 <8000094c <IfxAsclin_cfg_indexMap>>
80004b38:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
80004b3c:	c8 02       	ld.a %a2,[%a15]0
    {
        module = NULL_PTR;
    }

    return module;
}
80004b3e:	00 90       	ret 

80004b40 <IfxAsclin_getFaFrequency>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004b40:	19 4f 0c 10 	ld.w %d15,[%a4]76
80004b44:	16 1f       	and %d15,31
float32 IfxAsclin_getFaFrequency(Ifx_ASCLIN *asclin)
{
    float32               frequency;
    IfxAsclin_ClockSource clockSource = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);    /* gets the current clock source*/

    switch (clockSource)
80004b46:	c2 ff       	add %d15,-1
80004b48:	8b 0f a1 22 	ge.u %d2,%d15,16
80004b4c:	df 02 32 80 	jne %d2,0,80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b50:	91 00 00 f8 	movh.a %a15,32768
80004b54:	d9 ff 9c d4 	lea %a15,[%a15]19292 <80004b5c <IfxAsclin_getFaFrequency+0x1c>>
80004b58:	90 ff       	addsc.a %a15,%a15,%d15,2
80004b5a:	dc 0f       	ji %a15
80004b5c:	1d 00 20 00 	j 80004b9c <IfxAsclin_getFaFrequency+0x5c>
80004b60:	1d 00 20 00 	j 80004ba0 <IfxAsclin_getFaFrequency+0x60>
80004b64:	1d 00 26 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b68:	1d 00 1e 00 	j 80004ba4 <IfxAsclin_getFaFrequency+0x64>
80004b6c:	1d 00 22 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b70:	1d 00 20 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b74:	1d 00 1e 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b78:	1d 00 18 00 	j 80004ba8 <IfxAsclin_getFaFrequency+0x68>
80004b7c:	1d 00 1a 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b80:	1d 00 18 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b84:	1d 00 16 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b88:	1d 00 14 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b8c:	1d 00 12 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b90:	1d 00 10 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b94:	1d 00 0e 00 	j 80004bb0 <IfxAsclin_getFaFrequency+0x70>
80004b98:	1d 00 0a 00 	j 80004bac <IfxAsclin_getFaFrequency+0x6c>
    {
    case IfxAsclin_ClockSource_noClock: /* gets the respective frequency*/
        frequency = 0.0;
        break;
    case IfxAsclin_ClockSource_kernelClock:
        frequency = IfxScuCcu_getSpbFrequency();
80004b9c:	1d 00 37 0a 	j 8000600a <IfxScuCcu_getSpbFrequency>
        break;
    case IfxAsclin_ClockSource_oscillatorClock:
        frequency = IfxScuCcu_getOsc0Frequency();
80004ba0:	1d 00 a6 08 	j 80005cec <IfxScuCcu_getOsc0Frequency>
        break;
    case IfxAsclin_ClockSource_flexRayClock:
        frequency = IfxScuCcu_getPllErayFrequency();
80004ba4:	1d 00 c3 08 	j 80005d2a <IfxScuCcu_getPllErayFrequency>
        break;
    case IfxAsclin_ClockSource_ascFastClock:
        frequency = IfxScuCcu_getBaud2Frequency();
80004ba8:	1d 00 20 0a 	j 80005fe8 <IfxScuCcu_getBaud2Frequency>
        break;
    case IfxAsclin_ClockSource_ascSlowClock:
        frequency = IfxScuCcu_getBaud1Frequency();
80004bac:	1d 00 0e 0a 	j 80005fc8 <IfxScuCcu_getBaud1Frequency>
        frequency = 0.0;
        break;
    }

    return frequency;
}
80004bb0:	82 02       	mov %d2,0
80004bb2:	00 90       	ret 

80004bb4 <IfxAsclin_getIndex>:

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80004bb4:	91 00 00 38 	movh.a %a3,32768
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80004bb8:	82 0f       	mov %d15,0
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80004bba:	d9 33 8c 50 	lea %a3,[%a3]2380 <8000094c <IfxAsclin_cfg_indexMap>>
80004bbe:	a0 3f       	mov.a %a15,3
80004bc0:	d0 32       	addsc.a %a2,%a3,%d15,3
80004bc2:	d4 25       	ld.a %a5,[%a2]
80004bc4:	7d 45 05 80 	jne.a %a5,%a4,80004bce <IfxAsclin_getIndex+0x1a>
        {
            result = (IfxAsclin_Index)IfxAsclin_cfg_indexMap[index].index;
80004bc8:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
80004bcc:	00 90       	ret 
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80004bce:	c2 1f       	add %d15,1
80004bd0:	fc f8       	loop %a15,80004bc0 <IfxAsclin_getIndex+0xc>
IfxAsclin_Index IfxAsclin_getIndex(Ifx_ASCLIN *asclin)
{
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;
80004bd2:	82 f2       	mov %d2,-1
            break;
        }
    }

    return result;
}
80004bd4:	00 90       	ret 

80004bd6 <IfxAsclin_getPdFrequency>:
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
}


float32 IfxAsclin_getPdFrequency(Ifx_ASCLIN *asclin)
{
80004bd6:	40 4f       	mov.aa %a15,%a4
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
80004bd8:	6d ff b4 ff 	call 80004b40 <IfxAsclin_getFaFrequency>
80004bdc:	4c f5       	ld.w %d15,[%a15]20
80004bde:	b7 0f 14 f6 	insert %d15,%d15,0,12,20
80004be2:	c2 1f       	add %d15,1
80004be4:	4b 0f 41 f1 	itof %d15,%d15
}
80004be8:	4b f2 51 20 	div.f %d2,%d2,%d15
80004bec:	00 90       	ret 

80004bee <IfxAsclin_getOvsFrequency>:
    return result;
}


float32 IfxAsclin_getOvsFrequency(Ifx_ASCLIN *asclin)
{
80004bee:	40 4f       	mov.aa %a15,%a4
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
80004bf0:	6d ff f3 ff 	call 80004bd6 <IfxAsclin_getPdFrequency>
80004bf4:	48 83       	ld.w %d3,[%a15]32
80004bf6:	4c f8       	ld.w %d15,[%a15]32
80004bf8:	37 03 6c 38 	extr.u %d3,%d3,16,12
80004bfc:	b7 0f 14 f6 	insert %d15,%d15,0,12,20
80004c00:	4b 03 41 31 	itof %d3,%d3
80004c04:	4b 0f 41 f1 	itof %d15,%d15
80004c08:	4b 32 41 20 	mul.f %d2,%d2,%d3
}
80004c0c:	4b f2 51 20 	div.f %d2,%d2,%d15
80004c10:	00 90       	ret 

80004c12 <IfxAsclin_getShiftFrequency>:
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
}


float32 IfxAsclin_getShiftFrequency(Ifx_ASCLIN *asclin)
{
80004c12:	40 4f       	mov.aa %a15,%a4
    return IfxAsclin_getOvsFrequency(asclin) / asclin->BITCON.B.OVERSAMPLING;
80004c14:	6d ff ed ff 	call 80004bee <IfxAsclin_getOvsFrequency>
80004c18:	4c f5       	ld.w %d15,[%a15]20
80004c1a:	37 0f 64 f8 	extr.u %d15,%d15,16,4
80004c1e:	4b 0f 41 f1 	itof %d15,%d15
}
80004c22:	4b f2 51 20 	div.f %d2,%d2,%d15
80004c26:	00 90       	ret 

80004c28 <IfxAsclin_getSrcPointerEr>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerEr(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].ERR);
80004c28:	6d ff c6 ff 	call 80004bb4 <IfxAsclin_getIndex>
80004c2c:	53 c2 20 f0 	mul %d15,%d2,12
80004c30:	60 ff       	mov.a %a15,%d15
80004c32:	d9 f2 08 28 	lea %a2,[%a15]-32632
}
80004c36:	11 42 00 2f 	addih.a %a2,%a2,61444
80004c3a:	00 90       	ret 

80004c3c <IfxAsclin_getSrcPointerRx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerRx(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].RX);
80004c3c:	6d ff bc ff 	call 80004bb4 <IfxAsclin_getIndex>
80004c40:	53 c2 20 f0 	mul %d15,%d2,12
80004c44:	60 ff       	mov.a %a15,%d15
80004c46:	d9 f2 04 28 	lea %a2,[%a15]-32636
}
80004c4a:	11 42 00 2f 	addih.a %a2,%a2,61444
80004c4e:	00 90       	ret 

80004c50 <IfxAsclin_getSrcPointerTx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerTx(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].TX);
80004c50:	6d ff b2 ff 	call 80004bb4 <IfxAsclin_getIndex>
80004c54:	53 c2 20 f0 	mul %d15,%d2,12
80004c58:	60 ff       	mov.a %a15,%d15
80004c5a:	d9 f2 00 28 	lea %a2,[%a15]-32640
}
80004c5e:	11 42 00 2f 	addih.a %a2,%a2,61444
80004c62:	00 90       	ret 

80004c64 <IfxAsclin_read16>:


uint32 IfxAsclin_read16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
80004c64:	9f 04 04 80 	jned %d4,0,80004c6c <IfxAsclin_read16+0x8>
        *data++ = (uint16)rxData->U;
        count--;
    }

    return count;
}
80004c68:	82 02       	mov %d2,0
80004c6a:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint16)rxData->U;
80004c6c:	19 4f 08 10 	ld.w %d15,[%a4]72
80004c70:	ac 50       	st.h [%a5]0,%d15
80004c72:	b0 25       	add.a %a5,2
80004c74:	3c f8       	j 80004c64 <IfxAsclin_read16>

80004c76 <IfxAsclin_read32>:
    return count;
}


uint32 IfxAsclin_read32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
80004c76:	9f 04 04 80 	jned %d4,0,80004c7e <IfxAsclin_read32+0x8>
        *data++ = rxData->U;
        count--;
    }

    return count;
}
80004c7a:	82 02       	mov %d2,0
80004c7c:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = rxData->U;
80004c7e:	19 4f 08 10 	ld.w %d15,[%a4]72
80004c82:	6c 50       	st.w [%a5]0,%d15
80004c84:	b0 45       	add.a %a5,4
80004c86:	3c f8       	j 80004c76 <IfxAsclin_read32>

80004c88 <IfxAsclin_read8>:
    return count;
}


uint32 IfxAsclin_read8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80004c88:	9f 04 04 80 	jned %d4,0,80004c90 <IfxAsclin_read8+0x8>
        *data++ = (uint8)rxData->U;
        count--;
    }

    return count;
}
80004c8c:	82 02       	mov %d2,0
80004c8e:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint8)rxData->U;
80004c90:	19 4f 08 10 	ld.w %d15,[%a4]72
80004c94:	2c 50       	st.b [%a5]0,%d15
80004c96:	b0 15       	add.a %a5,1
80004c98:	3c f8       	j 80004c88 <IfxAsclin_read8>

80004c9a <IfxAsclin_resetModule>:
    return count;
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
80004c9a:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004c9c:	6d 00 7b 12 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80004ca0:	02 24       	mov %d4,%d2
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004ca2:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80004ca4:	6d 00 77 11 	call 80006f92 <IfxScuWdt_clearCpuEndinit>

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
80004ca8:	19 f2 34 30 	ld.w %d2,[%a15]244
    asclin->KRST1.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
80004cac:	02 f4       	mov %d4,%d15
void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
80004cae:	8f 12 40 21 	or %d2,%d2,1
80004cb2:	59 f2 34 30 	st.w [%a15]244,%d2
    asclin->KRST1.B.RST = 1;
80004cb6:	19 f2 30 30 	ld.w %d2,[%a15]240
80004cba:	8f 12 40 21 	or %d2,%d2,1
80004cbe:	59 f2 30 30 	st.w [%a15]240,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80004cc2:	6d 00 9d 12 	call 800071fc <IfxScuWdt_setCpuEndinit>

    while (0 == asclin->KRST0.B.RSTSTAT)    /* Wait until reset is executed */
80004cc6:	19 f2 34 30 	ld.w %d2,[%a15]244
80004cca:	6f 12 fe 7f 	jz.t %d2,1,80004cc6 <IfxAsclin_resetModule+0x2c>
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
80004cce:	02 f4       	mov %d4,%d15
80004cd0:	6d 00 61 11 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
    asclin->KRSTCLR.B.CLR = 1;          /* Clear Kernel reset status bit */
80004cd4:	19 f2 2c 30 	ld.w %d2,[%a15]236

    IfxScuWdt_setCpuEndinit(passwd);
80004cd8:	02 f4       	mov %d4,%d15

    while (0 == asclin->KRST0.B.RSTSTAT)    /* Wait until reset is executed */
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    asclin->KRSTCLR.B.CLR = 1;          /* Clear Kernel reset status bit */
80004cda:	8f 12 40 21 	or %d2,%d2,1
80004cde:	59 f2 2c 30 	st.w [%a15]236,%d2

    IfxScuWdt_setCpuEndinit(passwd);
80004ce2:	1d 00 8d 12 	j 800071fc <IfxScuWdt_setCpuEndinit>

80004ce6 <IfxAsclin_setClockSource>:
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004ce6:	19 4f 0c 10 	ld.w %d15,[%a4]76
80004cea:	37 4f 05 f0 	insert %d15,%d15,%d4,0,5
80004cee:	59 4f 0c 10 	st.w [%a4]76,%d15

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
80004cf2:	f6 46       	jnz %d4,80004cfe <IfxAsclin_setClockSource+0x18>
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004cf4:	19 4f 0c 10 	ld.w %d15,[%a4]76
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004cf8:	bf 0f fe 7f 	jlt %d15,0,80004cf4 <IfxAsclin_setClockSource+0xe>
80004cfc:	00 90       	ret 
80004cfe:	19 4f 0c 10 	ld.w %d15,[%a4]76
        {}
    }
    else
    {
        while (IfxAsclin_getClockStatus(asclin) != 1U)
80004d02:	ff 0f fe 7f 	jge %d15,0,80004cfe <IfxAsclin_setClockSource+0x18>
80004d06:	00 90       	ret 

80004d08 <IfxAsclin_setBaudrateBitFields>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004d08:	19 4f 0c 10 	ld.w %d15,[%a4]76
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004d0c:	19 42 0c 10 	ld.w %d2,[%a4]76
80004d10:	16 1f       	and %d15,31
80004d12:	8f f2 c1 21 	andn %d2,%d2,31
80004d16:	59 42 0c 10 	st.w [%a4]76,%d2
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004d1a:	19 42 0c 10 	ld.w %d2,[%a4]76

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004d1e:	bf 02 fe 7f 	jlt %d2,0,80004d1a <IfxAsclin_setBaudrateBitFields+0x12>
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
80004d22:	19 42 14 00 	ld.w %d2,[%a4]20
80004d26:	c2 f4       	add %d4,-1
80004d28:	37 42 0c 40 	insert %d4,%d2,%d4,0,12
80004d2c:	59 44 14 00 	st.w [%a4]20,%d4
}


IFX_INLINE void IfxAsclin_setNumerator(Ifx_ASCLIN *asclin, uint16 numerator)
{
    asclin->BRG.B.NUMERATOR = numerator;
80004d30:	19 42 20 00 	ld.w %d2,[%a4]32
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);                             /* turns off the clock for settings */
    IfxAsclin_setPrescaler(asclin, prescaler);                                                   /* sets the prescaler*/
    IfxAsclin_setNumerator(asclin, numerator);                                                   /* sets the numerator*/
    IfxAsclin_setDenominator(asclin, denominator);                                               /* sets the denominator*/
    IfxAsclin_setOversampling(asclin, oversampling);                                             /* sets the oversampling*/
    IfxAsclin_setClockSource(asclin, clockSource);                                               /* sets the clock source back on*/
80004d34:	02 f4       	mov %d4,%d15
80004d36:	37 52 0c 58 	insert %d5,%d2,%d5,16,12
80004d3a:	59 45 20 00 	st.w [%a4]32,%d5
}


IFX_INLINE void IfxAsclin_setDenominator(Ifx_ASCLIN *asclin, uint16 denominator)
{
    asclin->BRG.B.DENOMINATOR = denominator;
80004d3e:	19 42 20 00 	ld.w %d2,[%a4]32
80004d42:	37 62 0c 60 	insert %d6,%d2,%d6,0,12
80004d46:	59 46 20 00 	st.w [%a4]32,%d6
}


IFX_INLINE void IfxAsclin_setOversampling(Ifx_ASCLIN *asclin, IfxAsclin_OversamplingFactor ovsFactor)
{
    asclin->BITCON.B.OVERSAMPLING = ovsFactor;
80004d4a:	19 42 14 00 	ld.w %d2,[%a4]20
80004d4e:	37 72 04 78 	insert %d7,%d2,%d7,16,4
80004d52:	59 47 14 00 	st.w [%a4]20,%d7
80004d56:	1d ff c8 ff 	j 80004ce6 <IfxAsclin_setClockSource>

80004d5a <IfxAsclin_setBitTiming>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004d5a:	19 42 0c 10 	ld.w %d2,[%a4]76
}


boolean IfxAsclin_setBitTiming(Ifx_ASCLIN *asclin, float32 baudrate, IfxAsclin_OversamplingFactor oversampling, IfxAsclin_SamplePointPosition samplepoint, IfxAsclin_SamplesPerBit medianFilter)
{
80004d5e:	20 08       	sub.a %sp,8
80004d60:	8f f2 01 21 	and %d2,%d2,31
80004d64:	02 5f       	mov %d15,%d5
80004d66:	40 4f       	mov.aa %a15,%a4
80004d68:	02 48       	mov %d8,%d4
80004d6a:	02 6a       	mov %d10,%d6
80004d6c:	60 7d       	mov.a %a13,%d7
80004d6e:	60 2c       	mov.a %a12,%d2
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80004d70:	6d ff 33 ff 	call 80004bd6 <IfxAsclin_getPdFrequency>
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80004d74:	92 15       	add %d5,%d15,1
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80004d76:	02 29       	mov %d9,%d2
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80004d78:	82 4f       	mov %d15,4
80004d7a:	0b f5 b0 f1 	max.u %d15,%d5,%d15
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80004d7e:	8f ff 0f 21 	and %d2,%d15,255
80004d82:	59 a2 04 00 	st.w [%sp]4,%d2
80004d86:	82 16       	mov %d6,1
80004d88:	0b 6a b0 61 	max.u %d6,%d10,%d6
80004d8c:	16 ff       	and %d15,255
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    fOvs         = baudrate * oversampling;
80004d8e:	4b 0f 41 31 	itof %d3,%d15
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
80004d92:	8f f6 0f 61 	and %d6,%d6,255
    fOvs         = baudrate * oversampling;
80004d96:	4b 38 41 f0 	mul.f %d15,%d8,%d3
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
80004d9a:	60 6e       	mov.a %a14,%d6
    fOvs         = baudrate * oversampling;
    float32               relError   = fOvs;
    float32               limit      = 0.001 * fOvs;                     // save the error limit
80004d9c:	02 f4       	mov %d4,%d15
80004d9e:	6d 00 c5 28 	call 80009f28 <__extendsfdf2>
80004da2:	7b 00 f5 73 	movh %d7,16208
80004da6:	0b 23 10 48 	mov %e4,%d3,%d2
80004daa:	7b 20 2f 6d 	movh %d6,54002
80004dae:	1b d7 24 76 	addi %d7,%d7,25165
80004db2:	1b c6 9f 6a 	addi %d6,%d6,-22020
80004db6:	6d 00 dc 29 	call 8000a16e <__muldf3>
80004dba:	0b 23 10 48 	mov %e4,%d3,%d2
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
    nBest          = n;
80004dbe:	82 1c       	mov %d12,1
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    fOvs         = baudrate * oversampling;
    float32               relError   = fOvs;
    float32               limit      = 0.001 * fOvs;                     // save the error limit
80004dc0:	6d 00 68 2b 	call 8000a490 <__truncdfsf2>

    boolean               terminated = FALSE;
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
80004dc4:	4b f9 51 50 	div.f %d5,%d9,%d15
80004dc8:	91 00 00 20 	movh.a %a2,0

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
    relError       = __absf(fOvs - f);
80004dcc:	82 01       	mov %d1,0

    boolean               terminated = FALSE;
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
80004dce:	4b 05 71 51 	ftouz %d5,%d5
    }

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
80004dd2:	4b 05 61 31 	utof %d3,%d5
80004dd6:	4b 39 51 30 	div.f %d3,%d9,%d3
    relError       = __absf(fOvs - f);
80004dda:	6b 03 31 3f 	sub.f %d3,%d15,%d3
80004dde:	4b 13 01 00 	cmp.f %d0,%d3,%d1
80004de2:	37 00 61 00 	extr.u %d0,%d0,0,1
80004de6:	9b 03 00 48 	addih %d4,%d3,32768
80004dea:	2b 34 40 30 	sel %d3,%d0,%d4,%d3
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004dee:	4b 23 01 00 	cmp.f %d0,%d3,%d2
80004df2:	87 00 a0 00 	or.t %d0,%d0,0,%d0,1
80004df6:	df 00 45 80 	jne %d0,0,80004e80 <IfxAsclin_setBitTiming+0x126>
80004dfa:	8f 15 00 60 	sh %d6,%d5,1
            /* Increase the value of the oversampling to generate the required baudrate */
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
80004dfe:	02 51       	mov %d1,%d5
    nBest          = n;
    adder_facL_min = 0;
80004e00:	82 0e       	mov %d14,0
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004e02:	82 28       	mov %d8,2
80004e04:	3b 00 00 71 	mov %d7,4096
80004e08:	7f 76 3b 80 	jge.u %d6,%d7,80004e7e <IfxAsclin_setBitTiming+0x124>
    {
        if (n == 2)
        {
            adder_facL = 1;
            adder_facH = 1;
80004e0c:	a0 13       	mov.a %a3,1

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
        {
            adder_facL = 1;
80004e0e:	82 1b       	mov %d11,1
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
80004e10:	df 28 09 00 	jeq %d8,2,80004e22 <IfxAsclin_setBitTiming+0xc8>
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
80004e14:	73 8e 0a a0 	mul %d10,%d14,%d8
80004e18:	4b ca 11 a2 	div.u %e10,%d10,%d12
            adder_facH = adder_facL + 1;
80004e1c:	60 a3       	mov.a %a3,%d10
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
80004e1e:	02 ab       	mov %d11,%d10
            adder_facH = adder_facL + 1;
80004e20:	b0 13       	add.a %a3,1
        }

        for (count = adder_facL; count <= adder_facH; count++)
80004e22:	80 34       	mov.d %d4,%a3
80004e24:	3f b4 25 80 	jlt.u %d4,%d11,80004e6e <IfxAsclin_setBitTiming+0x114>
        {
            f           = (fpd * n) / (n * d + count);
80004e28:	4b 08 61 01 	utof %d0,%d8
80004e2c:	0b 6b 00 40 	add %d4,%d11,%d6
80004e30:	4b 04 61 d1 	utof %d13,%d4
80004e34:	4b 09 41 00 	mul.f %d0,%d9,%d0
            newRelError = __absf(fOvs - f);
80004e38:	80 2a       	mov.d %d10,%a2
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
        {
            f           = (fpd * n) / (n * d + count);
80004e3a:	4b d0 51 00 	div.f %d0,%d0,%d13
            newRelError = __absf(fOvs - f);
80004e3e:	6b 00 31 0f 	sub.f %d0,%d15,%d0
80004e42:	4b a0 01 d0 	cmp.f %d13,%d0,%d10
80004e46:	37 0d 61 d0 	extr.u %d13,%d13,0,1
80004e4a:	9b 00 00 a8 	addih %d10,%d0,32768
80004e4e:	2b 0a 40 0d 	sel %d0,%d13,%d10,%d0

            if (relError > (newRelError))
80004e52:	4b 03 01 d0 	cmp.f %d13,%d3,%d0
80004e56:	37 0d 61 d1 	extr.u %d13,%d13,2,1
80004e5a:	2b be 50 ed 	seln %d14,%d13,%d14,%d11
80004e5e:	2b 03 50 3d 	seln %d3,%d13,%d3,%d0
80004e62:	2b 8c 50 cd 	seln %d12,%d13,%d12,%d8
80004e66:	2b 41 50 1d 	seln %d1,%d13,%d1,%d4
        {
            adder_facL = (adder_facL_min * n) / nBest;
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
80004e6a:	c2 1b       	add %d11,1
80004e6c:	3c db       	j 80004e22 <IfxAsclin_setBitTiming+0xc8>
                dBest          = (n * d + count);
                adder_facL_min = count;
            }
        }

        if (relError <= limit)
80004e6e:	4b 23 01 00 	cmp.f %d0,%d3,%d2
80004e72:	87 00 a0 00 	or.t %d0,%d0,0,%d0,1
80004e76:	f6 04       	jnz %d0,80004e7e <IfxAsclin_setBitTiming+0x124>
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004e78:	c2 18       	add %d8,1
80004e7a:	42 56       	add %d6,%d5
80004e7c:	3c c6       	j 80004e08 <IfxAsclin_setBitTiming+0xae>
80004e7e:	02 15       	mov %d5,%d1
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004e80:	19 f3 0c 10 	ld.w %d3,[%a15]76
80004e84:	8f f3 c1 31 	andn %d3,%d3,31
80004e88:	59 f3 0c 10 	st.w [%a15]76,%d3
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004e8c:	19 ff 0c 10 	ld.w %d15,[%a15]76

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004e90:	bf 0f fe 7f 	jlt %d15,0,80004e8c <IfxAsclin_setBitTiming+0x132>
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80004e94:	4c f8       	ld.w %d15,[%a15]32
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80004e96:	19 a2 04 00 	ld.w %d2,[%sp]4
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80004e9a:	37 5f 0c 50 	insert %d5,%d15,%d5,0,12
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80004e9e:	c2 f2       	add %d2,-1
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80004ea0:	68 85       	st.w [%a15]32,%d5
    asclin->BRG.B.NUMERATOR   = nBest;
80004ea2:	4c f8       	ld.w %d15,[%a15]32

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80004ea4:	80 ea       	mov.d %d10,%a14
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;
80004ea6:	37 cf 0c c8 	insert %d12,%d15,%d12,16,12
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);
80004eaa:	80 c4       	mov.d %d4,%a12
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;
80004eac:	68 8c       	st.w [%a15]32,%d12

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80004eae:	4c f5       	ld.w %d15,[%a15]20
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);
80004eb0:	40 f4       	mov.aa %a4,%a15
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80004eb2:	37 2f 04 28 	insert %d2,%d15,%d2,16,4
80004eb6:	68 52       	st.w [%a15]20,%d2

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80004eb8:	4c f5       	ld.w %d15,[%a15]20

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80004eba:	80 d2       	mov.d %d2,%a13

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80004ebc:	37 af 04 6c 	insert %d6,%d15,%d10,24,4

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80004ec0:	7b 00 00 f8 	movh %d15,32768

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80004ec4:	68 56       	st.w [%a15]20,%d6

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80004ec6:	ab 0f 80 72 	sel %d7,%d2,%d15,0
80004eca:	4c f5       	ld.w %d15,[%a15]20
80004ecc:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
80004ed0:	a6 7f       	or %d15,%d7
80004ed2:	68 5f       	st.w [%a15]20,%d15

    IfxAsclin_setClockSource(asclin, source);
80004ed4:	6d ff 09 ff 	call 80004ce6 <IfxAsclin_setClockSource>

    return TRUE;
}
80004ed8:	82 12       	mov %d2,1
80004eda:	00 90       	ret 

80004edc <IfxAsclin_write16>:
    }
}


uint32 IfxAsclin_write16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
80004edc:	9f 04 04 80 	jned %d4,0,80004ee4 <IfxAsclin_write16+0x8>
        txData->U = *data++;
        count--;
    }

    return count;
}
80004ee0:	82 02       	mov %d2,0
80004ee2:	00 90       	ret 
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
80004ee4:	b9 5f 00 00 	ld.hu %d15,[%a5]0
80004ee8:	b0 25       	add.a %a5,2
80004eea:	59 4f 04 10 	st.w [%a4]68,%d15
80004eee:	3c f7       	j 80004edc <IfxAsclin_write16>

80004ef0 <IfxAsclin_write32>:
    return count;
}


uint32 IfxAsclin_write32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
80004ef0:	9f 04 04 80 	jned %d4,0,80004ef8 <IfxAsclin_write32+0x8>
        txData->U = *data++;
        count--;
    }

    return count;
}
80004ef4:	82 02       	mov %d2,0
80004ef6:	00 90       	ret 
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
80004ef8:	4c 50       	ld.w %d15,[%a5]0
80004efa:	b0 45       	add.a %a5,4
80004efc:	59 4f 04 10 	st.w [%a4]68,%d15
80004f00:	3c f8       	j 80004ef0 <IfxAsclin_write32>

80004f02 <IfxAsclin_write8>:
    return count;
}

#include <stdio.h>
uint32 IfxAsclin_write8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80004f02:	9f 04 04 80 	jned %d4,0,80004f0a <IfxAsclin_write8+0x8>
        count--;

    }

    return count;
}
80004f06:	82 02       	mov %d2,0
80004f08:	00 90       	ret 
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {

        txData->U = *data++;
80004f0a:	0c 50       	ld.bu %d15,[%a5]0
80004f0c:	b0 15       	add.a %a5,1
80004f0e:	59 4f 04 10 	st.w [%a4]68,%d15
80004f12:	3c f8       	j 80004f02 <IfxAsclin_write8>

80004f14 <IfxAsclin_Asc_getReadCount>:
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
80004f14:	cc 42       	ld.a %a15,[%a4]8


sint32 IfxAsclin_Asc_getReadCount(IfxAsclin_Asc *asclin)
{
    return Ifx_Fifo_readCount(asclin->rx);
}
80004f16:	88 22       	ld.h %d2,[%a15]4
80004f18:	00 90       	ret 

80004f1a <IfxAsclin_Asc_getReadEvent>:


IfxStdIf_DPipe_ReadEvent IfxAsclin_Asc_getReadEvent(IfxAsclin_Asc *asclin)
{
    return &asclin->rx->eventWriter;
80004f1a:	99 42 08 00 	ld.a %a2,[%a4]8
}
80004f1e:	d9 22 1d 00 	lea %a2,[%a2]29
80004f22:	00 90       	ret 

80004f24 <IfxAsclin_Asc_getSendCount>:


uint32 IfxAsclin_Asc_getSendCount(IfxAsclin_Asc *asclin)
{
    return asclin->sendCount;
80004f24:	19 42 10 00 	ld.w %d2,[%a4]16
}
80004f28:	00 90       	ret 

80004f2a <IfxAsclin_Asc_getTxTimeStamp>:


Ifx_TickTime IfxAsclin_Asc_getTxTimeStamp(IfxAsclin_Asc *asclin)
{
    return asclin->txTimestamp;
80004f2a:	09 42 54 09 	ld.d %e2,[%a4]20
}
80004f2e:	00 90       	ret 

80004f30 <IfxAsclin_Asc_getWriteCount>:


sint32 IfxAsclin_Asc_getWriteCount(IfxAsclin_Asc *asclin)
{
    return Ifx_Fifo_writeCount(asclin->tx);
80004f30:	cc 41       	ld.a %a15,[%a4]4
 *
 * \return Returns the free size in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_writeCount(Ifx_Fifo *fifo)
{
    return (Ifx_SizeT)(fifo->size - Ifx_Fifo_readCount(fifo));
80004f32:	88 c2       	ld.h %d2,[%a15]24
80004f34:	8c f2       	ld.h %d15,[%a15]4
80004f36:	a2 f2       	sub %d2,%d15
}
80004f38:	37 02 50 20 	extr %d2,%d2,0,16
80004f3c:	00 90       	ret 

80004f3e <IfxAsclin_Asc_getWriteEvent>:


IfxStdIf_DPipe_WriteEvent IfxAsclin_Asc_getWriteEvent(IfxAsclin_Asc *asclin)
{
    return &asclin->tx->eventWriter;
80004f3e:	99 42 04 00 	ld.a %a2,[%a4]4
}
80004f42:	d9 22 1d 00 	lea %a2,[%a2]29
80004f46:	00 90       	ret 

80004f48 <IfxAsclin_Asc_isrError>:
}


void IfxAsclin_Asc_isrError(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin; /* getting the pointer to ASCLIN registers from module handler*/
80004f48:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE boolean IfxAsclin_getParityErrorFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.PE;
80004f4a:	4c fd       	ld.w %d15,[%a15]52

    /* store all the flags in the variable */
    if (IfxAsclin_getParityErrorFlagStatus(asclinSFR))
80004f4c:	ef 0f 0a 00 	jz.t %d15,16,80004f60 <IfxAsclin_Asc_isrError+0x18>
}


IFX_INLINE void IfxAsclin_clearParityErrorFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.PEC = 1;
80004f50:	4c ff       	ld.w %d15,[%a15]60
80004f52:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80004f56:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearParityErrorFlag(asclinSFR);
        asclin->errorFlags.flags.parityError = 1;
80004f58:	0c 4e       	ld.bu %d15,[%a4]14
80004f5a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
80004f5e:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getFrameErrorFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.FE;
80004f60:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getFrameErrorFlagStatus(asclinSFR))
80004f62:	ef 2f 0a 00 	jz.t %d15,18,80004f76 <IfxAsclin_Asc_isrError+0x2e>
}


IFX_INLINE void IfxAsclin_clearFrameErrorFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.FEC = 1;
80004f66:	4c ff       	ld.w %d15,[%a15]60
80004f68:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80004f6c:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearFrameErrorFlag(asclinSFR);
        asclin->errorFlags.flags.frameError = 1;
80004f6e:	0c 4e       	ld.bu %d15,[%a4]14
80004f70:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
80004f74:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getRxFifoOverflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.RFO;
80004f76:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getRxFifoOverflowFlagStatus(asclinSFR))
80004f78:	ef af 0a 00 	jz.t %d15,26,80004f8c <IfxAsclin_Asc_isrError+0x44>
}


IFX_INLINE void IfxAsclin_clearRxFifoOverflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.RFOC = 1;
80004f7c:	4c ff       	ld.w %d15,[%a15]60
80004f7e:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80004f82:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearRxFifoOverflowFlag(asclinSFR);
        asclin->errorFlags.flags.rxFifoOverflow = 1;
80004f84:	0c 4e       	ld.bu %d15,[%a4]14
80004f86:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
80004f8a:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getRxFifoUnderflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.RFU;
80004f8c:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getRxFifoUnderflowFlagStatus(asclinSFR))
80004f8e:	ef bf 0a 00 	jz.t %d15,27,80004fa2 <IfxAsclin_Asc_isrError+0x5a>
}


IFX_INLINE void IfxAsclin_clearRxFifoUnderflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.RFUC = 1;
80004f92:	4c ff       	ld.w %d15,[%a15]60
80004f94:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80004f98:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearRxFifoUnderflowFlag(asclinSFR);
        asclin->errorFlags.flags.rxFifoUnderflow = 1;
80004f9a:	0c 4e       	ld.bu %d15,[%a4]14
80004f9c:	b7 1f 81 f1 	insert %d15,%d15,1,3,1
80004fa0:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getTxFifoOverflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.TFO;
80004fa2:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getTxFifoOverflowFlagStatus(asclinSFR))
80004fa4:	ef ef 0a 00 	jz.t %d15,30,80004fb8 <IfxAsclin_Asc_isrError+0x70>
}


IFX_INLINE void IfxAsclin_clearTxFifoOverflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.TFOC = 1;
80004fa8:	4c ff       	ld.w %d15,[%a15]60
80004faa:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80004fae:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearTxFifoOverflowFlag(asclinSFR);
        asclin->errorFlags.flags.txFifoOverflow = 1;
80004fb0:	0c 4e       	ld.bu %d15,[%a4]14
80004fb2:	b7 1f 01 f2 	insert %d15,%d15,1,4,1
80004fb6:	2c 4e       	st.b [%a4]14,%d15
80004fb8:	00 90       	ret 

80004fba <IfxAsclin_Asc_resetSendCount>:
}


void IfxAsclin_Asc_resetSendCount(IfxAsclin_Asc *asclin)
{
    asclin->sendCount = 0;
80004fba:	82 0f       	mov %d15,0
80004fbc:	6c 44       	st.w [%a4]16,%d15
80004fbe:	00 90       	ret 

80004fc0 <IfxAsclin_Asc_canReadCount>:
}


boolean IfxAsclin_Asc_canReadCount(IfxAsclin_Asc *asclin, Ifx_SizeT count, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canReadCount(asclin->rx, count, timeout);
80004fc0:	99 44 08 00 	ld.a %a4,[%a4]8
80004fc4:	1d 00 df 18 	j 80008182 <Ifx_Fifo_canReadCount>

80004fc8 <IfxAsclin_Asc_flushTx>:

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80004fc8:	82 f2       	mov %d2,-1
80004fca:	06 f2       	sh %d2,-1
80004fcc:	ba f4       	eq %d15,%d4,-1
80004fce:	0b 52 00 f2 	and.eq %d15,%d2,%d5
    IfxScuWdt_setCpuEndinit(psw);                 /* setting the endinit protection back on */
}


boolean IfxAsclin_Asc_flushTx(IfxAsclin_Asc *asclin, Ifx_TickTime timeout)
{
80004fd2:	40 4f       	mov.aa %a15,%a4
80004fd4:	02 46       	mov %d6,%d4
    {
        deadLine = TIME_INFINITE;
80004fd6:	82 f9       	mov %d9,-1
80004fd8:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80004fda:	ee 16       	jnz %d15,80005006 <IfxAsclin_Asc_flushTx+0x3e>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80004fdc:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80004fe0:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80004fe4:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80004fe8:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004fea:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80004fee:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80004ff2:	02 39       	mov %d9,%d3
80004ff4:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80004ff8:	76 23       	jz %d2,80004ffe <IfxAsclin_Asc_flushTx+0x36>
    {
        __enable();
80004ffa:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80004ffe:	0b 69 40 90 	addx %d9,%d9,%d6
80005002:	0b 58 50 80 	addc %d8,%d8,%d5
 *
 * \return TRUE if the buffer is emptied.
 */
IFX_INLINE boolean Ifx_Fifo_flush(Ifx_Fifo *fifo, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canWriteCount(fifo, fifo->size, timeout);
80005006:	c8 14       	ld.a %a4,[%a15]4
80005008:	02 57       	mov %d7,%d5
8000500a:	c9 44 18 00 	ld.h %d4,[%a4]24
8000500e:	6d 00 fd 19 	call 80008408 <Ifx_Fifo_canWriteCount>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80005012:	82 f4       	mov %d4,-1
80005014:	06 f4       	sh %d4,-1
    boolean      result;

    /* Flush the software FIFO */
    result = Ifx_Fifo_flush(asclin->tx, timeout);

    if (result)
80005016:	f6 23       	jnz %d2,8000501c <IfxAsclin_Asc_flushTx+0x54>
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
    {
        deadLine = TIME_INFINITE;
80005018:	82 02       	mov %d2,0
8000501a:	00 90       	ret 
    {
        /* Flush the hardware FIFO (wait until all bytes have been transmitted) */
        do
        {
            result = IfxAsclin_getTxFifoFillLevel(asclin->asclin) == 0;
8000501c:	c8 02       	ld.a %a2,[%a15]0
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
8000501e:	4c 23       	ld.w %d15,[%a2]12
80005020:	37 0f 65 f8 	extr.u %d15,%d15,16,5
        } while (!result && !IfxStm_isDeadLine(deadline));
80005024:	6e 1e       	jz %d15,80005060 <IfxAsclin_Asc_flushTx+0x98>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80005026:	ba f9       	eq %d15,%d9,-1
80005028:	0b 84 00 f2 	and.eq %d15,%d4,%d8
8000502c:	ee f9       	jnz %d15,8000501e <IfxAsclin_Asc_flushTx+0x56>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000502e:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80005032:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80005036:	0d 00 40 03 	disable 
8000503a:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000503c:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80005040:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80005044:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005048:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000504c:	76 23       	jz %d2,80005052 <IfxAsclin_Asc_flushTx+0x8a>
    {
        __enable();
8000504e:	0d 00 00 03 	enable 
80005052:	0b 8f 00 21 	eq %d2,%d15,%d8
80005056:	0b 93 30 22 	and.lt.u %d2,%d3,%d9
8000505a:	0b 8f 90 22 	or.lt %d2,%d15,%d8
8000505e:	3c dc       	j 80005016 <IfxAsclin_Asc_flushTx+0x4e>
80005060:	82 12       	mov %d2,1
    }

    return result;
}
80005062:	00 90       	ret 

80005064 <IfxAsclin_Asc_canWriteCount>:
}


boolean IfxAsclin_Asc_canWriteCount(IfxAsclin_Asc *asclin, Ifx_SizeT count, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canWriteCount(asclin->tx, count, timeout);
80005064:	99 44 04 00 	ld.a %a4,[%a4]4
80005068:	1d 00 d0 19 	j 80008408 <Ifx_Fifo_canWriteCount>

8000506c <IfxAsclin_Asc_clearRx>:
}


void IfxAsclin_Asc_clearRx(IfxAsclin_Asc *asclin)
{
    IfxAsclin_flushRxFifo(asclin->asclin);
8000506c:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE void IfxAsclin_flushRxFifo(Ifx_ASCLIN *asclin)
{
    asclin->RXFIFOCON.B.FLUSH = 1;
8000506e:	4c f4       	ld.w %d15,[%a15]16
80005070:	96 01       	or %d15,1
80005072:	68 4f       	st.w [%a15]16,%d15
    Ifx_Fifo_clear(asclin->rx);
80005074:	99 44 08 00 	ld.a %a4,[%a4]8
80005078:	1d 00 ad 19 	j 800083d2 <Ifx_Fifo_clear>

8000507c <IfxAsclin_Asc_clearTx>:
}


void IfxAsclin_Asc_clearTx(IfxAsclin_Asc *asclin)
{
8000507c:	40 4f       	mov.aa %a15,%a4
    Ifx_Fifo_clear(asclin->tx);
8000507e:	99 44 04 00 	ld.a %a4,[%a4]4
80005082:	6d 00 a8 19 	call 800083d2 <Ifx_Fifo_clear>
    IfxAsclin_flushTxFifo(asclin->asclin);
80005086:	c8 0f       	ld.a %a15,[%a15]0
}


IFX_INLINE void IfxAsclin_flushTxFifo(Ifx_ASCLIN *asclin)
{
    asclin->TXFIFOCON.B.FLUSH = 1;
80005088:	4c f3       	ld.w %d15,[%a15]12
8000508a:	96 01       	or %d15,1
8000508c:	68 3f       	st.w [%a15]12,%d15
8000508e:	00 90       	ret 

80005090 <IfxAsclin_Asc_read>:
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
80005090:	99 44 08 00 	ld.a %a4,[%a4]8
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
80005094:	0b 45 10 68 	mov %e6,%d5,%d4
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
80005098:	94 64       	ld.h %d4,[%a6]
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
8000509a:	40 6f       	mov.aa %a15,%a6
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
8000509c:	6d 00 e0 18 	call 8000825c <Ifx_Fifo_read>

    *count -= left;
800050a0:	8c f0       	ld.h %d15,[%a15]0
800050a2:	a2 2f       	sub %d15,%d2
800050a4:	a8 0f       	st.h [%a15]0,%d15

    return left == 0;
}
800050a6:	8b 02 00 22 	eq %d2,%d2,0
800050aa:	00 90       	ret 

800050ac <IfxAsclin_Asc_isrTransmit>:
    }
}

#include <stdio.h>
void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
800050ac:	20 18       	sub.a %sp,24
800050ae:	40 4f       	mov.aa %a15,%a4
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800050b0:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
800050b4:	37 04 e1 47 	extr.u %d4,%d4,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800050b8:	0d 00 40 03 	disable 
800050bc:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800050be:	85 f5 10 00 	ld.w %d5,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800050c2:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800050c6:	02 52       	mov %d2,%d5
800050c8:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800050cc:	76 43       	jz %d4,800050d2 <IfxAsclin_Asc_isrTransmit+0x26>
    {
        __enable();
800050ce:	0d 00 00 03 	enable 
    asclin->txTimestamp = IfxStm_now();
800050d2:	89 f2 54 09 	st.d [%a15]20,%e2
    asclin->sendCount++;

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
800050d6:	c8 14       	ld.a %a4,[%a15]4

#include <stdio.h>
void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
    asclin->txTimestamp = IfxStm_now();
    asclin->sendCount++;
800050d8:	4c f4       	ld.w %d15,[%a15]16
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
800050da:	c9 44 04 00 	ld.h %d4,[%a4]4
800050de:	c2 1f       	add %d15,1
800050e0:	68 4f       	st.w [%a15]16,%d15

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
800050e2:	df 04 32 00 	jeq %d4,0,80005146 <IfxAsclin_Asc_isrTransmit+0x9a>
    {

        switch (asclin->dataBufferMode)
800050e6:	0c ff       	ld.bu %d15,[%a15]15
800050e8:	6e 03       	jz %d15,800050ee <IfxAsclin_Asc_isrTransmit+0x42>
800050ea:	9e 1d       	jeq %d15,1,80005124 <IfxAsclin_Asc_isrTransmit+0x78>
800050ec:	00 90       	ret 
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/

            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
800050ee:	c8 02       	ld.a %a2,[%a15]0
        case Ifx_DataBufferMode_normal:
        {

            uint8          ascData[16];
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;
800050f0:	2c a7       	st.b [%sp]7,%d15

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/
800050f2:	37 04 70 40 	extr.u %d4,%d4,0,16
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
800050f6:	4c 23       	ld.w %d15,[%a2]12
            if (i_count > count)
            {
                i_count = count;
            }

            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
800050f8:	d2 06       	mov %e6,0
800050fa:	37 0f 65 f8 	extr.u %d15,%d15,16,5
800050fe:	d9 a5 08 00 	lea %a5,[%sp]8
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/

            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
80005102:	2c a7       	st.b [%sp]7,%d15

            i_count          = (16 - hw_tx_fill_level);
80005104:	0c a7       	ld.bu %d15,[%sp]7
80005106:	8b 0f 01 f1 	rsub %d15,%d15,16
8000510a:	37 0f 70 f0 	extr.u %d15,%d15,0,16
8000510e:	0b 4f 90 f1 	min.u %d15,%d15,%d4
            if (i_count > count)
            {
                i_count = count;
            }

            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
80005112:	37 0f 50 40 	extr %d4,%d15,0,16
80005116:	6d 00 a3 18 	call 8000825c <Ifx_Fifo_read>
            IfxAsclin_write8(asclin->asclin, &ascData[0], i_count);
8000511a:	c8 04       	ld.a %a4,[%a15]0
8000511c:	d9 a5 08 00 	lea %a5,[%sp]8
80005120:	02 f4       	mov %d4,%d15
80005122:	3c 10       	j 80005142 <IfxAsclin_Asc_isrTransmit+0x96>
        {

            Ifx_DataBufferMode_TimeStampSingle packedData;
            uint8                              ascData;

            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
80005124:	d2 06       	mov %e6,0
80005126:	d9 a5 08 00 	lea %a5,[%sp]8
8000512a:	3b c0 00 40 	mov %d4,12
8000512e:	6d 00 97 18 	call 8000825c <Ifx_Fifo_read>

            ascData = packedData.data;
80005132:	39 af 10 00 	ld.bu %d15,[%sp]16
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
80005136:	c8 04       	ld.a %a4,[%a15]0
            Ifx_DataBufferMode_TimeStampSingle packedData;
            uint8                              ascData;

            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);

            ascData = packedData.data;
80005138:	d9 a5 18 00 	lea %a5,[%sp]24
8000513c:	89 5f 2f f4 	st.b [+%a5]-17,%d15
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
80005140:	82 14       	mov %d4,1
        }
        break;
80005142:	1d ff e0 fe 	j 80004f02 <IfxAsclin_write8>
    }
    else
    {

        /* Transmit buffer is empty */
        asclin->txInProgress = FALSE;
80005146:	28 c4       	st.b [%a15]12,%d4
80005148:	00 90       	ret 

8000514a <IfxAsclin_Asc_isrReceive>:

void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
8000514a:	0c 4f       	ld.bu %d15,[%a4]15
    }
}


void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
8000514c:	20 20       	sub.a %sp,32
8000514e:	40 4f       	mov.aa %a15,%a4
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
80005150:	6e 34       	jz %d15,800051b8 <IfxAsclin_Asc_isrReceive+0x6e>
            packedData.data      = ascData[0];

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
            {
                /* Receive buffer is full, data is discard */
                asclin->rxSwFifoOverflow = TRUE;
80005152:	82 18       	mov %d8,1

void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
80005154:	df 1f 45 80 	jne %d15,1,800051de <IfxAsclin_Asc_isrReceive+0x94>
    }
    case Ifx_DataBufferMode_timeStampSingle:
    {
        Ifx_DataBufferMode_TimeStampSingle packedData;

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
80005158:	c8 02       	ld.a %a2,[%a15]0
}


IFX_INLINE uint8 IfxAsclin_getRxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->RXFIFOCON.B.FILL;
8000515a:	4c 24       	ld.w %d15,[%a2]16
8000515c:	37 0f 65 f8 	extr.u %d15,%d15,16,5
80005160:	6e 2b       	jz %d15,800051b6 <IfxAsclin_Asc_isrReceive+0x6c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80005162:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
80005166:	37 03 e1 37 	extr.u %d3,%d3,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000516a:	0d 00 40 03 	disable 
8000516e:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80005170:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80005174:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80005178:	8f 02 40 21 	or %d2,%d2,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000517c:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80005180:	76 33       	jz %d3,80005186 <IfxAsclin_Asc_isrReceive+0x3c>
    {
        __enable();
80005182:	0d 00 00 03 	enable 
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
80005186:	c8 04       	ld.a %a4,[%a15]0
80005188:	d9 a5 10 00 	lea %a5,[%sp]16
8000518c:	82 14       	mov %d4,1
    {
        Ifx_DataBufferMode_TimeStampSingle packedData;

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
8000518e:	78 02       	st.w [%sp]8,%d15
80005190:	59 a2 04 00 	st.w [%sp]4,%d2
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
80005194:	6d ff 7a fd 	call 80004c88 <IfxAsclin_read8>
            packedData.data      = ascData[0];

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
80005198:	c8 24       	ld.a %a4,[%a15]8

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
            packedData.data      = ascData[0];
8000519a:	39 af 10 00 	ld.bu %d15,[%sp]16

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
8000519e:	d2 06       	mov %e6,0
800051a0:	d9 a5 04 00 	lea %a5,[%sp]4
800051a4:	3b c0 00 40 	mov %d4,12

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
            packedData.data      = ascData[0];
800051a8:	2c ac       	st.b [%sp]12,%d15

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
800051aa:	6d 00 a7 19 	call 800084f8 <Ifx_Fifo_write>
800051ae:	df 02 d5 7f 	jeq %d2,0,80005158 <IfxAsclin_Asc_isrReceive+0xe>
            {
                /* Receive buffer is full, data is discard */
                asclin->rxSwFifoOverflow = TRUE;
800051b2:	28 d8       	st.b [%a15]13,%d8
800051b4:	3c d2       	j 80005158 <IfxAsclin_Asc_isrReceive+0xe>
800051b6:	00 90       	ret 
    switch (asclin->dataBufferMode)
    {
    case Ifx_DataBufferMode_normal:
    {
        uint8 count;
        count = IfxAsclin_getRxFifoFillLevel(asclin->asclin);
800051b8:	d4 44       	ld.a %a4,[%a4]
        IfxAsclin_read8(asclin->asclin, &ascData[0], count);
800051ba:	d9 a5 10 00 	lea %a5,[%sp]16
800051be:	4c 44       	ld.w %d15,[%a4]16
800051c0:	37 0f 65 f8 	extr.u %d15,%d15,16,5
800051c4:	02 f4       	mov %d4,%d15
800051c6:	6d ff 61 fd 	call 80004c88 <IfxAsclin_read8>

        if (Ifx_Fifo_write(asclin->rx, &ascData[0], count, TIME_NULL) != 0)
800051ca:	c8 24       	ld.a %a4,[%a15]8
800051cc:	d2 06       	mov %e6,0
800051ce:	d9 a5 10 00 	lea %a5,[%sp]16
800051d2:	02 f4       	mov %d4,%d15
800051d4:	6d 00 92 19 	call 800084f8 <Ifx_Fifo_write>
800051d8:	76 23       	jz %d2,800051de <IfxAsclin_Asc_isrReceive+0x94>
        {
            /* Receive buffer is full, data is discard */
            asclin->rxSwFifoOverflow = TRUE;
800051da:	82 1f       	mov %d15,1
800051dc:	28 df       	st.b [%a15]13,%d15
800051de:	00 90       	ret 

800051e0 <IfxAsclin_Asc_blockingRead>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint8 IfxAsclin_Asc_blockingRead(IfxAsclin_Asc *asclin)
{
800051e0:	20 08       	sub.a %sp,8
    Ifx_SizeT count = 1;
800051e2:	82 1f       	mov %d15,1
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint8 IfxAsclin_Asc_blockingRead(IfxAsclin_Asc *asclin)
{
800051e4:	40 4f       	mov.aa %a15,%a4
    Ifx_SizeT count = 1;
800051e6:	ac a3       	st.h [%sp]6,%d15
    uint8     data;

    while (IfxAsclin_Asc_read(asclin, &data, &count, TIME_INFINITE) != TRUE)
800051e8:	82 f4       	mov %d4,-1
800051ea:	40 f4       	mov.aa %a4,%a15
800051ec:	d9 a5 05 00 	lea %a5,[%sp]5
800051f0:	d9 a6 06 00 	lea %a6,[%sp]6
800051f4:	9b 04 00 58 	addih %d5,%d4,32768
800051f8:	6d ff 4c ff 	call 80005090 <IfxAsclin_Asc_read>
800051fc:	df 12 f6 ff 	jne %d2,1,800051e8 <IfxAsclin_Asc_blockingRead+0x8>
    {}

    return data;
}
80005200:	39 a2 05 00 	ld.bu %d2,[%sp]5
80005204:	00 90       	ret 

80005206 <IfxAsclin_Asc_disableModule>:
}


void IfxAsclin_Asc_disableModule(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       /* getting the pointer to ASCLIN registers from module handler*/
80005206:	cc 40       	ld.a %a15,[%a4]0
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
80005208:	6d 00 c5 0f 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);               /* clearing the endinit protection */
8000520c:	02 24       	mov %d4,%d2


void IfxAsclin_Asc_disableModule(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       /* getting the pointer to ASCLIN registers from module handler*/
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
8000520e:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);               /* clearing the endinit protection */
80005210:	6d 00 c1 0e 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setDisableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 1;
80005214:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setDisableModuleRequest(asclinSFR); /* disabling the module */
    IfxScuWdt_setCpuEndinit(psw);                 /* setting the endinit protection back on */
80005216:	02 f4       	mov %d4,%d15
80005218:	8f 12 40 21 	or %d2,%d2,1
8000521c:	68 02       	st.w [%a15]0,%d2
8000521e:	1d 00 ef 0f 	j 800071fc <IfxScuWdt_setCpuEndinit>

80005222 <IfxAsclin_Asc_initModule>:
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
80005222:	cc 50       	ld.a %a15,[%a5]0
    return &asclin->tx->eventWriter;
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
80005224:	40 4e       	mov.aa %a14,%a4
80005226:	40 5c       	mov.aa %a12,%a5
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
    IfxAsclin_Status status    = IfxAsclin_Status_noError;

    asclin->asclin = asclinSFR;                                         /* adding register pointer to module handler*/
80005228:	ec 40       	st.a [%a4]0,%a15

    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
8000522a:	40 f4       	mov.aa %a4,%a15
8000522c:	6d ff 71 fc 	call 80004b0e <IfxAsclin_enableModule>
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
80005230:	40 f4       	mov.aa %a4,%a15
80005232:	82 04       	mov %d4,0
80005234:	6d ff 59 fd 	call 80004ce6 <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
80005238:	4c f6       	ld.w %d15,[%a15]24
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
8000523a:	40 f4       	mov.aa %a4,%a15
8000523c:	b7 0f 02 f8 	insert %d15,%d15,0,16,2
80005240:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
80005242:	8c c4       	ld.h %d15,[%a12]8
80005244:	48 52       	ld.w %d2,[%a15]20
80005246:	c2 ff       	add %d15,-1
80005248:	37 f2 0c f0 	insert %d15,%d2,%d15,0,12
8000524c:	68 5f       	st.w [%a15]20,%d15
8000524e:	39 c4 28 00 	ld.bu %d4,[%a12]40
80005252:	6d ff 4a fd 	call 80004ce6 <IfxAsclin_setClockSource>
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
80005256:	40 f4       	mov.aa %a4,%a15
80005258:	19 c4 04 00 	ld.w %d4,[%a12]4
8000525c:	39 c5 0a 00 	ld.bu %d5,[%a12]10
80005260:	39 c6 0d 00 	ld.bu %d6,[%a12]13
80005264:	39 c7 0c 00 	ld.bu %d7,[%a12]12
80005268:	6d ff 79 fd 	call 80004d5a <IfxAsclin_setBitTiming>
        config->baudrate.baudrate,
        config->baudrate.oversampling,
        config->bitTiming.samplePointPosition,
        config->bitTiming.medianFilter);
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
8000526c:	40 f4       	mov.aa %a4,%a15
8000526e:	82 04       	mov %d4,0
    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
80005270:	02 29       	mov %d9,%d2
        config->baudrate.baudrate,
        config->baudrate.oversampling,
        config->bitTiming.samplePointPosition,
        config->bitTiming.medianFilter);
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
80005272:	6d ff 3a fd 	call 80004ce6 <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_enableLoopBackMode(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->IOCR.B.LB = enable ? 1 : 0;
80005276:	39 c2 38 00 	ld.bu %d2,[%a12]56
8000527a:	7b 00 00 f1 	movh %d15,4096
8000527e:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80005282:	4c f1       	ld.w %d15,[%a15]4
80005284:	b7 0f 01 fe 	insert %d15,%d15,0,28,1
80005288:	a6 2f       	or %d15,%d2
8000528a:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxAsclin_enableParity(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FRAMECON.B.PEN = enable ? 1 : 0;
8000528c:	39 c2 14 00 	ld.bu %d2,[%a12]20
80005290:	7b 00 00 f4 	movh %d15,16384
80005294:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80005298:	4c f6       	ld.w %d15,[%a15]24
8000529a:	b7 0f 01 ff 	insert %d15,%d15,0,30,1
8000529e:	a6 2f       	or %d15,%d2
800052a0:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setParityType(Ifx_ASCLIN *asclin, IfxAsclin_ParityType type)
{
    asclin->FRAMECON.B.ODD = type;
800052a2:	48 62       	ld.w %d2,[%a15]24
800052a4:	39 cf 12 00 	ld.bu %d15,[%a12]18
800052a8:	37 f2 81 ff 	insert %d15,%d2,%d15,31,1
800052ac:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setStopBit(Ifx_ASCLIN *asclin, IfxAsclin_StopBit stopBit)
{
    asclin->FRAMECON.B.STOP = stopBit;
800052ae:	48 62       	ld.w %d2,[%a15]24
800052b0:	0c cf       	ld.bu %d15,[%a12]15
800052b2:	37 f2 83 f4 	insert %d15,%d2,%d15,9,3
800052b6:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setShiftDirection(Ifx_ASCLIN *asclin, IfxAsclin_ShiftDirection dir)
{
    asclin->FRAMECON.B.MSB = dir;
800052b8:	48 62       	ld.w %d2,[%a15]24
800052ba:	39 cf 11 00 	ld.bu %d15,[%a12]17
800052be:	67 f2 1c f0 	ins.t %d15,%d2,28,%d15,0
800052c2:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setDataLength(Ifx_ASCLIN *asclin, IfxAsclin_DataLength length)
{
    asclin->DATCON.B.DATLEN = length;
800052c4:	48 72       	ld.w %d2,[%a15]28
800052c6:	39 cf 13 00 	ld.bu %d15,[%a12]19
800052ca:	37 f2 04 f0 	insert %d15,%d2,%d15,0,4
800052ce:	68 7f       	st.w [%a15]28,%d15
}


IFX_INLINE void IfxAsclin_setTxFifoInletWidth(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInletWidth width)
{
    asclin->TXFIFOCON.B.INW = width;
800052d0:	48 32       	ld.w %d2,[%a15]12
800052d2:	39 cf 16 00 	ld.bu %d15,[%a12]22
800052d6:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
800052da:	68 3f       	st.w [%a15]12,%d15
}


IFX_INLINE void IfxAsclin_setRxFifoOutletWidth(Ifx_ASCLIN *asclin, IfxAsclin_RxFifoOutletWidth width)
{
    asclin->RXFIFOCON.B.OUTW = width;
800052dc:	48 42       	ld.w %d2,[%a15]16
800052de:	39 cf 17 00 	ld.bu %d15,[%a12]23
800052e2:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
800052e6:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_setIdleDelay(Ifx_ASCLIN *asclin, IfxAsclin_IdleDelay delay)
{
    asclin->FRAMECON.B.IDLE = delay;
800052e8:	48 62       	ld.w %d2,[%a15]24
800052ea:	0c ce       	ld.bu %d15,[%a12]14
800052ec:	37 f2 03 f3 	insert %d15,%d2,%d15,6,3
800052f0:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setTxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInterruptLevel level)
{
    asclin->TXFIFOCON.B.INTLEVEL = __minu(level, 15);
800052f2:	39 c2 18 00 	ld.bu %d2,[%a12]24
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800052f6:	da 0f       	mov %d15,15
800052f8:	0b f2 90 21 	min.u %d2,%d2,%d15
800052fc:	48 33       	ld.w %d3,[%a15]12
800052fe:	37 23 04 24 	insert %d2,%d3,%d2,8,4
80005302:	68 32       	st.w [%a15]12,%d2
}


IFX_INLINE void IfxAsclin_setRxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_RxFifoInterruptLevel level)
{
    asclin->RXFIFOCON.B.INTLEVEL = __minu(level, 15);
80005304:	39 c2 19 00 	ld.bu %d2,[%a12]25
80005308:	0b f2 90 f1 	min.u %d15,%d2,%d15
8000530c:	48 42       	ld.w %d2,[%a15]16
8000530e:	37 f2 04 f4 	insert %d15,%d2,%d15,8,4
80005312:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
80005314:	39 cf 10 00 	ld.bu %d15,[%a12]16
80005318:	48 62       	ld.w %d2,[%a15]24
8000531a:	37 f2 02 f8 	insert %d15,%d2,%d15,16,2
8000531e:	68 6f       	st.w [%a15]24,%d15
    IfxAsclin_setTxFifoInterruptLevel(asclinSFR, config->fifo.txFifoInterruptLevel); /* setting Tx FIFO level at which a Tx interrupt will be triggered*/
    IfxAsclin_setRxFifoInterruptLevel(asclinSFR, config->fifo.rxFifoInterruptLevel); /* setting Rx FIFO interrupt level at which a Rx interrupt will be triggered*/
    IfxAsclin_setFrameMode(asclinSFR, config->frame.frameMode);                      /* selecting the frame mode*/

    /* Pin mapping */
    const IfxAsclin_Asc_Pins *pins = config->pins;
80005320:	99 cd 24 00 	ld.a %a13,[%a12]36

    if (pins != NULL_PTR)
80005324:	bd 0d 81 00 	jz.a %a13,80005426 <IfxAsclin_Asc_initModule+0x204>
    {
        IfxAsclin_Cts_In *cts = pins->cts;
80005328:	4c d0       	ld.w %d15,[%a13]0

        if (cts != NULL_PTR)
8000532a:	6e 27       	jz %d15,80005378 <IfxAsclin_Asc_initModule+0x156>
}


IFX_INLINE void IfxAsclin_initCtsPin(const IfxAsclin_Cts_In *cts, IfxPort_InputMode inputMode, IfxPort_PadDriver padDriver)
{
    if (cts->pin.port != NULL_PTR)
8000532c:	60 f2       	mov.a %a2,%d15
        {
            IfxAsclin_initCtsPin(cts, pins->ctsMode, pins->pinDriver);
8000532e:	79 d5 04 00 	ld.b %d5,[%a13]4
80005332:	99 24 04 00 	ld.a %a4,[%a2]4
80005336:	39 d8 1d 00 	ld.bu %d8,[%a13]29
8000533a:	bd 04 1f 00 	jz.a %a4,80005378 <IfxAsclin_Asc_initModule+0x156>
8000533e:	39 24 08 00 	ld.bu %d4,[%a2]8
80005342:	8f f5 0f 51 	and %d5,%d5,255
80005346:	6d 00 ba 03 	call 80005aba <IfxPort_setPinMode>
    {
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
8000534a:	60 f3       	mov.a %a3,%d15
8000534c:	02 85       	mov %d5,%d8
8000534e:	99 34 04 00 	ld.a %a4,[%a3]4
80005352:	39 34 08 00 	ld.bu %d4,[%a3]8
80005356:	6d 00 30 04 	call 80005bb6 <IfxPort_setPinPadDriver>
        IfxAsclin_enableCts(cts->module, TRUE);
8000535a:	60 f3       	mov.a %a3,%d15
8000535c:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_enableCts(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->IOCR.B.CTSEN = enable ? 1 : 0;
8000535e:	19 22 04 00 	ld.w %d2,[%a2]4
80005362:	b7 f2 81 2e 	insert %d2,%d2,15,29,1
80005366:	59 22 04 00 	st.w [%a2]4,%d2
    if (cts->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
        IfxAsclin_enableCts(cts->module, TRUE);
        IfxAsclin_setCtsInput(cts->module, (IfxAsclin_CtsInputSelect)cts->select);
8000536a:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_setCtsInput(Ifx_ASCLIN *asclin, IfxAsclin_CtsInputSelect ctsi)
{
    asclin->IOCR.B.CTS = ctsi;
8000536c:	0c 3c       	ld.bu %d15,[%a3]12
8000536e:	19 22 04 00 	ld.w %d2,[%a2]4
80005372:	37 f2 02 f8 	insert %d15,%d2,%d15,16,2
80005376:	6c 21       	st.w [%a2]4,%d15
        }

        IfxAsclin_Rx_In *rx = pins->rx;
80005378:	4c d2       	ld.w %d15,[%a13]8

        if (rx != NULL_PTR)
8000537a:	6e 20       	jz %d15,800053ba <IfxAsclin_Asc_initModule+0x198>
}


IFX_INLINE void IfxAsclin_initRxPin(const IfxAsclin_Rx_In *rx, IfxPort_InputMode inputMode, IfxPort_PadDriver padDriver)
{
    if (rx->pin.port != NULL_PTR)
8000537c:	60 f2       	mov.a %a2,%d15
        {
            IfxAsclin_initRxPin(rx, pins->rxMode, pins->pinDriver);
8000537e:	79 d5 0c 00 	ld.b %d5,[%a13]12
80005382:	99 24 04 00 	ld.a %a4,[%a2]4
80005386:	39 d8 1d 00 	ld.bu %d8,[%a13]29
8000538a:	bd 04 18 00 	jz.a %a4,800053ba <IfxAsclin_Asc_initModule+0x198>
8000538e:	39 24 08 00 	ld.bu %d4,[%a2]8
80005392:	8f f5 0f 51 	and %d5,%d5,255
80005396:	6d 00 92 03 	call 80005aba <IfxPort_setPinMode>
    {
        IfxPort_setPinModeInput(rx->pin.port, rx->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(rx->pin.port, rx->pin.pinIndex, padDriver);
8000539a:	60 f3       	mov.a %a3,%d15
8000539c:	02 85       	mov %d5,%d8
8000539e:	99 34 04 00 	ld.a %a4,[%a3]4
800053a2:	39 34 08 00 	ld.bu %d4,[%a3]8
800053a6:	6d 00 08 04 	call 80005bb6 <IfxPort_setPinPadDriver>
        IfxAsclin_setRxInput(rx->module, (IfxAsclin_RxInputSelect)rx->select);
800053aa:	60 f3       	mov.a %a3,%d15
800053ac:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_setRxInput(Ifx_ASCLIN *asclin, IfxAsclin_RxInputSelect alti)
{
    asclin->IOCR.B.ALTI = alti;
800053ae:	0c 3c       	ld.bu %d15,[%a3]12
800053b0:	19 22 04 00 	ld.w %d2,[%a2]4
800053b4:	37 f2 03 f0 	insert %d15,%d2,%d15,0,3
800053b8:	6c 21       	st.w [%a2]4,%d15
        }

        IfxAsclin_Rts_Out *rts = pins->rts;
800053ba:	4c d4       	ld.w %d15,[%a13]16

        if (rts != NULL_PTR)
800053bc:	6e 1a       	jz %d15,800053f0 <IfxAsclin_Asc_initModule+0x1ce>
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
800053be:	60 f2       	mov.a %a2,%d15
800053c0:	39 d2 14 00 	ld.bu %d2,[%a13]20
800053c4:	39 23 0c 00 	ld.bu %d3,[%a2]12
800053c8:	99 24 04 00 	ld.a %a4,[%a2]4
800053cc:	0f 23 a0 50 	or %d5,%d3,%d2
800053d0:	39 24 08 00 	ld.bu %d4,[%a2]8
800053d4:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxAsclin_initRtsPin(rts, pins->rtsMode, pins->pinDriver);
800053d8:	39 d8 1d 00 	ld.bu %d8,[%a13]29
800053dc:	6d 00 6f 03 	call 80005aba <IfxPort_setPinMode>


IFX_INLINE void IfxAsclin_initRtsPin(const IfxAsclin_Rts_Out *rts, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(rts->pin.port, rts->pin.pinIndex, outputMode, rts->select);
    IfxPort_setPinPadDriver(rts->pin.port, rts->pin.pinIndex, padDriver);
800053e0:	60 f3       	mov.a %a3,%d15
800053e2:	02 85       	mov %d5,%d8
800053e4:	99 34 04 00 	ld.a %a4,[%a3]4
800053e8:	39 34 08 00 	ld.bu %d4,[%a3]8
800053ec:	6d 00 e5 03 	call 80005bb6 <IfxPort_setPinPadDriver>
        }

        IfxAsclin_Tx_Out *tx = pins->tx;
800053f0:	4c d6       	ld.w %d15,[%a13]24

        if (tx != NULL_PTR)
800053f2:	6e 1a       	jz %d15,80005426 <IfxAsclin_Asc_initModule+0x204>
800053f4:	60 f2       	mov.a %a2,%d15
800053f6:	39 d2 1c 00 	ld.bu %d2,[%a13]28
800053fa:	39 23 0c 00 	ld.bu %d3,[%a2]12
800053fe:	99 24 04 00 	ld.a %a4,[%a2]4
80005402:	0f 23 a0 50 	or %d5,%d3,%d2
80005406:	39 24 08 00 	ld.bu %d4,[%a2]8
8000540a:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxAsclin_initTxPin(tx, pins->txMode, pins->pinDriver);
8000540e:	39 d8 1d 00 	ld.bu %d8,[%a13]29
80005412:	6d 00 54 03 	call 80005aba <IfxPort_setPinMode>


IFX_INLINE void IfxAsclin_initTxPin(const IfxAsclin_Tx_Out *tx, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(tx->pin.port, tx->pin.pinIndex, outputMode, tx->select);
    IfxPort_setPinPadDriver(tx->pin.port, tx->pin.pinIndex, padDriver);
80005416:	60 f3       	mov.a %a3,%d15
80005418:	02 85       	mov %d5,%d8
8000541a:	99 34 04 00 	ld.a %a4,[%a3]4
8000541e:	39 34 08 00 	ld.bu %d4,[%a3]8
80005422:	6d 00 ca 03 	call 80005bb6 <IfxPort_setPinPadDriver>
        }
    }

    IfxAsclin_setClockSource(asclinSFR, config->clockSource); /* select the clock source*/
80005426:	40 f4       	mov.aa %a4,%a15
80005428:	39 c4 28 00 	ld.bu %d4,[%a12]40
8000542c:	6d ff 5d fc 	call 80004ce6 <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_disableAllFlags(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSENABLE.U = 0x00000000;
80005430:	82 0f       	mov %d15,0
80005432:	59 ff 00 10 	st.w [%a15]64,%d15
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxAsclin_clearAllFlags(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.U = 0xFFFFFFFF;
80005436:	82 f2       	mov %d2,-1
80005438:	68 f2       	st.w [%a15]60,%d2

    IfxAsclin_disableAllFlags(asclinSFR);                     /* disable all flags */
    IfxAsclin_clearAllFlags(asclinSFR);                       /* clear all flags */

    /* HW error flags */
    asclin->errorFlags.ALL = 0;
8000543a:	2c ee       	st.b [%a14]14,%d15

    if (config->errorFlags.flags.parityError)
8000543c:	4c ca       	ld.w %d15,[%a12]40
8000543e:	2e 87       	jz.t %d15,8,8000544c <IfxAsclin_Asc_initModule+0x22a>
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
80005440:	19 ff 00 10 	ld.w %d15,[%a15]64
80005444:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80005448:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableParityErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.frameError)
8000544c:	4c ca       	ld.w %d15,[%a12]40
8000544e:	2e 97       	jz.t %d15,9,8000545c <IfxAsclin_Asc_initModule+0x23a>
}


IFX_INLINE void IfxAsclin_enableFrameErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.FEE = enable ? 1 : 0;
80005450:	19 ff 00 10 	ld.w %d15,[%a15]64
80005454:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80005458:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableFrameErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoOverflow)
8000545c:	4c ca       	ld.w %d15,[%a12]40
8000545e:	2e a7       	jz.t %d15,10,8000546c <IfxAsclin_Asc_initModule+0x24a>
}


IFX_INLINE void IfxAsclin_enableRxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
80005460:	19 ff 00 10 	ld.w %d15,[%a15]64
80005464:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80005468:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableRxFifoOverflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoUnderflow)
8000546c:	4c ca       	ld.w %d15,[%a12]40
8000546e:	2e b7       	jz.t %d15,11,8000547c <IfxAsclin_Asc_initModule+0x25a>
}


IFX_INLINE void IfxAsclin_enableRxFifoUnderflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFUE = enable ? 1 : 0;
80005470:	19 ff 00 10 	ld.w %d15,[%a15]64
80005474:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80005478:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableRxFifoUnderflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.txFifoOverflow)
8000547c:	4c ca       	ld.w %d15,[%a12]40
8000547e:	2e c7       	jz.t %d15,12,8000548c <IfxAsclin_Asc_initModule+0x26a>
}


IFX_INLINE void IfxAsclin_enableTxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.TFOE = enable ? 1 : 0;
80005480:	19 ff 00 10 	ld.w %d15,[%a15]64
80005484:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80005488:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableTxFifoOverflowFlag(asclinSFR, TRUE);
    }

    /* transmission flags */
    asclin->rxSwFifoOverflow = FALSE;
8000548c:	82 0f       	mov %d15,0
8000548e:	2c ed       	st.b [%a14]13,%d15
    asclin->txInProgress     = FALSE;
80005490:	2c ec       	st.b [%a14]12,%d15

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
80005492:	d2 04       	mov %e4,0
    asclin->rxSwFifoOverflow = FALSE;
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
80005494:	39 c3 39 00 	ld.bu %d3,[%a12]57
    asclin->txTimestamp    = 0;
    asclin->sendCount      = 0;
80005498:	82 0f       	mov %d15,0
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
8000549a:	89 e4 54 09 	st.d [%a14]20,%e4
    asclin->sendCount      = 0;
8000549e:	6c e4       	st.w [%a14]16,%d15
    asclin->rxSwFifoOverflow = FALSE;
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
800054a0:	e9 e3 0f 00 	st.b [%a14]15,%d3
    asclin->sendCount      = 0;

    switch (asclin->dataBufferMode)
    {
    case Ifx_DataBufferMode_normal:
        elementSize = 1;
800054a4:	82 1f       	mov %d15,1
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
    asclin->sendCount      = 0;

    switch (asclin->dataBufferMode)
800054a6:	76 34       	jz %d3,800054ae <IfxAsclin_Asc_initModule+0x28c>
        break;
    case Ifx_DataBufferMode_timeStampSingle:
        elementSize = sizeof(Ifx_DataBufferMode_TimeStampSingle);
        break;
    default:
        elementSize = 0;
800054a8:	ba 13       	eq %d15,%d3,1
800054aa:	ab cf a0 ff 	seln %d15,%d15,%d15,12
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
800054ae:	99 c4 2c 00 	ld.a %a4,[%a12]44
800054b2:	c9 c4 2a 00 	ld.h %d4,[%a12]42
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
800054b6:	02 f5       	mov %d5,%d15
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
800054b8:	bc 44       	jz.a %a4,800054c0 <IfxAsclin_Asc_initModule+0x29e>
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
800054ba:	6d 00 36 16 	call 80008126 <Ifx_Fifo_init>
800054be:	3c 03       	j 800054c4 <IfxAsclin_Asc_initModule+0x2a2>
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
800054c0:	6d 00 50 16 	call 80008160 <Ifx_Fifo_create>
    }

    if (config->rxBuffer != NULL_PTR)
800054c4:	99 c4 34 00 	ld.a %a4,[%a12]52
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
800054c8:	b5 e2 04 00 	st.a [%a14]4,%a2
800054cc:	c9 c4 30 00 	ld.h %d4,[%a12]48
    }

    if (config->rxBuffer != NULL_PTR)
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
800054d0:	02 f5       	mov %d5,%d15
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
    }

    if (config->rxBuffer != NULL_PTR)
800054d2:	bc 44       	jz.a %a4,800054da <IfxAsclin_Asc_initModule+0x2b8>
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
800054d4:	6d 00 29 16 	call 80008126 <Ifx_Fifo_init>
800054d8:	3c 03       	j 800054de <IfxAsclin_Asc_initModule+0x2bc>
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
800054da:	6d 00 43 16 	call 80008160 <Ifx_Fifo_create>
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;
800054de:	39 cf 22 00 	ld.bu %d15,[%a12]34

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
800054e2:	b9 c2 1e 00 	ld.hu %d2,[%a12]30
800054e6:	8b 3f 00 82 	eq %d8,%d15,3
800054ea:	02 83       	mov %d3,%d8
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
800054ec:	b5 e2 08 00 	st.a [%a14]8,%a2
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
800054f0:	8b 02 00 35 	or.ne %d3,%d2,0
800054f4:	df 03 1e 00 	jeq %d3,0,80005530 <IfxAsclin_Asc_initModule+0x30e>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerRx(asclinSFR);
800054f8:	40 f4       	mov.aa %a4,%a15
800054fa:	6d ff a1 fb 	call 80004c3c <IfxAsclin_getSrcPointerRx>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
800054fe:	54 22       	ld.w %d2,[%a2]
80005500:	39 c3 1e 00 	ld.bu %d3,[%a12]30
80005504:	8f f2 cf 21 	andn %d2,%d2,255
80005508:	a6 32       	or %d2,%d3
8000550a:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
8000550c:	54 22       	ld.w %d2,[%a2]
8000550e:	37 f2 82 25 	insert %d2,%d2,%d15,11,2
80005512:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80005514:	54 22       	ld.w %d2,[%a2]
80005516:	b7 f2 81 2c 	insert %d2,%d2,15,25,1
8000551a:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxAsclin_enableRxFifoFillLevelFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFLE = enable ? 1 : 0;
8000551c:	19 f2 00 10 	ld.w %d2,[%a15]64
80005520:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
80005524:	59 f2 00 10 	st.w [%a15]64,%d2
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80005528:	54 22       	ld.w %d2,[%a2]
8000552a:	b7 f2 01 25 	insert %d2,%d2,15,10,1
8000552e:	74 22       	st.w [%a2],%d2
        IfxSrc_init(src, tos, config->interrupt.rxPriority);
        IfxAsclin_enableRxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if ((config->interrupt.txPriority > 0) || (tos == IfxSrc_Tos_dma))
80005530:	b9 c2 1c 00 	ld.hu %d2,[%a12]28
80005534:	8b 02 00 85 	or.ne %d8,%d2,0
80005538:	df 08 1e 00 	jeq %d8,0,80005574 <IfxAsclin_Asc_initModule+0x352>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerTx(asclinSFR);
8000553c:	40 f4       	mov.aa %a4,%a15
8000553e:	6d ff 89 fb 	call 80004c50 <IfxAsclin_getSrcPointerTx>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80005542:	54 22       	ld.w %d2,[%a2]
80005544:	39 c3 1c 00 	ld.bu %d3,[%a12]28
80005548:	8f f2 cf 21 	andn %d2,%d2,255
8000554c:	a6 32       	or %d2,%d3
8000554e:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80005550:	54 22       	ld.w %d2,[%a2]
80005552:	37 f2 82 25 	insert %d2,%d2,%d15,11,2
80005556:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80005558:	54 22       	ld.w %d2,[%a2]
8000555a:	b7 f2 81 2c 	insert %d2,%d2,15,25,1
8000555e:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxAsclin_enableTxFifoFillLevelFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.TFLE = enable ? 1 : 0;
80005560:	19 f2 00 10 	ld.w %d2,[%a15]64
80005564:	b7 f2 81 2f 	insert %d2,%d2,15,31,1
80005568:	59 f2 00 10 	st.w [%a15]64,%d2
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
8000556c:	54 22       	ld.w %d2,[%a2]
8000556e:	b7 f2 01 25 	insert %d2,%d2,15,10,1
80005572:	74 22       	st.w [%a2],%d2
        IfxSrc_init(src, tos, config->interrupt.txPriority);
        IfxAsclin_enableTxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if (config->interrupt.erPriority > 0) /*These interrupts are not serviced by dma*/
80005574:	b9 c2 20 00 	ld.hu %d2,[%a12]32
80005578:	df 02 1e 00 	jeq %d2,0,800055b4 <IfxAsclin_Asc_initModule+0x392>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerEr(asclinSFR);
8000557c:	40 f4       	mov.aa %a4,%a15
8000557e:	6d ff 55 fb 	call 80004c28 <IfxAsclin_getSrcPointerEr>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80005582:	54 22       	ld.w %d2,[%a2]
80005584:	39 c3 20 00 	ld.bu %d3,[%a12]32
80005588:	8f f2 cf 21 	andn %d2,%d2,255
8000558c:	a6 32       	or %d2,%d3
8000558e:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80005590:	54 22       	ld.w %d2,[%a2]
80005592:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
80005596:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80005598:	4c 20       	ld.w %d15,[%a2]0
8000559a:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
8000559e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
800055a0:	19 ff 00 10 	ld.w %d15,[%a15]64
800055a4:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
800055a8:	59 ff 00 10 	st.w [%a15]64,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
800055ac:	4c 20       	ld.w %d15,[%a2]0
800055ae:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
800055b2:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxAsclin_enableRxFifoInlet(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->RXFIFOCON.B.ENI = enable ? 1 : 0;
800055b4:	4c f4       	ld.w %d15,[%a15]16

    IfxAsclin_flushRxFifo(asclinSFR);              // flushing Rx FIFO
    IfxAsclin_flushTxFifo(asclinSFR);              // flushing Tx FIFO

    return status;
}
800055b6:	02 92       	mov %d2,%d9
800055b8:	96 02       	or %d15,2
800055ba:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_enableTxFifoOutlet(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->TXFIFOCON.B.ENO = enable ? 1 : 0;
800055bc:	4c f3       	ld.w %d15,[%a15]12
800055be:	96 02       	or %d15,2
800055c0:	68 3f       	st.w [%a15]12,%d15
}


IFX_INLINE void IfxAsclin_flushRxFifo(Ifx_ASCLIN *asclin)
{
    asclin->RXFIFOCON.B.FLUSH = 1;
800055c2:	4c f4       	ld.w %d15,[%a15]16
800055c4:	96 01       	or %d15,1
800055c6:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_flushTxFifo(Ifx_ASCLIN *asclin)
{
    asclin->TXFIFOCON.B.FLUSH = 1;
800055c8:	4c f3       	ld.w %d15,[%a15]12
800055ca:	96 01       	or %d15,1
800055cc:	68 3f       	st.w [%a15]12,%d15
800055ce:	00 90       	ret 

800055d0 <IfxAsclin_Asc_initModuleConfig>:

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
800055d0:	82 12       	mov %d2,1
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
800055d2:	7b 10 7e 34 	movh %d3,18401

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
800055d6:	e9 42 28 00 	st.b [%a4]40,%d2
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
800055da:	82 12       	mov %d2,1
void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
800055dc:	82 0f       	mov %d15,0

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
800055de:	f9 42 08 00 	st.h [%a4]8,%d2
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
800055e2:	59 43 04 00 	st.w [%a4]4,%d3
    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
800055e6:	e9 42 0f 00 	st.b [%a4]15,%d2

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
800055ea:	82 33       	mov %d3,3
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
800055ec:	e9 42 10 00 	st.b [%a4]16,%d2
    config->frame.parityBit               = FALSE;                             /* disable parity*/
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
800055f0:	e9 42 16 00 	st.b [%a4]22,%d2
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
800055f4:	e9 42 17 00 	st.b [%a4]23,%d2
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
800055f8:	82 f2       	mov %d2,-1
void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
800055fa:	e9 4f 38 00 	st.b [%a4]56,%d15

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
800055fe:	e9 43 0a 00 	st.b [%a4]10,%d3

    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
80005602:	2c 4c       	st.b [%a4]12,%d15
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
80005604:	e9 43 0d 00 	st.b [%a4]13,%d3
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
80005608:	2c 4e       	st.b [%a4]14,%d15
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
8000560a:	e9 4f 11 00 	st.b [%a4]17,%d15
    config->frame.parityBit               = FALSE;                             /* disable parity*/
8000560e:	e9 4f 14 00 	st.b [%a4]20,%d15
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
80005612:	e9 4f 12 00 	st.b [%a4]18,%d15
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
80005616:	82 73       	mov %d3,7

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
80005618:	e9 4f 18 00 	st.b [%a4]24,%d15
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
8000561c:	e9 4f 19 00 	st.b [%a4]25,%d15
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/
80005620:	e9 4f 1a 00 	st.b [%a4]26,%d15
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
80005624:	e9 42 29 00 	st.b [%a4]41,%d2
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
80005628:	82 0f       	mov %d15,0

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/

    /* init pointers */
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
8000562a:	82 02       	mov %d2,0
}


void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;
8000562c:	f4 45       	st.a [%a4],%a5
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
    config->frame.parityBit               = FALSE;                             /* disable parity*/
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
8000562e:	e9 43 13 00 	st.b [%a4]19,%d3
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
80005632:	ac 4f       	st.h [%a4]30,%d15
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
80005634:	ac 4e       	st.h [%a4]28,%d15
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
80005636:	f9 4f 20 00 	st.h [%a4]32,%d15
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/
8000563a:	e9 4f 22 00 	st.b [%a4]34,%d15

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/

    /* init pointers */
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
8000563e:	59 42 24 00 	st.w [%a4]36,%d2
    config->rxBuffer       = NULL_PTR;                                         /* Rx Fifo buffer*/
80005642:	59 42 34 00 	st.w [%a4]52,%d2
    config->txBuffer       = NULL_PTR;                                         /* Tx Fifo buffer*/
80005646:	59 42 2c 00 	st.w [%a4]44,%d2

    config->txBufferSize   = 0;                                                /* Rx Fifo buffer size*/
8000564a:	f9 42 2a 00 	st.h [%a4]42,%d2
    config->rxBufferSize   = 0;                                                /* Rx Fifo buffer size*/
8000564e:	f9 42 30 00 	st.h [%a4]48,%d2

    config->dataBufferMode = Ifx_DataBufferMode_normal;
80005652:	e9 4f 39 00 	st.b [%a4]57,%d15
80005656:	00 90       	ret 

80005658 <IfxAsclin_Asc_initiateTransmission>:
}

#include <stdio.h>
void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
80005658:	0c 4c       	ld.bu %d15,[%a4]12
    config->dataBufferMode = Ifx_DataBufferMode_normal;
}

#include <stdio.h>
void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
8000565a:	20 10       	sub.a %sp,16
8000565c:	40 4f       	mov.aa %a15,%a4
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
8000565e:	ee 20       	jnz %d15,8000569e <IfxAsclin_Asc_initiateTransmission+0x46>
    {

        if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
80005660:	99 44 04 00 	ld.a %a4,[%a4]4
80005664:	8c 42       	ld.h %d15,[%a4]4
80005666:	6e 1c       	jz %d15,8000569e <IfxAsclin_Asc_initiateTransmission+0x46>
        {
            uint8 data;

            asclin->txInProgress = TRUE;
80005668:	82 1f       	mov %d15,1
8000566a:	28 cf       	st.b [%a15]12,%d15

            switch (asclin->dataBufferMode)
8000566c:	0c ff       	ld.bu %d15,[%a15]15
8000566e:	6e 0c       	jz %d15,80005686 <IfxAsclin_Asc_initiateTransmission+0x2e>
80005670:	de 11       	jne %d15,1,80005692 <IfxAsclin_Asc_initiateTransmission+0x3a>
            break;
            case Ifx_DataBufferMode_timeStampSingle:
            {

                Ifx_DataBufferMode_TimeStampSingle packedData;
                Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
80005672:	d2 06       	mov %e6,0
80005674:	d9 a5 04 00 	lea %a5,[%sp]4
80005678:	3b c0 00 40 	mov %d4,12
8000567c:	6d 00 f0 15 	call 8000825c <Ifx_Fifo_read>
                data = packedData.data;
80005680:	0c ac       	ld.bu %d15,[%sp]12
80005682:	2c a3       	st.b [%sp]3,%d15
80005684:	3c 07       	j 80005692 <IfxAsclin_Asc_initiateTransmission+0x3a>
            switch (asclin->dataBufferMode)
            {
            case Ifx_DataBufferMode_normal: // here
            {

                Ifx_Fifo_read(asclin->tx, &data, 1, TIME_NULL);
80005686:	d2 06       	mov %e6,0
80005688:	d9 a5 03 00 	lea %a5,[%sp]3
8000568c:	82 14       	mov %d4,1
8000568e:	6d 00 e7 15 	call 8000825c <Ifx_Fifo_read>
                data = packedData.data;
            }
            break;
            }

            IfxAsclin_write8(asclin->asclin, &data, 1);
80005692:	c8 04       	ld.a %a4,[%a15]0
80005694:	d9 a5 03 00 	lea %a5,[%sp]3
80005698:	82 14       	mov %d4,1
8000569a:	6d ff 34 fc 	call 80004f02 <IfxAsclin_write8>
8000569e:	00 90       	ret 

800056a0 <IfxAsclin_Asc_write>:
    return TRUE;
}

#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800056a0:	40 4f       	mov.aa %a15,%a4

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
800056a2:	0c 4c       	ld.bu %d15,[%a4]12
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
800056a4:	99 44 04 00 	ld.a %a4,[%a4]4

    if (*count != 0)
800056a8:	94 63       	ld.h %d3,[%a6]
    return TRUE;
}

#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800056aa:	0b 45 10 88 	mov %e8,%d5,%d4
800056ae:	40 5d       	mov.aa %a13,%a5

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
800056b0:	c9 44 18 00 	ld.h %d4,[%a4]24
#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{

    Ifx_SizeT left;
    boolean   result       = TRUE;
800056b4:	82 12       	mov %d2,1
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;

    if (*count != 0)
800056b6:	df 03 25 00 	jeq %d3,0,80005700 <IfxAsclin_Asc_write+0x60>
800056ba:	40 6c       	mov.aa %a12,%a6
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
800056bc:	ee 13       	jnz %d15,800056e2 <IfxAsclin_Asc_write+0x42>
{

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
800056be:	37 04 70 f0 	extr.u %d15,%d4,0,16

    if (*count != 0)
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
800056c2:	7f 3f 10 00 	jge %d15,%d3,800056e2 <IfxAsclin_Asc_write+0x42>
        {


            Ifx_Fifo_write(asclin->tx, data, tx_fifo_size, timeout); /*Fill upto the S/W FIFO size and initiate transmission*/
800056c6:	0b 89 10 68 	mov %e6,%d9,%d8
800056ca:	6d 00 17 17 	call 800084f8 <Ifx_Fifo_write>
            IfxAsclin_Asc_initiateTransmission(asclin);
800056ce:	40 f4       	mov.aa %a4,%a15
800056d0:	6d ff c4 ff 	call 80005658 <IfxAsclin_Asc_initiateTransmission>

            left = Ifx_Fifo_write(asclin->tx, (((const uint8 *)data) + tx_fifo_size), (*count) - tx_fifo_size, timeout);
800056d4:	94 c4       	ld.h %d4,[%a12]
800056d6:	c8 14       	ld.a %a4,[%a15]4
800056d8:	a2 f4       	sub %d4,%d15
800056da:	10 d5       	addsc.a %a5,%a13,%d15,0
800056dc:	37 04 50 40 	extr %d4,%d4,0,16
800056e0:	3c 03       	j 800056e6 <IfxAsclin_Asc_write+0x46>

        else
        {


            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
800056e2:	40 d5       	mov.aa %a5,%a13
800056e4:	02 34       	mov %d4,%d3
800056e6:	0b 89 10 68 	mov %e6,%d9,%d8
800056ea:	6d 00 07 17 	call 800084f8 <Ifx_Fifo_write>

            IfxAsclin_Asc_initiateTransmission(asclin);
800056ee:	40 f4       	mov.aa %a4,%a15

        else
        {


            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
800056f0:	02 2f       	mov %d15,%d2

            IfxAsclin_Asc_initiateTransmission(asclin);
800056f2:	6d ff b3 ff 	call 80005658 <IfxAsclin_Asc_initiateTransmission>
        }

        *count -= left;
800056f6:	94 c2       	ld.h %d2,[%a12]
800056f8:	a2 f2       	sub %d2,%d15
800056fa:	b4 c2       	st.h [%a12],%d2
        result  = left == 0;
800056fc:	8b 0f 00 22 	eq %d2,%d15,0

    }

    return result;
}
80005700:	00 90       	ret 

80005702 <IfxAsclin_Asc_blockingWrite>:
    return data;
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
80005702:	20 10       	sub.a %sp,16
80005704:	e9 a4 07 00 	st.b [%sp]7,%d4
    Ifx_SizeT count = 1;

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
80005708:	82 f4       	mov %d4,-1
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
    Ifx_SizeT count = 1;
8000570a:	82 1f       	mov %d15,1

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
8000570c:	d9 a5 07 00 	lea %a5,[%sp]7
80005710:	d9 a6 0e 00 	lea %a6,[%sp]14
80005714:	9b 04 00 58 	addih %d5,%d4,32768
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
    Ifx_SizeT count = 1;
80005718:	ac a7       	st.h [%sp]14,%d15

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
}
8000571a:	1d ff c3 ff 	j 800056a0 <IfxAsclin_Asc_write>

8000571e <IfxAsclin_Asc_stdIfDPipeInit>:


boolean IfxAsclin_Asc_stdIfDPipeInit(IfxStdIf_DPipe *stdif, IfxAsclin_Asc *asclin)
{
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));
8000571e:	40 42       	mov.aa %a2,%a4
80005720:	82 0f       	mov %d15,0
80005722:	c5 0f 0b 10 	lea %a15,4b <_.+0x4a>
80005726:	24 2f       	st.b [%a2+],%d15
80005728:	fc ff       	loop %a15,80005726 <IfxAsclin_Asc_stdIfDPipeInit+0x8>

    /* Set the API link */
    stdif->driver         = asclin;
    stdif->write          = (IfxStdIf_DPipe_Write) & IfxAsclin_Asc_write;
8000572a:	7b 00 00 f8 	movh %d15,32768
8000572e:	1b 0f 6a f5 	addi %d15,%d15,22176
80005732:	6c 42       	st.w [%a4]8,%d15
    stdif->read           = (IfxStdIf_DPipe_Read) & IfxAsclin_Asc_read;
80005734:	7b 00 00 f8 	movh %d15,32768
80005738:	1b 0f 09 f5 	addi %d15,%d15,20624
8000573c:	6c 43       	st.w [%a4]12,%d15
    stdif->getReadCount   = (IfxStdIf_DPipe_GetReadCount) & IfxAsclin_Asc_getReadCount;
8000573e:	7b 00 00 f8 	movh %d15,32768
80005742:	1b 4f f1 f4 	addi %d15,%d15,20244
80005746:	6c 44       	st.w [%a4]16,%d15
    stdif->getReadEvent   = (IfxStdIf_DPipe_GetReadEvent) & IfxAsclin_Asc_getReadEvent;
80005748:	7b 00 00 f8 	movh %d15,32768
8000574c:	1b af f1 f4 	addi %d15,%d15,20250
80005750:	6c 45       	st.w [%a4]20,%d15
    stdif->getWriteCount  = (IfxStdIf_DPipe_GetWriteCount) & IfxAsclin_Asc_getWriteCount;
80005752:	7b 00 00 f8 	movh %d15,32768
80005756:	1b 0f f3 f4 	addi %d15,%d15,20272
8000575a:	6c 46       	st.w [%a4]24,%d15
    stdif->getWriteEvent  = (IfxStdIf_DPipe_GetWriteEvent) & IfxAsclin_Asc_getWriteEvent;
8000575c:	7b 00 00 f8 	movh %d15,32768
80005760:	1b ef f3 f4 	addi %d15,%d15,20286
80005764:	6c 47       	st.w [%a4]28,%d15
    stdif->canReadCount   = (IfxStdIf_DPipe_CanReadCount) & IfxAsclin_Asc_canReadCount;
80005766:	7b 00 00 f8 	movh %d15,32768
8000576a:	1b 0f fc f4 	addi %d15,%d15,20416
8000576e:	6c 48       	st.w [%a4]32,%d15
    stdif->canWriteCount  = (IfxStdIf_DPipe_CanWriteCount) & IfxAsclin_Asc_canWriteCount;
80005770:	7b 00 00 f8 	movh %d15,32768
80005774:	1b 4f 06 f5 	addi %d15,%d15,20580
80005778:	6c 49       	st.w [%a4]36,%d15
    stdif->flushTx        = (IfxStdIf_DPipe_FlushTx) & IfxAsclin_Asc_flushTx;
8000577a:	7b 00 00 f8 	movh %d15,32768
8000577e:	1b 8f fc f4 	addi %d15,%d15,20424
80005782:	6c 4a       	st.w [%a4]40,%d15
    stdif->clearTx        = (IfxStdIf_DPipe_ClearTx) & IfxAsclin_Asc_clearTx;
80005784:	7b 00 00 f8 	movh %d15,32768
80005788:	1b cf 07 f5 	addi %d15,%d15,20604
8000578c:	6c 4b       	st.w [%a4]44,%d15
    stdif->clearRx        = (IfxStdIf_DPipe_ClearRx) & IfxAsclin_Asc_clearRx;
8000578e:	7b 00 00 f8 	movh %d15,32768
80005792:	1b cf 06 f5 	addi %d15,%d15,20588
80005796:	6c 4c       	st.w [%a4]48,%d15
    stdif->onReceive      = (IfxStdIf_DPipe_OnReceive) & IfxAsclin_Asc_isrReceive;
80005798:	7b 00 00 f8 	movh %d15,32768
8000579c:	1b af 14 f5 	addi %d15,%d15,20810
800057a0:	6c 4d       	st.w [%a4]52,%d15
    stdif->onTransmit     = (IfxStdIf_DPipe_OnTransmit) & IfxAsclin_Asc_isrTransmit;
800057a2:	7b 00 00 f8 	movh %d15,32768
800057a6:	1b cf 0a f5 	addi %d15,%d15,20652
800057aa:	6c 4e       	st.w [%a4]56,%d15
    stdif->onError        = (IfxStdIf_DPipe_OnError) & IfxAsclin_Asc_isrError;
800057ac:	7b 00 00 f8 	movh %d15,32768
800057b0:	1b 8f f4 f4 	addi %d15,%d15,20296
800057b4:	6c 4f       	st.w [%a4]60,%d15
    stdif->getSendCount   = (IfxStdIf_DPipe_GetSendCount) & IfxAsclin_Asc_getSendCount;
800057b6:	7b 00 00 f8 	movh %d15,32768
800057ba:	1b 4f f2 f4 	addi %d15,%d15,20260
800057be:	59 4f 00 10 	st.w [%a4]64,%d15
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) & IfxAsclin_Asc_getTxTimeStamp;
800057c2:	7b 00 00 f8 	movh %d15,32768
800057c6:	1b af f2 f4 	addi %d15,%d15,20266
800057ca:	59 4f 04 10 	st.w [%a4]68,%d15
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) & IfxAsclin_Asc_resetSendCount;
800057ce:	7b 00 00 f8 	movh %d15,32768
800057d2:	1b af fb f4 	addi %d15,%d15,20410
800057d6:	59 4f 08 10 	st.w [%a4]72,%d15
    stdif->txDisabled     = FALSE;
800057da:	82 0f       	mov %d15,0
{
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));

    /* Set the API link */
    stdif->driver         = asclin;
800057dc:	f4 45       	st.a [%a4],%a5
    stdif->onTransmit     = (IfxStdIf_DPipe_OnTransmit) & IfxAsclin_Asc_isrTransmit;
    stdif->onError        = (IfxStdIf_DPipe_OnError) & IfxAsclin_Asc_isrError;
    stdif->getSendCount   = (IfxStdIf_DPipe_GetSendCount) & IfxAsclin_Asc_getSendCount;
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) & IfxAsclin_Asc_getTxTimeStamp;
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) & IfxAsclin_Asc_resetSendCount;
    stdif->txDisabled     = FALSE;
800057de:	2c 44       	st.b [%a4]4,%d15
    return TRUE;
}
800057e0:	82 12       	mov %d2,1
800057e2:	00 90       	ret 

800057e4 <IfxPort_getAddress>:
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
800057e4:	91 00 00 28 	movh.a %a2,32768
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
800057e8:	82 05       	mov %d5,0
}


Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
800057ea:	82 02       	mov %d2,0
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
800057ec:	d9 22 ac 50 	lea %a2,[%a2]2412 <8000096c <IfxPort_cfg_indexMap>>
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
800057f0:	8f f5 0f f1 	and %d15,%d5,255
800057f4:	8b 02 00 32 	eq %d3,%d2,0
800057f8:	8b 0f 61 34 	and.lt.u %d3,%d15,16
800057fc:	76 3a       	jz %d3,80005810 <IfxPort_getAddress+0x2c>
800057fe:	02 5f       	mov %d15,%d5
80005800:	16 ff       	and %d15,255
    {
        if (IfxPort_cfg_indexMap[i].index == port)
80005802:	d0 2f       	addsc.a %a15,%a2,%d15,3
80005804:	82 02       	mov %d2,0
80005806:	4c f1       	ld.w %d15,[%a15]4
80005808:	7e 42       	jne %d15,%d4,8000580c <IfxPort_getAddress+0x28>
        {
            module = IfxPort_cfg_indexMap[i].module;
8000580a:	48 02       	ld.w %d2,[%a15]0
8000580c:	c2 15       	add %d5,1
8000580e:	3c f1       	j 800057f0 <IfxPort_getAddress+0xc>

        i++;
    }

    return module;
}
80005810:	60 22       	mov.a %a2,%d2
80005812:	00 90       	ret 

80005814 <IfxPort_getIndex>:

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
    {
        if (IfxPort_cfg_indexMap[index].module == port)
80005814:	91 00 00 38 	movh.a %a3,32768
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80005818:	82 0f       	mov %d15,0
    {
        if (IfxPort_cfg_indexMap[index].module == port)
8000581a:	d9 33 ac 50 	lea %a3,[%a3]2412 <8000096c <IfxPort_cfg_indexMap>>
8000581e:	a0 ff       	mov.a %a15,15
80005820:	d0 32       	addsc.a %a2,%a3,%d15,3
80005822:	d4 25       	ld.a %a5,[%a2]
80005824:	7d 45 05 80 	jne.a %a5,%a4,8000582e <IfxPort_getIndex+0x1a>
        {
            result = (IfxPort_Index)IfxPort_cfg_indexMap[index].index;
80005828:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
8000582c:	00 90       	ret 
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
8000582e:	c2 1f       	add %d15,1
80005830:	fc f8       	loop %a15,80005820 <IfxPort_getIndex+0xc>
IfxPort_Index IfxPort_getIndex(Ifx_P *port)
{
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;
80005832:	82 f2       	mov %d2,-1
            break;
        }
    }

    return result;
}
80005834:	00 90       	ret 

80005836 <IfxPort_resetESR>:


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
80005836:	40 4f       	mov.aa %a15,%a4
80005838:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000583a:	6d 00 ac 0c 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
8000583e:	02 24       	mov %d4,%d2
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005840:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005842:	6d 00 a8 0b 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 0);
80005846:	82 12       	mov %d2,1
80005848:	d9 f4 10 10 	lea %a4,[%a15]80
8000584c:	0f 82 00 20 	sh %d2,%d2,%d8

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005850:	d2 06       	mov %e6,0
80005852:	02 27       	mov %d7,%d2
80005854:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
80005858:	02 f4       	mov %d4,%d15
8000585a:	1d 00 d1 0c 	j 800071fc <IfxScuWdt_setCpuEndinit>

8000585e <IfxPort_disableEmergencyStop>:
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
8000585e:	91 00 00 38 	movh.a %a3,32768
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005862:	82 0f       	mov %d15,0
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005864:	d9 33 ac 70 	lea %a3,[%a3]2540 <800009ec <IfxPort_cfg_esrMasks>>
80005868:	a0 ff       	mov.a %a15,15
8000586a:	d0 32       	addsc.a %a2,%a3,%d15,3
8000586c:	d4 25       	ld.a %a5,[%a2]
8000586e:	7d 54 0c 80 	jne.a %a4,%a5,80005886 <IfxPort_disableEmergencyStop+0x28>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80005872:	b9 2f 04 00 	ld.hu %d15,[%a2]4
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
80005876:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80005878:	57 0f 61 f4 	extr.u %d15,%d15,%d4,1
8000587c:	6e 08       	jz %d15,8000588c <IfxPort_disableEmergencyStop+0x2e>
            {
                IfxPort_resetESR(port, pinIndex);
8000587e:	6d ff dc ff 	call 80005836 <IfxPort_resetESR>
                result = TRUE;
80005882:	82 12       	mov %d2,1
80005884:	00 90       	ret 
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005886:	c2 1f       	add %d15,1
80005888:	fc f1       	loop %a15,8000586a <IfxPort_disableEmergencyStop+0xc>
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
8000588a:	82 02       	mov %d2,0
            break;
        }
    }

    return result;
}
8000588c:	00 90       	ret 

8000588e <IfxPort_setESR>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
8000588e:	40 4f       	mov.aa %a15,%a4
80005890:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005892:	6d 00 80 0c 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005896:	02 24       	mov %d4,%d2
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005898:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
8000589a:	6d 00 7c 0b 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
8000589e:	82 12       	mov %d2,1
800058a0:	0f 82 00 20 	sh %d2,%d2,%d8
800058a4:	d9 f4 10 10 	lea %a4,[%a15]80
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
800058a8:	53 12 40 60 	mul.u %e6,%d2,1

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
800058ac:	02 27       	mov %d7,%d2
800058ae:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
800058b2:	02 f4       	mov %d4,%d15
800058b4:	1d 00 a4 0c 	j 800071fc <IfxScuWdt_setCpuEndinit>

800058b8 <IfxPort_enableEmergencyStop>:
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
800058b8:	82 19       	mov %d9,1
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
800058ba:	91 00 00 d8 	movh.a %a13,32768
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
800058be:	40 4c       	mov.aa %a12,%a4
800058c0:	02 48       	mov %d8,%d4
800058c2:	0f 49 00 90 	sh %d9,%d9,%d4
    sint32  portIndex;
    boolean result = FALSE;
800058c6:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800058c8:	82 0f       	mov %d15,0
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
800058ca:	d9 dd ac 70 	lea %a13,[%a13]2540 <800009ec <IfxPort_cfg_esrMasks>>
800058ce:	d0 df       	addsc.a %a15,%a13,%d15,3
800058d0:	c8 02       	ld.a %a2,[%a15]0
800058d2:	7d 2c 0b 80 	jne.a %a12,%a2,800058e8 <IfxPort_enableEmergencyStop+0x30>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
800058d6:	b9 f3 04 00 	ld.hu %d3,[%a15]4
800058da:	26 93       	and %d3,%d9
800058dc:	76 36       	jz %d3,800058e8 <IfxPort_enableEmergencyStop+0x30>
            {
                IfxPort_setESR(port, pinIndex);
800058de:	40 c4       	mov.aa %a4,%a12
800058e0:	02 84       	mov %d4,%d8
800058e2:	6d ff d6 ff 	call 8000588e <IfxPort_setESR>
                result = TRUE;
800058e6:	82 12       	mov %d2,1
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800058e8:	c2 1f       	add %d15,1
800058ea:	8b 0f 21 32 	ne %d3,%d15,16
800058ee:	df 03 f0 ff 	jne %d3,0,800058ce <IfxPort_enableEmergencyStop+0x16>
            }
        }
    }

    return result;
}
800058f2:	00 90       	ret 

800058f4 <IfxPort_setGroupModeInput>:
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800058f4:	82 0f       	mov %d15,0
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setGroupModeInput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_InputMode mode)
{
800058f6:	20 20       	sub.a %sp,32
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800058f8:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
800058fa:	78 04       	st.w [%sp]16,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800058fc:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
800058fe:	78 05       	st.w [%sp]20,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005900:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80005902:	78 06       	st.w [%sp]24,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005904:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80005906:	78 07       	st.w [%sp]28,%d15
80005908:	8b 14 a1 22 	ge.u %d2,%d4,17
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
8000590c:	8b 04 01 f1 	rsub %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
80005910:	0f 45 00 50 	sh %d5,%d5,%d4
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005914:	3b 80 0f 70 	mov %d7,248
80005918:	ab 0f a0 f2 	seln %d15,%d2,%d15,0
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
8000591c:	9f 0f 07 80 	jned %d15,0,8000592a <IfxPort_setGroupModeInput+0x36>
80005920:	d9 44 10 00 	lea %a4,[%a4]16
80005924:	82 0f       	mov %d15,0
80005926:	a0 3f       	mov.a %a15,3
80005928:	3c 1e       	j 80005964 <IfxPort_setGroupModeInput+0x70>
    {
        if ((imask & (1U << i)) != 0)
8000592a:	57 05 61 24 	extr.u %d2,%d5,%d4,1
8000592e:	df 02 19 00 	jeq %d2,0,80005960 <IfxPort_setGroupModeInput+0x6c>
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005932:	8f 34 c0 31 	andn %d3,%d4,3
80005936:	60 32       	mov.a %a2,%d3
80005938:	d9 af 20 00 	lea %a15,[%sp]32
8000593c:	30 2f       	add.a %a15,%a2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
8000593e:	8f 34 00 21 	and %d2,%d4,3
80005942:	06 32       	sh %d2,3
            iocrMask[index] |= (0x1FU << 3) << shift;
80005944:	19 f0 f0 ff 	ld.w %d0,[%a15]-16
80005948:	0f 27 00 30 	sh %d3,%d7,%d2
8000594c:	a6 03       	or %d3,%d0
8000594e:	59 f3 f0 ff 	st.w [%a15]-16,%d3
            iocrVal[index]  |= (mode) << shift;
80005952:	19 f3 e0 ff 	ld.w %d3,[%a15]-32
80005956:	0f 26 00 20 	sh %d2,%d6,%d2
8000595a:	a6 32       	or %d2,%d3
8000595c:	59 f2 e0 ff 	st.w [%a15]-32,%d2
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005960:	c2 14       	add %d4,1
80005962:	3c dd       	j 8000591c <IfxPort_setGroupModeInput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80005964:	d9 a3 20 00 	lea %a3,[%sp]32
80005968:	90 32       	addsc.a %a2,%a3,%d15,2
8000596a:	19 24 f0 ff 	ld.w %d4,[%a2]-16
8000596e:	76 47       	jz %d4,8000597c <IfxPort_setGroupModeInput+0x88>
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005970:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80005974:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005976:	02 43       	mov %d3,%d4
80005978:	49 42 40 08 	ldmst [%a4]0,%e2
            iocrVal[index]  |= (mode) << shift;
        }
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
8000597c:	c2 1f       	add %d15,1
8000597e:	b0 44       	add.a %a4,4
80005980:	fc f2       	loop %a15,80005964 <IfxPort_setGroupModeInput+0x70>
        if (iocrMask[i] != 0)
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
        }
    }
}
80005982:	00 90       	ret 

80005984 <IfxPort_setGroupModeOutput>:
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005984:	82 0f       	mov %d15,0
    }
}


void IfxPort_setGroupModeOutput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
80005986:	20 20       	sub.a %sp,32
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005988:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
8000598a:	78 04       	st.w [%sp]16,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
8000598c:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
8000598e:	78 05       	st.w [%sp]20,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005990:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
80005992:	78 06       	st.w [%sp]24,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005994:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80005996:	78 07       	st.w [%sp]28,%d15
80005998:	8b 14 a1 22 	ge.u %d2,%d4,17
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
8000599c:	8b 04 01 f1 	rsub %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
800059a0:	0f 45 00 50 	sh %d5,%d5,%d4
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
800059a4:	3b 80 0f 00 	mov %d0,248
800059a8:	ab 0f a0 f2 	seln %d15,%d2,%d15,0
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
800059ac:	9f 0f 07 80 	jned %d15,0,800059ba <IfxPort_setGroupModeOutput+0x36>
800059b0:	d9 44 10 00 	lea %a4,[%a4]16
800059b4:	82 0f       	mov %d15,0
800059b6:	a0 3f       	mov.a %a15,3
800059b8:	3c 1f       	j 800059f6 <IfxPort_setGroupModeOutput+0x72>
    {
        if ((imask & (1U << i)) != 0)
800059ba:	57 05 61 24 	extr.u %d2,%d5,%d4,1
800059be:	df 02 1a 00 	jeq %d2,0,800059f2 <IfxPort_setGroupModeOutput+0x6e>
        {
            uint32 index = i / 4;
800059c2:	8f e4 1f 30 	sh %d3,%d4,-2
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
800059c6:	d9 a2 20 00 	lea %a2,[%sp]32
800059ca:	01 23 02 f6 	addsc.a %a15,%a2,%d3,2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
800059ce:	8f 34 00 21 	and %d2,%d4,3
800059d2:	06 32       	sh %d2,3
            iocrMask[index] |= (0x1FU << 3) << shift;
            iocrVal[index]  |= (mode | index) << shift;
800059d4:	a6 63       	or %d3,%d6
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
800059d6:	0f 20 00 70 	sh %d7,%d0,%d2
800059da:	19 f1 f0 ff 	ld.w %d1,[%a15]-16
            iocrVal[index]  |= (mode | index) << shift;
800059de:	0f 23 00 20 	sh %d2,%d3,%d2
800059e2:	19 f3 e0 ff 	ld.w %d3,[%a15]-32
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
800059e6:	a6 17       	or %d7,%d1
            iocrVal[index]  |= (mode | index) << shift;
800059e8:	a6 32       	or %d2,%d3
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
800059ea:	59 f7 f0 ff 	st.w [%a15]-16,%d7
            iocrVal[index]  |= (mode | index) << shift;
800059ee:	59 f2 e0 ff 	st.w [%a15]-32,%d2
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
800059f2:	c2 14       	add %d4,1
800059f4:	3c dc       	j 800059ac <IfxPort_setGroupModeOutput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
800059f6:	d9 a3 20 00 	lea %a3,[%sp]32
800059fa:	90 32       	addsc.a %a2,%a3,%d15,2
800059fc:	19 24 f0 ff 	ld.w %d4,[%a2]-16
80005a00:	76 47       	jz %d4,80005a0e <IfxPort_setGroupModeOutput+0x8a>
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005a02:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80005a06:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005a08:	02 43       	mov %d3,%d4
80005a0a:	49 42 40 08 	ldmst [%a4]0,%e2
            iocrVal[index]  |= (mode | index) << shift;
        }
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
80005a0e:	c2 1f       	add %d15,1
80005a10:	b0 44       	add.a %a4,4
80005a12:	fc f2       	loop %a15,800059f6 <IfxPort_setGroupModeOutput+0x72>
        if (iocrMask[i] != 0)
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
        }
    }
}
80005a14:	00 90       	ret 

80005a16 <IfxPort_setGroupPadDriver>:


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
80005a16:	20 10       	sub.a %sp,16
80005a18:	02 4f       	mov %d15,%d4
80005a1a:	02 5a       	mov %d10,%d5
80005a1c:	40 4c       	mov.aa %a12,%a4
80005a1e:	02 69       	mov %d9,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005a20:	6d 00 b9 0b 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005a24:	02 24       	mov %d4,%d2
}


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005a26:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005a28:	6d 00 b5 0a 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80005a2c:	82 03       	mov %d3,0
80005a2e:	74 a3       	st.w [%sp],%d3
            pdrMask[i] = 0;
80005a30:	59 a3 08 00 	st.w [%sp]8,%d3
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80005a34:	59 a3 04 00 	st.w [%sp]4,%d3
            pdrMask[i] = 0;
80005a38:	59 a3 0c 00 	st.w [%sp]12,%d3
80005a3c:	8b 1f a1 22 	ge.u %d2,%d15,17
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005a40:	8b 0f 01 31 	rsub %d3,%d15,16
            pdrVal[i]  = 0;
            pdrMask[i] = 0;
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;
80005a44:	0f fa 00 50 	sh %d5,%d10,%d15
80005a48:	ab 03 a0 32 	seln %d3,%d2,%d3,0

        for (i = pinIndex; i < 16; i++)
80005a4c:	9f 03 03 80 	jned %d3,0,80005a52 <IfxPort_setGroupPadDriver+0x3c>
80005a50:	3c 1d       	j 80005a8a <IfxPort_setGroupPadDriver+0x74>
        {
            if ((imask & (1U << i)) != 0)
80005a52:	57 05 61 2f 	extr.u %d2,%d5,%d15,1
80005a56:	df 02 18 00 	jeq %d2,0,80005a86 <IfxPort_setGroupPadDriver+0x70>
            {
                uint32 index = i / 8;
80005a5a:	8f df 1f 40 	sh %d4,%d15,-3
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005a5e:	d9 a2 10 00 	lea %a2,[%sp]16
80005a62:	01 24 02 f6 	addsc.a %a15,%a2,%d4,2
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80005a66:	8f 7f 00 21 	and %d2,%d15,7
                pdrMask[index] |= (0xFUL << shift);
80005a6a:	19 f4 f8 ff 	ld.w %d4,[%a15]-8
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80005a6e:	06 22       	sh %d2,2
                pdrMask[index] |= (0xFUL << shift);
80005a70:	d7 f4 04 42 	insert %d4,%d4,15,%d2,4
                pdrVal[index]  |= (padDriver << shift);
80005a74:	0f 29 00 20 	sh %d2,%d9,%d2
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005a78:	59 f4 f8 ff 	st.w [%a15]-8,%d4
                pdrVal[index]  |= (padDriver << shift);
80005a7c:	19 f4 f0 ff 	ld.w %d4,[%a15]-16
80005a80:	a6 42       	or %d2,%d4
80005a82:	59 f2 f0 ff 	st.w [%a15]-16,%d2
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
80005a86:	c2 1f       	add %d15,1
80005a88:	3c e2       	j 80005a4c <IfxPort_setGroupPadDriver+0x36>
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80005a8a:	58 02       	ld.w %d15,[%sp]8
80005a8c:	6e 08       	jz %d15,80005a9c <IfxPort_setGroupPadDriver+0x86>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80005a8e:	d9 cf 00 10 	lea %a15,[%a12]64
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005a92:	54 a6       	ld.w %d6,[%sp]
80005a94:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005a96:	02 f7       	mov %d7,%d15
80005a98:	49 f6 40 08 	ldmst [%a15]0,%e6
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80005a9c:	58 03       	ld.w %d15,[%sp]12
80005a9e:	6e 09       	jz %d15,80005ab0 <IfxPort_setGroupPadDriver+0x9a>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80005aa0:	d9 cc 04 10 	lea %a12,[%a12]68
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005aa4:	19 a6 04 00 	ld.w %d6,[%sp]4
80005aa8:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005aaa:	02 f7       	mov %d7,%d15
80005aac:	49 c6 40 08 	ldmst [%a12]0,%e6
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005ab0:	02 84       	mov %d4,%d8
}
80005ab2:	d9 aa 10 00 	lea %sp,[%sp]16
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005ab6:	1d 00 a3 0b 	j 800071fc <IfxScuWdt_setCpuEndinit>

80005aba <IfxPort_setPinMode>:
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
80005aba:	91 40 00 2f 	movh.a %a2,61444

void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80005abe:	8f 34 00 91 	and %d9,%d4,3

    if (port == &MODULE_P40)
80005ac2:	d9 22 00 0e 	lea %a2,[%a2]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
80005ac6:	40 4f       	mov.aa %a15,%a4
80005ac8:	02 4f       	mov %d15,%d4
80005aca:	02 5a       	mov %d10,%d5
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
80005acc:	d9 4c 10 00 	lea %a12,[%a4]16
    uint8                 iocrIndex = (pinIndex / 4);
80005ad0:	8f e4 1f b0 	sh %d11,%d4,-2
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80005ad4:	06 39       	sh %d9,3

    if (port == &MODULE_P40)
80005ad6:	7d 24 11 80 	jne.a %a4,%a2,80005af8 <IfxPort_setPinMode+0x3e>
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005ada:	6d 00 5c 0b 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
80005ade:	02 24       	mov %d4,%d2
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005ae0:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80005ae2:	6d 00 58 0a 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80005ae6:	19 f2 20 10 	ld.w %d2,[%a15]96
        IfxScuWdt_setCpuEndinit(passwd);
80005aea:	02 84       	mov %d4,%d8

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
80005aec:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80005af0:	59 ff 20 10 	st.w [%a15]96,%d15
        IfxScuWdt_setCpuEndinit(passwd);
80005af4:	6d 00 84 0b 	call 800071fc <IfxScuWdt_setCpuEndinit>
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80005af8:	da ff       	mov %d15,255
80005afa:	01 cb 02 f6 	addsc.a %a15,%a12,%d11,2
80005afe:	0f 9f 00 f0 	sh %d15,%d15,%d9
80005b02:	0f 9a 00 20 	sh %d2,%d10,%d9
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005b06:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005b08:	02 f3       	mov %d3,%d15
80005b0a:	49 f2 40 08 	ldmst [%a15]0,%e2
80005b0e:	00 90       	ret 

80005b10 <IfxPort_setPinModeLvdsHigh>:
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
80005b10:	02 5a       	mov %d10,%d5
80005b12:	40 4f       	mov.aa %a15,%a4
80005b14:	02 49       	mov %d9,%d4
80005b16:	02 6f       	mov %d15,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005b18:	6d 00 3d 0b 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005b1c:	02 24       	mov %d4,%d2
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005b1e:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005b20:	6d 00 39 0a 	call 80006f92 <IfxScuWdt_clearCpuEndinit>

    if (mode < IfxPort_Mode_outputPushPullGeneral)
80005b24:	37 0a 48 50 	extr %d5,%d10,0,8
80005b28:	bf 05 11 00 	jlt %d5,0,80005b4a <IfxPort_setPinModeLvdsHigh+0x3a>
    {
        if (pinIndex < 2)
80005b2c:	bf 29 21 80 	jlt.u %d9,2,80005b6e <IfxPort_setPinModeLvdsHigh+0x5e>
        {}
        else
        {
            port->LPCR1.B_P21.RDIS_CTRL = enablePortControlled;
80005b30:	19 f2 24 20 	ld.w %d2,[%a15]164
80005b34:	37 f2 01 f0 	insert %d15,%d2,%d15,0,1
80005b38:	59 ff 24 20 	st.w [%a15]164,%d15
            port->LPCR1.B_P21.RX_DIS    = 0;
80005b3c:	19 ff 24 20 	ld.w %d15,[%a15]164
80005b40:	8f 2f c0 f1 	andn %d15,%d15,2
80005b44:	59 ff 24 20 	st.w [%a15]164,%d15
80005b48:	3c 13       	j 80005b6e <IfxPort_setPinModeLvdsHigh+0x5e>
        }
    }
    else
    {
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
80005b4a:	19 f2 28 20 	ld.w %d2,[%a15]168
80005b4e:	67 f2 0c f0 	ins.t %d15,%d2,12,%d15,0
80005b52:	59 ff 28 20 	st.w [%a15]168,%d15
        port->LPCR2.B.TX_DIS    = 0;
80005b56:	19 ff 28 20 	ld.w %d15,[%a15]168
80005b5a:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80005b5e:	59 ff 28 20 	st.w [%a15]168,%d15
        port->LPCR2.B.TX_PD     = 0;
80005b62:	19 ff 28 20 	ld.w %d15,[%a15]168
80005b66:	b7 0f 01 f7 	insert %d15,%d15,0,14,1
80005b6a:	59 ff 28 20 	st.w [%a15]168,%d15
    }

    IfxScuWdt_setCpuEndinit(passwd);
80005b6e:	02 84       	mov %d4,%d8
80005b70:	1d 00 46 0b 	j 800071fc <IfxScuWdt_setCpuEndinit>

80005b74 <IfxPort_setPinModeLvdsMedium>:
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80005b74:	0b 65 10 a8 	mov %e10,%d5,%d6
80005b78:	40 4f       	mov.aa %a15,%a4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80005b7a:	8f f4 1f 90 	sh %d9,%d4,-1
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80005b7e:	02 48       	mov %d8,%d4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80005b80:	6d 00 09 0b 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005b84:	02 24       	mov %d4,%d2
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80005b86:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005b88:	6d 00 05 0a 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
80005b8c:	06 d8       	sh %d8,-3
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
80005b8e:	d9 f2 00 10 	lea %a2,[%a15]64
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80005b92:	01 28 02 26 	addsc.a %a2,%a2,%d8,2


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80005b96:	8f 39 00 20 	sh %d2,%d9,3
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
80005b9a:	d9 f4 20 20 	lea %a4,[%a15]160
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005b9e:	01 49 02 46 	addsc.a %a4,%a4,%d9,2
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80005ba2:	0f 2b 00 50 	sh %d5,%d11,%d2
80005ba6:	74 25       	st.w [%a2],%d5
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005ba8:	54 46       	ld.w %d6,[%a4]
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005baa:	02 f4       	mov %d4,%d15
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005bac:	67 a6 01 60 	ins.t %d6,%d6,1,%d10,0
80005bb0:	74 46       	st.w [%a4],%d6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005bb2:	1d 00 25 0b 	j 800071fc <IfxScuWdt_setCpuEndinit>

80005bb6 <IfxPort_setPinPadDriver>:
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
80005bb6:	0b 45 10 88 	mov %e8,%d5,%d4
80005bba:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005bbc:	6d 00 eb 0a 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005bc0:	02 24       	mov %d4,%d2
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005bc2:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005bc4:	6d 00 e7 09 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
80005bc8:	8f 78 00 21 	and %d2,%d8,7
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80005bcc:	06 22       	sh %d2,2
80005bce:	06 d8       	sh %d8,-3
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
80005bd0:	d9 ff 00 10 	lea %a15,[%a15]64
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80005bd4:	3b f0 00 30 	mov %d3,15
80005bd8:	01 f8 02 f6 	addsc.a %a15,%a15,%d8,2
80005bdc:	0f 23 00 30 	sh %d3,%d3,%d2
80005be0:	0f 29 00 60 	sh %d6,%d9,%d2
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005be4:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005be6:	02 37       	mov %d7,%d3
80005be8:	49 f6 40 08 	ldmst [%a15]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005bec:	02 f4       	mov %d4,%d15
80005bee:	1d 00 07 0b 	j 800071fc <IfxScuWdt_setCpuEndinit>
	...

80005bf4 <IfxScuCcu_calculateSysPllDividers>:
        //' K2+1 div should be even for 50% duty cycle
        k2Steps = 2;

        if (fPll > 240000000)
        {
            k2Steps = 1;
80005bf4:	7b e0 e4 30 	movh %d3,3662
80005bf8:	1b 13 c0 31 	addi %d3,%d3,7169
80005bfc:	0b 34 30 c1 	lt.u %d12,%d4,%d3
80005c00:	82 2f       	mov %d15,2
80005c02:	ab 1f 80 cc 	sel %d12,%d12,%d15,1
80005c06:	8f 4c 00 80 	sh %d8,%d12,4
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80005c0a:	7b c0 be 00 	movh %d0,3052

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005c0e:	91 40 0f 50 	movh.a %a5,244
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005c12:	7b 80 82 6e 	movh %d6,59432
80005c16:	91 80 7d 61 	movh.a %a6,6104

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
    uint8   deviationAllowed = 2;
    uint32  fOsc             = cfg->xtalFrequency;
80005c1a:	19 4e 10 10 	ld.w %d14,[%a4]80
80005c1e:	60 83       	mov.a %a3,%d8
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80005c20:	1b 00 20 0c 	addi %d0,%d0,-15872

        uint32       p;
        uint32       n;
        uint32       k2;
        uint32       k2Steps;
        uint32       bestK2 = 0, bestN = 0, bestP = 0;
80005c24:	d2 0a       	mov %e10,0
80005c26:	82 09       	mov %d9,0
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80005c28:	3b 00 01 50 	mov %d5,16
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005c2c:	d9 55 41 02 	lea %a5,[%a5]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005c30:	82 f7       	mov %d7,-1
80005c32:	1b 06 c0 67 	addi %d6,%d6,31744
80005c36:	d9 66 41 08 	lea %a6,[%a6]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
80005c3a:	a0 ff       	mov.a %a15,15
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80005c3c:	4b 5e 11 22 	div.u %e2,%d14,%d5

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005c40:	7b 60 f8 1f 	movh %d1,65414
80005c44:	1b 01 e0 1e 	addi %d1,%d1,-4608
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80005c48:	82 03       	mov %d3,0

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005c4a:	0b 12 40 10 	addx %d1,%d2,%d1
80005c4e:	8b f3 bf 20 	addc %d2,%d3,-1
80005c52:	80 53       	mov.d %d3,%a5
80005c54:	ba 02       	eq %d15,%d2,0
80005c56:	0b 31 50 f2 	and.ge.u %d15,%d1,%d3
80005c5a:	8b 02 00 f5 	or.ne %d15,%d2,0
80005c5e:	ee 24       	jnz %d15,80005ca6 <IfxScuCcu_calculateSysPllDividers+0xb2>
80005c60:	02 5d       	mov %d13,%d5
80005c62:	82 11       	mov %d1,1
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005c64:	03 41 68 26 	madd.u %e2,%e6,%d1,%d4
80005c68:	80 68       	mov.d %d8,%a6
80005c6a:	ba 03       	eq %d15,%d3,0
80005c6c:	0b 82 50 f2 	and.ge.u %d15,%d2,%d8
80005c70:	8b 03 00 f5 	or.ne %d15,%d3,0
80005c74:	ee 13       	jnz %d15,80005c9a <IfxScuCcu_calculateSysPllDividers+0xa6>
80005c76:	82 18       	mov %d8,1
80005c78:	c5 02 3f 10 	lea %a2,7f <_.+0x7e>
                    {
                        for (n = nMin; n <= nMax; n++)
                        {
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);
80005c7c:	4b d8 11 22 	div.u %e2,%d8,%d13
80005c80:	e2 e2       	mul %d2,%d14
80005c82:	a2 42       	sub %d2,%d4

                            if (fPllError == 0)
80005c84:	df 02 18 00 	jeq %d2,0,80005cb4 <IfxScuCcu_calculateSysPllDividers+0xc0>
                                bestP          = p;

                                goto EXITCALC_LOOP;
                            }

                            if (fPllLeastError > fPllError)
80005c88:	82 1f       	mov %d15,1
80005c8a:	0b 02 50 f2 	and.ge.u %d15,%d2,%d0
80005c8e:	6a 8b       	cmovn %d11,%d15,%d8
80005c90:	6a 20       	cmovn %d0,%d15,%d2
80005c92:	6a 5a       	cmovn %d10,%d15,%d5
80005c94:	6a 19       	cmovn %d9,%d15,%d1
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
                    {
                        for (n = nMin; n <= nMax; n++)
80005c96:	c2 18       	add %d8,1
80005c98:	fc 22       	loop %a2,80005c7c <IfxScuCcu_calculateSysPllDividers+0x88>
80005c9a:	80 3f       	mov.d %d15,%a3
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
80005c9c:	42 c1       	add %d1,%d12
80005c9e:	42 fd       	add %d13,%d15
80005ca0:	8b 11 68 f2 	lt.u %d15,%d1,129
80005ca4:	ee e0       	jnz %d15,80005c64 <IfxScuCcu_calculateSysPllDividers+0x70>
80005ca6:	60 c2       	mov.a %a2,%d12
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80005ca8:	c2 f5       	add %d5,-1
80005caa:	01 23 20 30 	sub.a %a3,%a3,%a2
80005cae:	fd f0 c7 7f 	loop %a15,80005c3c <IfxScuCcu_calculateSysPllDividers+0x48>
80005cb2:	3c 05       	j 80005cbc <IfxScuCcu_calculateSysPllDividers+0xc8>

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
                                bestK2         = k2;
                                bestN          = n;
80005cb4:	0b 58 10 a8 	mov %e10,%d8,%d5
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
                                bestK2         = k2;
80005cb8:	02 19       	mov %d9,%d1
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
80005cba:	82 00       	mov %d0,0
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80005cbc:	da 64       	mov %d15,100
80005cbe:	06 14       	sh %d4,1
80005cc0:	4b f4 11 42 	div.u %e4,%d4,%d15
80005cc4:	82 1f       	mov %d15,1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
        }
        else
        {
            retVal = 1;
80005cc6:	82 12       	mov %d2,1
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80005cc8:	0b 40 50 f2 	and.ge.u %d15,%d0,%d4
80005ccc:	ee 0f       	jnz %d15,80005cea <IfxScuCcu_calculateSysPllDividers+0xf6>
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80005cce:	82 02       	mov %d2,0

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80005cd0:	c2 fb       	add %d11,-1
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80005cd2:	c2 fa       	add %d10,-1
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80005cd4:	c2 f9       	add %d9,-1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80005cd6:	59 42 0c 00 	st.w [%a4]12,%d2

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80005cda:	e9 4b 09 00 	st.b [%a4]9,%d11
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80005cde:	e9 4a 08 00 	st.b [%a4]8,%d10
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80005ce2:	e9 49 0a 00 	st.b [%a4]10,%d9
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
80005ce6:	2c 40       	st.b [%a4]0,%d15
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
80005ce8:	82 02       	mov %d2,0
        {
            retVal = 1;
        }
    }
    return retVal;
}
80005cea:	00 90       	ret 

80005cec <IfxScuCcu_getOsc0Frequency>:
}


float32 IfxScuCcu_getOsc0Frequency(void)
{
    return (float32)IfxScuCcu_xtalFrequency;
80005cec:	91 00 00 f7 	movh.a %a15,28672
80005cf0:	19 f2 28 30 	ld.w %d2,[%a15]232 <700000e8 <IfxScuCcu_xtalFrequency>>
}
80005cf4:	4b 02 61 21 	utof %d2,%d2
80005cf8:	00 90       	ret 

80005cfa <IfxScuCcu_getOscFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005cfa:	91 30 00 ff 	movh.a %a15,61443
80005cfe:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80005d02:	4c f0       	ld.w %d15,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80005d04:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005d08:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80005d0c:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005d10:	6e 0c       	jz %d15,80005d28 <IfxScuCcu_getOscFrequency+0x2e>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80005d12:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0;
80005d14:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80005d16:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80005d1a:	5e 17       	jne %d15,1,80005d28 <IfxScuCcu_getOscFrequency+0x2e>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80005d1c:	91 00 00 f7 	movh.a %a15,28672
80005d20:	19 f2 28 30 	ld.w %d2,[%a15]232 <700000e8 <IfxScuCcu_xtalFrequency>>
80005d24:	4b 02 61 21 	utof %d2,%d2
        /* Reserved values, this */
        freq = 0.0;
    }

    return freq;
}
80005d28:	00 90       	ret 

80005d2a <IfxScuCcu_getPllErayFrequency>:
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80005d2a:	91 30 00 ff 	movh.a %a15,61443
80005d2e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
{
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80005d32:	6d ff e4 ff 	call 80005cfa <IfxScuCcu_getOscFrequency>

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80005d36:	4c f9       	ld.w %d15,[%a15]36
80005d38:	2e 05       	jz.t %d15,0,80005d42 <IfxScuCcu_getPllErayFrequency+0x18>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
80005d3a:	4c fb       	ld.w %d15,[%a15]44
80005d3c:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80005d40:	3c 21       	j 80005d82 <IfxScuCcu_getPllErayFrequency+0x58>
    }
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
80005d42:	4c f9       	ld.w %d15,[%a15]36
80005d44:	6f 3f 15 00 	jz.t %d15,3,80005d6e <IfxScuCcu_getPllErayFrequency+0x44>
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
80005d48:	48 b4       	ld.w %d4,[%a15]44
80005d4a:	8f f4 07 41 	and %d4,%d4,127
80005d4e:	c2 14       	add %d4,1
80005d50:	6d 00 6d 23 	call 8000a42a <__floatsidf>
80005d54:	7b 80 19 54 	movh %d5,16792
80005d58:	0b 23 10 68 	mov %e6,%d3,%d2
80005d5c:	82 04       	mov %d4,0
80005d5e:	1b 45 78 5d 	addi %d5,%d5,-10364
80005d62:	6d 00 d8 22 	call 8000a312 <__divdf3>
80005d66:	0b 23 10 48 	mov %e4,%d3,%d2
80005d6a:	1d 00 93 23 	j 8000a490 <__truncdfsf2>
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLERAYCON0.B.NDIV + 1)) / (scu->PLLERAYCON1.B.K2DIV + 1);
80005d6e:	48 a3       	ld.w %d3,[%a15]40
80005d70:	4c fb       	ld.w %d15,[%a15]44
80005d72:	37 03 e5 34 	extr.u %d3,%d3,9,5
80005d76:	16 7f       	and %d15,127
80005d78:	c2 13       	add %d3,1
80005d7a:	4b 03 41 31 	itof %d3,%d3
80005d7e:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005d82:	c2 1f       	add %d15,1
80005d84:	4b 0f 41 f1 	itof %d15,%d15
80005d88:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return freq;
}
80005d8c:	00 90       	ret 

80005d8e <IfxScuCcu_getPllErayVcoFrequency>:

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80005d8e:	91 30 00 ff 	movh.a %a15,61443
80005d92:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80005d96:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80005d98:	7b f0 cb 24 	movh %d2,19647
80005d9c:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80005da0:	6f 3f 18 80 	jnz.t %d15,3,80005dd0 <IfxScuCcu_getPllErayVcoFrequency+0x42>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80005da4:	6d ff ab ff 	call 80005cfa <IfxScuCcu_getOscFrequency>
80005da8:	91 30 00 ff 	movh.a %a15,61443
80005dac:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80005db0:	48 03       	ld.w %d3,[%a15]0
80005db2:	4c f0       	ld.w %d15,[%a15]0
80005db4:	37 03 e5 34 	extr.u %d3,%d3,9,5
80005db8:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005dbc:	c2 13       	add %d3,1
80005dbe:	4b 03 41 31 	itof %d3,%d3
80005dc2:	c2 1f       	add %d15,1
80005dc4:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005dc8:	4b 0f 41 f1 	itof %d15,%d15
80005dcc:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80005dd0:	00 90       	ret 

80005dd2 <IfxScuCcu_getPllFrequency>:
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80005dd2:	91 30 00 ff 	movh.a %a15,61443
80005dd6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
{
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80005dda:	6d ff 90 ff 	call 80005cfa <IfxScuCcu_getOscFrequency>

    if (scu->PLLSTAT.B.VCOBYST == 1)
80005dde:	4c f5       	ld.w %d15,[%a15]20
80005de0:	2e 06       	jz.t %d15,0,80005dec <IfxScuCcu_getPllFrequency+0x1a>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80005de2:	4c f7       	ld.w %d15,[%a15]28
80005de4:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80005de8:	c2 1f       	add %d15,1
80005dea:	3c 28       	j 80005e3a <IfxScuCcu_getPllFrequency+0x68>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80005dec:	4c f5       	ld.w %d15,[%a15]20
80005dee:	6f 3f 15 00 	jz.t %d15,3,80005e18 <IfxScuCcu_getPllFrequency+0x46>
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80005df2:	48 74       	ld.w %d4,[%a15]28
80005df4:	8f f4 07 41 	and %d4,%d4,127
80005df8:	c2 14       	add %d4,1
80005dfa:	6d 00 18 23 	call 8000a42a <__floatsidf>
80005dfe:	7b 80 19 54 	movh %d5,16792
80005e02:	0b 23 10 68 	mov %e6,%d3,%d2
80005e06:	82 04       	mov %d4,0
80005e08:	1b 45 78 5d 	addi %d5,%d5,-10364
80005e0c:	6d 00 83 22 	call 8000a312 <__divdf3>
80005e10:	0b 23 10 48 	mov %e4,%d3,%d2
80005e14:	1d 00 3e 23 	j 8000a490 <__truncdfsf2>
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80005e18:	48 64       	ld.w %d4,[%a15]24
80005e1a:	4c f7       	ld.w %d15,[%a15]28
80005e1c:	37 04 e7 44 	extr.u %d4,%d4,9,7
80005e20:	8f ff 07 31 	and %d3,%d15,127
80005e24:	4c f6       	ld.w %d15,[%a15]24
80005e26:	c2 14       	add %d4,1
80005e28:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005e2c:	4b 04 41 41 	itof %d4,%d4
80005e30:	c2 1f       	add %d15,1
80005e32:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
80005e36:	4b 42 41 20 	mul.f %d2,%d2,%d4
80005e3a:	4b 0f 41 f1 	itof %d15,%d15
80005e3e:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return freq;
}
80005e42:	00 90       	ret 

80005e44 <IfxScuCcu_getPllVcoFrequency>:

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80005e44:	91 30 00 ff 	movh.a %a15,61443
80005e48:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80005e4c:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80005e4e:	7b f0 cb 24 	movh %d2,19647
80005e52:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80005e56:	6f 3f 18 80 	jnz.t %d15,3,80005e86 <IfxScuCcu_getPllVcoFrequency+0x42>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
80005e5a:	6d ff 50 ff 	call 80005cfa <IfxScuCcu_getOscFrequency>
80005e5e:	91 30 00 ff 	movh.a %a15,61443
80005e62:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80005e66:	48 03       	ld.w %d3,[%a15]0
80005e68:	4c f0       	ld.w %d15,[%a15]0
80005e6a:	37 03 e7 34 	extr.u %d3,%d3,9,7
80005e6e:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005e72:	c2 13       	add %d3,1
80005e74:	4b 03 41 31 	itof %d3,%d3
80005e78:	c2 1f       	add %d15,1
80005e7a:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005e7e:	4b 0f 41 f1 	itof %d15,%d15
80005e82:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80005e86:	00 90       	ret 

80005e88 <IfxScuCcu_getSourceFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80005e88:	91 30 00 ff 	movh.a %a15,61443
80005e8c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80005e90:	4c f0       	ld.w %d15,[%a15]0
80005e92:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80005e96:	6e 06       	jz %d15,80005ea2 <IfxScuCcu_getSourceFrequency+0x1a>
80005e98:	1e 13       	jeq %d15,1,80005e9e <IfxScuCcu_getSourceFrequency+0x16>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80005e9a:	82 02       	mov %d2,0
80005e9c:	00 90       	ret 
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
80005e9e:	1d ff 9a ff 	j 80005dd2 <IfxScuCcu_getPllFrequency>
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80005ea2:	7b f0 cb 24 	movh %d2,19647
80005ea6:	1b 02 c2 2b 	addi %d2,%d2,-17376
        sourcefreq = 0;
        break;
    }

    return sourcefreq;
}
80005eaa:	00 90       	ret 

80005eac <IfxScuCcu_wait>:
    }
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
80005eac:	02 4f       	mov %d15,%d4
80005eae:	6d ff ed ff 	call 80005e88 <IfxScuCcu_getSourceFrequency>
80005eb2:	91 30 00 ff 	movh.a %a15,61443
80005eb6:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80005eba:	48 03       	ld.w %d3,[%a15]0
80005ebc:	37 03 64 34 	extr.u %d3,%d3,8,4
80005ec0:	4b 03 41 31 	itof %d3,%d3
80005ec4:	4b 32 51 20 	div.f %d2,%d2,%d3
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = STM0_TIM0.U;
80005ec8:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
80005ecc:	4b f2 41 20 	mul.f %d2,%d2,%d15
80005ed0:	4b 02 71 21 	ftouz %d2,%d2
    uint32 stmCountBegin = STM0_TIM0.U;

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
80005ed4:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80005ed8:	a2 3f       	sub %d15,%d3
80005eda:	3f 2f fd ff 	jlt.u %d15,%d2,80005ed4 <IfxScuCcu_wait+0x28>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
80005ede:	00 90       	ret 

80005ee0 <IfxScuCcu_getBbbFrequency>:
float32 IfxScuCcu_getBbbFrequency(void)
{
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80005ee0:	6d ff d4 ff 	call 80005e88 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
80005ee4:	91 30 00 ff 	movh.a %a15,61443
80005ee8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80005eec:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
        break;
    default:
        bbbFrequency = 0.0;
80005eee:	82 0f       	mov %d15,0
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80005ef0:	37 03 64 36 	extr.u %d3,%d3,12,4
80005ef4:	ff 53 30 80 	jge.u %d3,5,80005f54 <IfxScuCcu_getBbbFrequency+0x74>
80005ef8:	91 00 00 f8 	movh.a %a15,32768
80005efc:	d9 ff c8 c5 	lea %a15,[%a15]24328 <80005f08 <IfxScuCcu_getBbbFrequency+0x28>>
80005f00:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80005f04:	dc 0f       	ji %a15
80005f06:	00 00       	nop 
80005f08:	1d 00 0a 00 	j 80005f1c <IfxScuCcu_getBbbFrequency+0x3c>
80005f0c:	1d 00 17 00 	j 80005f3a <IfxScuCcu_getBbbFrequency+0x5a>
80005f10:	1d 00 18 00 	j 80005f40 <IfxScuCcu_getBbbFrequency+0x60>
80005f14:	1d 00 19 00 	j 80005f46 <IfxScuCcu_getBbbFrequency+0x66>
80005f18:	1d 00 1a 00 	j 80005f4c <IfxScuCcu_getBbbFrequency+0x6c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
80005f1c:	91 30 00 ff 	movh.a %a15,61443
80005f20:	d9 ff 00 16 	lea %a15,[%a15]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
80005f24:	48 03       	ld.w %d3,[%a15]0
        {
            bbbFrequency = 0.0;
80005f26:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
80005f28:	8f f3 00 31 	and %d3,%d3,15
80005f2c:	df 03 14 00 	jeq %d3,0,80005f54 <IfxScuCcu_getBbbFrequency+0x74>
        {
            bbbFrequency = 0.0;
        }
        else
        {
            bbbFrequency = sourceFrequency / SCU_CCUCON2.B.BBBDIV;
80005f30:	4c f0       	ld.w %d15,[%a15]0
80005f32:	16 0f       	and %d15,15
80005f34:	4b 0f 41 f1 	itof %d15,%d15
80005f38:	3c 0c       	j 80005f50 <IfxScuCcu_getBbbFrequency+0x70>
        }

        break;
    case 1:
        bbbFrequency = sourceFrequency / 30;
80005f3a:	7b 00 1f f4 	movh %d15,16880
80005f3e:	3c 09       	j 80005f50 <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 2:
        bbbFrequency = sourceFrequency / 60;
80005f40:	7b 00 27 f4 	movh %d15,17008
80005f44:	3c 06       	j 80005f50 <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 3:
        bbbFrequency = sourceFrequency / 120;
80005f46:	7b 00 2f f4 	movh %d15,17136
80005f4a:	3c 03       	j 80005f50 <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
80005f4c:	7b 00 37 f4 	movh %d15,17264
80005f50:	4b f2 51 f0 	div.f %d15,%d2,%d15
        bbbFrequency = 0.0;
        break;
    }

    return bbbFrequency;
}
80005f54:	02 f2       	mov %d2,%d15
80005f56:	00 90       	ret 

80005f58 <IfxScuCcu_getMaxFrequency>:
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80005f58:	91 30 00 ff 	movh.a %a15,61443
80005f5c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>

float32 IfxScuCcu_getMaxFrequency(void)
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();
80005f60:	6d ff 94 ff 	call 80005e88 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
80005f64:	4c f0       	ld.w %d15,[%a15]0
80005f66:	37 0f 64 f6 	extr.u %d15,%d15,12,4
80005f6a:	ff 5f 2d 80 	jge.u %d15,5,80005fc4 <IfxScuCcu_getMaxFrequency+0x6c>
80005f6e:	91 00 00 f8 	movh.a %a15,32768
80005f72:	d9 ff fc d5 	lea %a15,[%a15]24444 <80005f7c <IfxScuCcu_getMaxFrequency+0x24>>
80005f76:	90 ff       	addsc.a %a15,%a15,%d15,2
80005f78:	dc 0f       	ji %a15
80005f7a:	00 00       	nop 
80005f7c:	1d 00 0a 00 	j 80005f90 <IfxScuCcu_getMaxFrequency+0x38>
80005f80:	1d 00 14 00 	j 80005fa8 <IfxScuCcu_getMaxFrequency+0x50>
80005f84:	1d 00 15 00 	j 80005fae <IfxScuCcu_getMaxFrequency+0x56>
80005f88:	1d 00 16 00 	j 80005fb4 <IfxScuCcu_getMaxFrequency+0x5c>
80005f8c:	1d 00 17 00 	j 80005fba <IfxScuCcu_getMaxFrequency+0x62>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
80005f90:	91 30 00 ff 	movh.a %a15,61443
80005f94:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80005f98:	4c f0       	ld.w %d15,[%a15]0
80005f9a:	16 0f       	and %d15,15
80005f9c:	6e 15       	jz %d15,80005fc6 <IfxScuCcu_getMaxFrequency+0x6e>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
80005f9e:	4c f0       	ld.w %d15,[%a15]0
80005fa0:	16 0f       	and %d15,15
80005fa2:	4b 0f 41 f1 	itof %d15,%d15
80005fa6:	3c 0c       	j 80005fbe <IfxScuCcu_getMaxFrequency+0x66>
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
80005fa8:	7b 00 17 f4 	movh %d15,16752
80005fac:	3c 09       	j 80005fbe <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
80005fae:	7b 00 1f f4 	movh %d15,16880
80005fb2:	3c 06       	j 80005fbe <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
80005fb4:	7b 00 27 f4 	movh %d15,17008
80005fb8:	3c 03       	j 80005fbe <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
80005fba:	7b 00 2f f4 	movh %d15,17136
80005fbe:	4b f2 51 20 	div.f %d2,%d2,%d15
        break;
80005fc2:	00 90       	ret 
    default:
        maxFrequency = 0.0;
80005fc4:	82 02       	mov %d2,0
        break;
    }

    return maxFrequency;
}
80005fc6:	00 90       	ret 

80005fc8 <IfxScuCcu_getBaud1Frequency>:


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80005fc8:	91 30 00 ff 	movh.a %a15,61443
80005fcc:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80005fd0:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD1DIV == 0)
    {
        frequency = 0;
80005fd2:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80005fd4:	8f ff 00 81 	and %d8,%d15,15

    if (ccucon0.B.BAUD1DIV == 0)
80005fd8:	76 87       	jz %d8,80005fe6 <IfxScuCcu_getBaud1Frequency+0x1e>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
80005fda:	6d ff bf ff 	call 80005f58 <IfxScuCcu_getMaxFrequency>
80005fde:	4b 08 41 f1 	itof %d15,%d8
80005fe2:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return frequency;
}
80005fe6:	00 90       	ret 

80005fe8 <IfxScuCcu_getBaud2Frequency>:


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80005fe8:	91 30 00 ff 	movh.a %a15,61443
80005fec:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80005ff0:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD2DIV == 0)
    {
        frequency = 0;
80005ff2:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80005ff4:	37 0f 64 82 	extr.u %d8,%d15,4,4

    if (ccucon0.B.BAUD2DIV == 0)
80005ff8:	16 f0       	and %d15,240
80005ffa:	6e 07       	jz %d15,80006008 <IfxScuCcu_getBaud2Frequency+0x20>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
80005ffc:	6d ff ae ff 	call 80005f58 <IfxScuCcu_getMaxFrequency>
80006000:	4b 08 41 f1 	itof %d15,%d8
80006004:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return frequency;
}
80006008:	00 90       	ret 

8000600a <IfxScuCcu_getSpbFrequency>:
float32 IfxScuCcu_getSpbFrequency(void)
{
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
8000600a:	6d ff 3f ff 	call 80005e88 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
8000600e:	91 30 00 ff 	movh.a %a15,61443
80006012:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006016:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
        break;
    default:
        spbFrequency = 0.0;
80006018:	82 0f       	mov %d15,0
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
8000601a:	37 03 64 36 	extr.u %d3,%d3,12,4
8000601e:	ff 53 30 80 	jge.u %d3,5,8000607e <IfxScuCcu_getSpbFrequency+0x74>
80006022:	91 00 00 f8 	movh.a %a15,32768
80006026:	d9 ff 30 06 	lea %a15,[%a15]24624 <80006030 <IfxScuCcu_getSpbFrequency+0x26>>
8000602a:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000602e:	dc 0f       	ji %a15
80006030:	1d 00 0a 00 	j 80006044 <IfxScuCcu_getSpbFrequency+0x3a>
80006034:	1d 00 18 00 	j 80006064 <IfxScuCcu_getSpbFrequency+0x5a>
80006038:	1d 00 19 00 	j 8000606a <IfxScuCcu_getSpbFrequency+0x60>
8000603c:	1d 00 1a 00 	j 80006070 <IfxScuCcu_getSpbFrequency+0x66>
80006040:	1d 00 1b 00 	j 80006076 <IfxScuCcu_getSpbFrequency+0x6c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
80006044:	91 30 00 ff 	movh.a %a15,61443
80006048:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000604c:	48 03       	ld.w %d3,[%a15]0
        {
            spbFrequency = 0.0;
8000604e:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
80006050:	37 03 64 38 	extr.u %d3,%d3,16,4
80006054:	df 03 15 00 	jeq %d3,0,8000607e <IfxScuCcu_getSpbFrequency+0x74>
        {
            spbFrequency = 0.0;
        }
        else
        {
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
80006058:	4c f0       	ld.w %d15,[%a15]0
8000605a:	37 0f 64 f8 	extr.u %d15,%d15,16,4
8000605e:	4b 0f 41 f1 	itof %d15,%d15
80006062:	3c 0c       	j 8000607a <IfxScuCcu_getSpbFrequency+0x70>
        }

        break;
    case 1:
        spbFrequency = sourceFrequency / 30;
80006064:	7b 00 1f f4 	movh %d15,16880
80006068:	3c 09       	j 8000607a <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
8000606a:	7b 00 27 f4 	movh %d15,17008
8000606e:	3c 06       	j 8000607a <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
80006070:	7b 00 2f f4 	movh %d15,17136
80006074:	3c 03       	j 8000607a <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
80006076:	7b 00 37 f4 	movh %d15,17264
8000607a:	4b f2 51 f0 	div.f %d15,%d2,%d15
        spbFrequency = 0.0;
        break;
    }

    return spbFrequency;
}
8000607e:	02 f2       	mov %d2,%d15
80006080:	00 90       	ret 

80006082 <IfxScuCcu_getModuleFrequency>:
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
80006082:	91 30 00 ff 	movh.a %a15,61443
80006086:	d9 ff 38 06 	lea %a15,[%a15]24632 <f0036038 <_SMALL_DATA4_+0x4002e038>>
8000608a:	48 09       	ld.w %d9,[%a15]0
    spbFreq = IfxScuCcu_getSpbFrequency();
8000608c:	6d ff bf ff 	call 8000600a <IfxScuCcu_getSpbFrequency>

    if (scuFdr.B.DM == 1)
80006090:	bb 00 00 fc 	mov.u %d15,49152
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
    spbFreq = IfxScuCcu_getSpbFrequency();
80006094:	02 23       	mov %d3,%d2

    if (scuFdr.B.DM == 1)
80006096:	26 9f       	and %d15,%d9
80006098:	3b 00 00 24 	mov %d2,16384
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
8000609c:	b7 09 16 85 	insert %d8,%d9,0,10,22
    spbFreq = IfxScuCcu_getSpbFrequency();

    if (scuFdr.B.DM == 1)
800060a0:	7e 29       	jne %d15,%d2,800060b2 <IfxScuCcu_getModuleFrequency+0x30>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
800060a2:	3b 00 40 20 	mov %d2,1024
800060a6:	a2 82       	sub %d2,%d8
800060a8:	4b 02 41 21 	itof %d2,%d2
800060ac:	4b 23 51 20 	div.f %d2,%d3,%d2
800060b0:	00 90       	ret 
    }
    else if (scuFdr.B.DM == 2)
800060b2:	bb 00 00 48 	mov.u %d4,32768
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
    }
    else
    {
        moduleFreq = 0;
800060b6:	82 02       	mov %d2,0

    if (scuFdr.B.DM == 1)
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
800060b8:	7e 49       	jne %d15,%d4,800060ca <IfxScuCcu_getModuleFrequency+0x48>
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
800060ba:	4b 08 41 21 	itof %d2,%d8
800060be:	7b 00 a8 f3 	movh %d15,14976
800060c2:	4b 23 41 20 	mul.f %d2,%d3,%d2
800060c6:	4b f2 41 20 	mul.f %d2,%d2,%d15
    {
        moduleFreq = 0;
    }

    return moduleFreq;
}
800060ca:	00 90       	ret 

800060cc <IfxScuCcu_getSriFrequency>:
float32 IfxScuCcu_getSriFrequency(void)
{
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
800060cc:	6d ff de fe 	call 80005e88 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
800060d0:	91 30 00 ff 	movh.a %a15,61443
800060d4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800060d8:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0;
800060da:	82 0f       	mov %d15,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800060dc:	37 03 64 36 	extr.u %d3,%d3,12,4
800060e0:	ff 53 31 80 	jge.u %d3,5,80006142 <IfxScuCcu_getSriFrequency+0x76>
800060e4:	91 00 00 f8 	movh.a %a15,32768
800060e8:	d9 ff 34 36 	lea %a15,[%a15]24820 <800060f4 <IfxScuCcu_getSriFrequency+0x28>>
800060ec:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
800060f0:	dc 0f       	ji %a15
800060f2:	00 00       	nop 
800060f4:	1d 00 0a 00 	j 80006108 <IfxScuCcu_getSriFrequency+0x3c>
800060f8:	1d 00 18 00 	j 80006128 <IfxScuCcu_getSriFrequency+0x5c>
800060fc:	1d 00 19 00 	j 8000612e <IfxScuCcu_getSriFrequency+0x62>
80006100:	1d 00 1a 00 	j 80006134 <IfxScuCcu_getSriFrequency+0x68>
80006104:	1d 00 1b 00 	j 8000613a <IfxScuCcu_getSriFrequency+0x6e>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80006108:	91 30 00 ff 	movh.a %a15,61443
8000610c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006110:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0;
80006112:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80006114:	37 03 64 34 	extr.u %d3,%d3,8,4
80006118:	df 03 15 00 	jeq %d3,0,80006142 <IfxScuCcu_getSriFrequency+0x76>
        {
            sriFrequency = 0.0;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
8000611c:	4c f0       	ld.w %d15,[%a15]0
8000611e:	37 0f 64 f4 	extr.u %d15,%d15,8,4
80006122:	4b 0f 41 f1 	itof %d15,%d15
80006126:	3c 0c       	j 8000613e <IfxScuCcu_getSriFrequency+0x72>
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
80006128:	7b 00 1f f4 	movh %d15,16880
8000612c:	3c 09       	j 8000613e <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
8000612e:	7b 00 27 f4 	movh %d15,17008
80006132:	3c 06       	j 8000613e <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
80006134:	7b 00 2f f4 	movh %d15,17136
80006138:	3c 03       	j 8000613e <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
8000613a:	7b 00 37 f4 	movh %d15,17264
8000613e:	4b f2 51 f0 	div.f %d15,%d2,%d15
        sriFrequency = 0.0;
        break;
    }

    return sriFrequency;
}
80006142:	02 f2       	mov %d2,%d15
80006144:	00 90       	ret 

80006146 <IfxScuCcu_getCpuFrequency>:
    return bbbFrequency;
}


float32 IfxScuCcu_getCpuFrequency(const IfxCpu_ResourceCpu cpu)
{
80006146:	02 4f       	mov %d15,%d4
    float32 frequency = IfxScuCcu_getSriFrequency();
80006148:	6d ff c2 ff 	call 800060cc <IfxScuCcu_getSriFrequency>
    uint32  cpuDiv    = 0;

    switch (cpu)
8000614c:	1e 1d       	jeq %d15,1,80006166 <IfxScuCcu_getCpuFrequency+0x20>
8000614e:	6e 07       	jz %d15,8000615c <IfxScuCcu_getCpuFrequency+0x16>
80006150:	de 2a       	jne %d15,2,80006184 <IfxScuCcu_getCpuFrequency+0x3e>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
80006152:	91 30 00 ff 	movh.a %a15,61443
80006156:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
8000615a:	3c 0a       	j 8000616e <IfxScuCcu_getCpuFrequency+0x28>
    uint32  cpuDiv    = 0;

    switch (cpu)
    {
    case IfxCpu_ResourceCpu_0:
        cpuDiv = SCU_CCUCON6.U;
8000615c:	91 30 00 ff 	movh.a %a15,61443
80006160:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80006164:	3c 05       	j 8000616e <IfxScuCcu_getCpuFrequency+0x28>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
80006166:	91 30 00 ff 	movh.a %a15,61443
8000616a:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
8000616e:	4c f0       	ld.w %d15,[%a15]0
    default:
        frequency = 0.0;
        break;
    }

    if (cpuDiv != 0)
80006170:	6e 0b       	jz %d15,80006186 <IfxScuCcu_getCpuFrequency+0x40>
    {
        frequency = frequency * (cpuDiv / 64.0f);
80006172:	4b 0f 61 f1 	utof %d15,%d15
80006176:	7b 00 c8 33 	movh %d3,15488
8000617a:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
8000617e:	4b f2 41 20 	mul.f %d2,%d2,%d15
80006182:	00 90       	ret 
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
        break;
    default:
        frequency = 0.0;
80006184:	82 02       	mov %d2,0
    {
        frequency = frequency * (cpuDiv / 64.0f);
    }

    return frequency;
}
80006186:	00 90       	ret 

80006188 <IfxScuCcu_getFsi2Frequency>:


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006188:	91 30 00 ff 	movh.a %a15,61443
8000618c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006190:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSI2DIV == 0)
80006192:	7b 00 03 30 	movh %d3,48
80006196:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006198:	37 0f 62 8a 	extr.u %d8,%d15,20,2

    if (ccucon0.B.FSI2DIV == 0)
    {
        frequency = 0;
8000619c:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSI2DIV == 0)
8000619e:	76 3f       	jz %d3,800061bc <IfxScuCcu_getFsi2Frequency+0x34>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();
800061a0:	6d ff 96 ff 	call 800060cc <IfxScuCcu_getSriFrequency>

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
800061a4:	3b 00 f0 30 	mov %d3,3840
800061a8:	26 3f       	and %d15,%d3
800061aa:	1b 0f f0 ff 	addi %d15,%d15,-256
800061ae:	8f 0f d0 f1 	andn %d15,%d15,256
800061b2:	ee 05       	jnz %d15,800061bc <IfxScuCcu_getFsi2Frequency+0x34>
        {
            frequency = frequency / ccucon0.B.FSI2DIV;
800061b4:	4b 08 41 f1 	itof %d15,%d8
800061b8:	4b f2 51 20 	div.f %d2,%d2,%d15
        }
    }

    return frequency;
}
800061bc:	00 90       	ret 

800061be <IfxScuCcu_getFsiFrequency>:


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800061be:	91 30 00 ff 	movh.a %a15,61443
800061c2:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800061c6:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSIDIV == 0)
800061c8:	7b 00 30 30 	movh %d3,768
800061cc:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800061ce:	37 0f 62 8c 	extr.u %d8,%d15,24,2

    if (ccucon0.B.FSIDIV == 0)
    {
        frequency = 0;
800061d2:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSIDIV == 0)
800061d4:	76 3f       	jz %d3,800061f2 <IfxScuCcu_getFsiFrequency+0x34>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();
800061d6:	6d ff 7b ff 	call 800060cc <IfxScuCcu_getSriFrequency>

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
800061da:	3b 00 f0 30 	mov %d3,3840
800061de:	26 3f       	and %d15,%d3
800061e0:	1b 0f f0 ff 	addi %d15,%d15,-256
800061e4:	8f 0f d0 f1 	andn %d15,%d15,256
800061e8:	ee 05       	jnz %d15,800061f2 <IfxScuCcu_getFsiFrequency+0x34>
        {
            frequency = frequency / ccucon0.B.FSIDIV;
800061ea:	4b 08 41 f1 	itof %d15,%d8
800061ee:	4b f2 51 20 	div.f %d2,%d2,%d15
        }
    }

    return frequency;
}
800061f2:	00 90       	ret 

800061f4 <IfxScuCcu_init>:
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
800061f4:	19 4f 10 10 	ld.w %d15,[%a4]80
800061f8:	91 00 00 c7 	movh.a %a12,28672
    return sriFrequency;
}


boolean IfxScuCcu_init(const IfxScuCcu_Config *cfg)
{
800061fc:	40 4f       	mov.aa %a15,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
800061fe:	59 cf 28 30 	st.w [%a12]232 <700000e8 <IfxScuCcu_xtalFrequency>>,%d15

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
80006202:	6d 00 c8 07 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>
80006206:	02 29       	mov %d9,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
80006208:	6d 00 e3 07 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000620c:	02 94       	mov %d4,%d9
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
8000620e:	02 28       	mov %d8,%d2

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006210:	6d 00 c1 06 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006214:	91 30 00 2f 	movh.a %a2,61443
80006218:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
8000621c:	54 2c       	ld.w %d12,[%a2]
        SCU_TRAPDIS.B.SMUT = 1U;
8000621e:	4c 20       	ld.w %d15,[%a2]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006220:	02 94       	mov %d4,%d9

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80006222:	96 08       	or %d15,8
80006224:	6c 20       	st.w [%a2]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006226:	6d 00 eb 07 	call 800071fc <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000622a:	02 84       	mov %d4,%d8
8000622c:	6d 00 ce 06 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006230:	37 0c e1 c1 	extr.u %d12,%d12,3,1

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        while (SCU_CCUCON0.B.LCK != 0U)
80006234:	91 30 00 3f 	movh.a %a3,61443
80006238:	d9 33 30 06 	lea %a3,[%a3]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000623c:	4c 30       	ld.w %d15,[%a3]0
8000623e:	91 30 00 2f 	movh.a %a2,61443
80006242:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006246:	bf 0f fb 7f 	jlt %d15,0,8000623c <IfxScuCcu_init+0x48>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
8000624a:	4c 20       	ld.w %d15,[%a2]0
8000624c:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
80006250:	6c 20       	st.w [%a2]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
80006252:	4c 20       	ld.w %d15,[%a2]0
80006254:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80006258:	6c 20       	st.w [%a2]0,%d15

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
8000625a:	91 30 00 2f 	movh.a %a2,61443
8000625e:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006262:	4c 20       	ld.w %d15,[%a2]0
80006264:	96 10       	or %d15,16
80006266:	6c 20       	st.w [%a2]0,%d15
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON0.B.LCK != 0U)
80006268:	91 30 00 2f 	movh.a %a2,61443
8000626c:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006270:	4c 20       	ld.w %d15,[%a2]0
80006272:	bf 0f ff 7f 	jlt %d15,0,80006270 <IfxScuCcu_init+0x7c>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
80006276:	91 30 00 2f 	movh.a %a2,61443
8000627a:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000627e:	4c 20       	ld.w %d15,[%a2]0
80006280:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
80006284:	6c 20       	st.w [%a2]0,%d15
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
80006286:	4c 20       	ld.w %d15,[%a2]0
80006288:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000628c:	6c 20       	st.w [%a2]0,%d15
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
8000628e:	6d 00 82 07 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
80006292:	91 30 00 2f 	movh.a %a2,61443
80006296:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
8000629a:	02 2f       	mov %d15,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
8000629c:	54 22       	ld.w %d2,[%a2]

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
8000629e:	40 23       	mov.aa %a3,%a2
    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800062a0:	8f 02 c6 21 	andn %d2,%d2,96
800062a4:	74 22       	st.w [%a2],%d2

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
800062a6:	19 c6 28 30 	ld.w %d6,[%a12]232 <700000e8 <IfxScuCcu_xtalFrequency>>
800062aa:	7b 60 02 20 	movh %d2,38
800062ae:	1b 02 5a 22 	addi %d2,%d2,9632
800062b2:	4b 26 11 62 	div.u %e6,%d6,%d2
800062b6:	54 22       	ld.w %d2,[%a2]
800062b8:	c2 f6       	add %d6,-1
800062ba:	37 62 05 68 	insert %d6,%d2,%d6,16,5
800062be:	74 26       	st.w [%a2],%d6

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
800062c0:	54 22       	ld.w %d2,[%a2]
800062c2:	8f 42 40 21 	or %d2,%d2,4
800062c6:	74 22       	st.w [%a2],%d2

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
800062c8:	c5 02 3f 90 	lea %a2,27f <_.+0x27e>
800062cc:	54 32       	ld.w %d2,[%a3]
800062ce:	6f 12 05 80 	jnz.t %d2,1,800062d8 <IfxScuCcu_init+0xe4>
800062d2:	fc 2d       	loop %a2,800062cc <IfxScuCcu_init+0xd8>
    {
        TimeoutCtr--;

        if (TimeoutCtr == 0)
        {
            status = 1;
800062d4:	82 1b       	mov %d11,1
800062d6:	3c 05       	j 800062e0 <IfxScuCcu_init+0xec>

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
800062d8:	54 32       	ld.w %d2,[%a3]
800062da:	6f 82 fc 7f 	jz.t %d2,8,800062d2 <IfxScuCcu_init+0xde>


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;
800062de:	82 0b       	mov %d11,0
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
800062e0:	02 f4       	mov %d4,%d15
800062e2:	6d 00 58 06 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800062e6:	91 30 00 2f 	movh.a %a2,61443
800062ea:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
800062ee:	54 22       	ld.w %d2,[%a2]
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
        IfxScuWdt_setCpuEndinit(endinitPw);
800062f0:	02 f4       	mov %d4,%d15
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
800062f2:	8f 82 40 21 	or %d2,%d2,8
800062f6:	74 22       	st.w [%a2],%d2
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
800062f8:	91 30 00 2f 	movh.a %a2,61443
800062fc:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006300:	54 22       	ld.w %d2,[%a2]
80006302:	8f 82 40 21 	or %d2,%d2,8
80006306:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(endinitPw);
80006308:	6d 00 7a 07 	call 800071fc <IfxScuWdt_setCpuEndinit>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */

        status             |= IfxScuCcu_isOscillatorStable();

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000630c:	02 84       	mov %d4,%d8
8000630e:	6d 00 e3 07 	call 800072d4 <IfxScuWdt_setSafetyEndinit>
    }

    if (status == 0)
80006312:	df 0b 29 81 	jne %d11,0,80006564 <IfxScuCcu_init+0x370>

        /*Setting up P N and K2 values equate pll to evr osc freq */
        {
            {
                /*Set the K2 divider value for the step corresponding to step count */
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006316:	02 84       	mov %d4,%d8
80006318:	6d 00 58 06 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

                while (SCU_PLLSTAT.B.K2RDY == 0U)
8000631c:	91 30 00 2f 	movh.a %a2,61443
80006320:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80006324:	4c 20       	ld.w %d15,[%a2]0
80006326:	6f 5f ff 7f 	jz.t %d15,5,80006324 <IfxScuCcu_init+0x130>
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
8000632a:	91 30 00 2f 	movh.a %a2,61443
8000632e:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80006332:	54 22       	ld.w %d2,[%a2]
80006334:	0c fa       	ld.bu %d15,[%a15]10
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80006336:	7b 20 85 43 	movh %d4,14418
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
8000633a:	37 f2 07 f0 	insert %d15,%d2,%d15,0,7
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
8000633e:	1b 74 71 4b 	addi %d4,%d4,-18665
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80006342:	6c 20       	st.w [%a2]0,%d15

                {
                    /*change P and N divider values */
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
80006344:	91 30 00 2f 	movh.a %a2,61443
80006348:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000634c:	54 22       	ld.w %d2,[%a2]
8000634e:	0c f8       	ld.bu %d15,[%a15]8
80006350:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
80006354:	6c 20       	st.w [%a2]0,%d15
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
80006356:	54 22       	ld.w %d2,[%a2]
80006358:	0c f9       	ld.bu %d15,[%a15]9
8000635a:	37 f2 87 f4 	insert %d15,%d2,%d15,9,7
8000635e:	6c 20       	st.w [%a2]0,%d15

                    /* Disable oscillator disconnect feature
                     * in case of PLL unlock, PLL stays connected to fref */
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
80006360:	4c 20       	ld.w %d15,[%a2]0
80006362:	96 40       	or %d15,64
80006364:	6c 20       	st.w [%a2]0,%d15
                    //                    workaround for Errata: PLL TC 005
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
80006366:	4c 20       	ld.w %d15,[%a2]0
80006368:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
8000636c:	6c 20       	st.w [%a2]0,%d15
                    /* Connect PLL to fREF as oscillator clock is connected to PLL   */
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
8000636e:	4c 20       	ld.w %d15,[%a2]0
80006370:	96 20       	or %d15,32
80006372:	6c 20       	st.w [%a2]0,%d15
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
80006374:	4c 20       	ld.w %d15,[%a2]0
80006376:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
8000637a:	6c 20       	st.w [%a2]0,%d15

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;
8000637c:	4c 20       	ld.w %d15,[%a2]0
8000637e:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80006382:	6c 20       	st.w [%a2]0,%d15

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80006384:	6d ff 94 fd 	call 80005eac <IfxScuCcu_wait>

                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
80006388:	91 30 00 2f 	movh.a %a2,61443
8000638c:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80006390:	4c 20       	ld.w %d15,[%a2]0
80006392:	6f 2f ff 7f 	jz.t %d15,2,80006390 <IfxScuCcu_init+0x19c>
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
80006396:	91 30 00 2f 	movh.a %a2,61443
8000639a:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000639e:	4c 20       	ld.w %d15,[%a2]0

                    while (SCU_CCUCON0.B.LCK != 0U)
800063a0:	91 30 00 3f 	movh.a %a3,61443
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
800063a4:	8f 1f c0 f1 	andn %d15,%d15,1
800063a8:	6c 20       	st.w [%a2]0,%d15

                    while (SCU_CCUCON0.B.LCK != 0U)
800063aa:	d9 33 30 06 	lea %a3,[%a3]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063ae:	4c 30       	ld.w %d15,[%a3]0
800063b0:	91 30 00 2f 	movh.a %a2,61443
800063b4:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063b8:	bf 0f fb 7f 	jlt %d15,0,800063ae <IfxScuCcu_init+0x1ba>
                    {
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_CCUCON0.B.CLKSEL = 0x01;
800063bc:	4c 20       	ld.w %d15,[%a2]0
800063be:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
800063c2:	6c 20       	st.w [%a2]0,%d15

                    /*Configure the clock distribution */
                    while (SCU_CCUCON0.B.LCK != 0U)
800063c4:	4c 20       	ld.w %d15,[%a2]0
800063c6:	91 30 00 cf 	movh.a %a12,61443
800063ca:	d9 cc 30 06 	lea %a12,[%a12]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063ce:	bf 0f fb 7f 	jlt %d15,0,800063c4 <IfxScuCcu_init+0x1d0>
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
800063d2:	48 34       	ld.w %d4,[%a15]12
800063d4:	6d ff 6c fd 	call 80005eac <IfxScuCcu_wait>

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
800063d8:	4c f5       	ld.w %d15,[%a15]20
800063da:	54 c3       	ld.w %d3,[%a12]
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
800063dc:	48 42       	ld.w %d2,[%a15]16
                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
800063de:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
800063e2:	26 f2       	and %d2,%d15
800063e4:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
800063e8:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon0.B.UP     = 1;
800063ec:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
800063f0:	91 30 00 3f 	movh.a %a3,61443
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
                        ccucon0.B.UP     = 1;
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
800063f4:	6c c0       	st.w [%a12]0,%d15
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
800063f6:	d9 33 34 06 	lea %a3,[%a3]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800063fa:	4c 30       	ld.w %d15,[%a3]0
800063fc:	91 30 00 2f 	movh.a %a2,61443
80006400:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006404:	bf 0f fb 7f 	jlt %d15,0,800063fa <IfxScuCcu_init+0x206>
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
80006408:	4c f7       	ld.w %d15,[%a15]28
8000640a:	54 23       	ld.w %d3,[%a2]
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
8000640c:	48 62       	ld.w %d2,[%a15]24
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
8000640e:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
80006412:	26 f2       	and %d2,%d15
80006414:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon1.B.INSEL = 1;
80006418:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon1.B.UP    = 1;
8000641c:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON1     = ccucon1;
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
80006420:	91 30 00 3f 	movh.a %a3,61443
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
                        ccucon1.B.INSEL = 1;
                        ccucon1.B.UP    = 1;
                        SCU_CCUCON1     = ccucon1;
80006424:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
80006426:	d9 33 00 16 	lea %a3,[%a3]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
8000642a:	4c 30       	ld.w %d15,[%a3]0
8000642c:	91 30 00 2f 	movh.a %a2,61443
80006430:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
80006434:	bf 0f fb 7f 	jlt %d15,0,8000642a <IfxScuCcu_init+0x236>
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
80006438:	4c f9       	ld.w %d15,[%a15]36
8000643a:	54 23       	ld.w %d3,[%a2]
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
8000643c:	48 82       	ld.w %d2,[%a15]32
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
8000643e:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
80006442:	26 f2       	and %d2,%d15
80006444:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon2.B.UP = 1;
80006448:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON2  = ccucon2;
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
8000644c:	91 30 00 3f 	movh.a %a3,61443
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
                        ccucon2.B.UP = 1;
                        SCU_CCUCON2  = ccucon2;
80006450:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
80006452:	d9 33 0c 16 	lea %a3,[%a3]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80006456:	4c 30       	ld.w %d15,[%a3]0
80006458:	91 30 00 2f 	movh.a %a2,61443
8000645c:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80006460:	bf 0f fb 7f 	jlt %d15,0,80006456 <IfxScuCcu_init+0x262>
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80006464:	54 23       	ld.w %d3,[%a2]
80006466:	4c fb       	ld.w %d15,[%a15]44
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
80006468:	48 a2       	ld.w %d2,[%a15]40
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
8000646a:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
8000646e:	26 f2       	and %d2,%d15
80006470:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon5.B.UP = 1;
80006474:	b7 1f 01 ff 	insert %d15,%d15,1,30,1

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
80006478:	48 c2       	ld.w %d2,[%a15]48
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
                        ccucon5.B.UP = 1;
                        SCU_CCUCON5  = ccucon5;
8000647a:	6c 20       	st.w [%a2]0,%d15
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
8000647c:	91 30 00 2f 	movh.a %a2,61443
80006480:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80006484:	54 23       	ld.w %d3,[%a2]
80006486:	4c fd       	ld.w %d15,[%a15]52
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
                        SCU_CCUCON8 = ccucon8;
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006488:	02 84       	mov %d4,%d8
                        SCU_CCUCON5  = ccucon5;
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
8000648a:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
8000648e:	26 f2       	and %d2,%d15
80006490:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON6 = ccucon6;
80006494:	6c 20       	st.w [%a2]0,%d15
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
80006496:	91 30 00 2f 	movh.a %a2,61443
8000649a:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
8000649e:	54 23       	ld.w %d3,[%a2]
800064a0:	4c ff       	ld.w %d15,[%a15]60
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
800064a2:	48 e2       	ld.w %d2,[%a15]56
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
800064a4:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
800064a8:	26 f2       	and %d2,%d15
800064aa:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON7 = ccucon7;
800064ae:	6c 20       	st.w [%a2]0,%d15
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
800064b0:	91 30 00 2f 	movh.a %a2,61443
800064b4:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
800064b8:	54 23       	ld.w %d3,[%a2]
800064ba:	19 ff 04 10 	ld.w %d15,[%a15]68 <f0036088 <_SMALL_DATA4_+0x4002e088>>
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
800064be:	19 f2 00 10 	ld.w %d2,[%a15]64 <f0036088 <_SMALL_DATA4_+0x4002e088>>
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
800064c2:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
800064c6:	26 f2       	and %d2,%d15
800064c8:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON8 = ccucon8;
800064cc:	6c 20       	st.w [%a2]0,%d15
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800064ce:	6d 00 03 07 	call 800072d4 <IfxScuWdt_setSafetyEndinit>
            }
        }

        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
800064d2:	91 00 80 cf 	movh.a %a12,63488
800064d6:	d9 cc 14 02 	lea %a12,[%a12]8212 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
800064da:	19 ff 0c 10 	ld.w %d15,[%a15]76 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
800064de:	54 c3       	ld.w %d3,[%a12]

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
800064e0:	19 f2 08 10 	ld.w %d2,[%a15]72 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
800064e4:	0f f3 e0 30 	andn %d3,%d3,%d15
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
800064e8:	26 f2       	and %d2,%d15
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
800064ea:	02 94       	mov %d4,%d9
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
800064ec:	0f 23 a0 f0 	or %d15,%d3,%d2
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
800064f0:	6d 00 51 05 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
800064f4:	6c c0       	st.w [%a12]0,%d15
                IfxScuWdt_setCpuEndinit(endinit_pw);
800064f6:	02 94       	mov %d4,%d9
800064f8:	6d 00 82 06 	call 800071fc <IfxScuWdt_setCpuEndinit>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
800064fc:	91 30 00 df 	movh.a %a13,61443
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006500:	91 30 00 cf 	movh.a %a12,61443
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80006504:	82 0d       	mov %d13,0
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80006506:	d9 dd 14 06 	lea %a13,[%a13]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
8000650a:	d9 cc 1c 06 	lea %a12,[%a12]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
8000650e:	0c f0       	ld.bu %d15,[%a15]0
80006510:	8f fd 0f 21 	and %d2,%d13,255
80006514:	7f f2 28 80 	jge.u %d2,%d15,80006564 <IfxScuCcu_init+0x370>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006518:	02 84       	mov %d4,%d8
8000651a:	6d 00 57 05 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
8000651e:	4c d0       	ld.w %d15,[%a13]0
80006520:	6f 5f ff 7f 	jz.t %d15,5,8000651e <IfxScuCcu_init+0x32a>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006524:	02 df       	mov %d15,%d13
80006526:	16 ff       	and %d15,255
80006528:	53 cf 20 a0 	mul %d10,%d15,12
8000652c:	c8 12       	ld.a %a2,[%a15]4
8000652e:	4c c0       	ld.w %d15,[%a12]0
80006530:	60 a3       	mov.a %a3,%d10
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006532:	02 84       	mov %d4,%d8
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006534:	30 32       	add.a %a2,%a3
80006536:	14 22       	ld.bu %d2,[%a2]
80006538:	37 2f 07 20 	insert %d2,%d15,%d2,0,7
8000653c:	74 c2       	st.w [%a12],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000653e:	6d 00 cb 06 	call 800072d4 <IfxScuWdt_setSafetyEndinit>
            }

            /*call the hook function if configured */
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
80006542:	c8 12       	ld.a %a2,[%a15]4
80006544:	60 a3       	mov.a %a3,%d10
80006546:	30 32       	add.a %a2,%a3
80006548:	99 22 08 00 	ld.a %a2,[%a2]8
8000654c:	bc 23       	jz.a %a2,80006552 <IfxScuCcu_init+0x35e>
            {
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
8000654e:	2d 02 00 00 	calli %a2
            }

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
80006552:	c8 12       	ld.a %a2,[%a15]4
80006554:	60 a3       	mov.a %a3,%d10
80006556:	c2 1d       	add %d13,1
80006558:	30 32       	add.a %a2,%a3
8000655a:	19 24 04 00 	ld.w %d4,[%a2]4
8000655e:	6d ff a7 fc 	call 80005eac <IfxScuCcu_wait>
80006562:	3c d6       	j 8000650e <IfxScuCcu_init+0x31a>
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006564:	02 84       	mov %d4,%d8
80006566:	6d 00 31 05 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
8000656a:	91 30 00 ff 	movh.a %a15,61443
8000656e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006572:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006574:	02 84       	mov %d4,%d8
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80006576:	8f 0f c4 f1 	andn %d15,%d15,64
8000657a:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000657c:	6d 00 ac 06 	call 800072d4 <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006580:	91 30 00 ff 	movh.a %a15,61443
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006584:	02 94       	mov %d4,%d9
        SCU_TRAPCLR.B.SMUT = 1U;
80006586:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000658a:	6d 00 04 05 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
8000658e:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006590:	06 3c       	sh %d12,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006592:	96 08       	or %d15,8
80006594:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006596:	91 30 00 ff 	movh.a %a15,61443
8000659a:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
8000659e:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800065a0:	02 94       	mov %d4,%d9
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800065a2:	8f 8f c0 f1 	andn %d15,%d15,8
800065a6:	a6 fc       	or %d12,%d15
800065a8:	68 0c       	st.w [%a15]0,%d12
        IfxScuWdt_setCpuEndinit(endinit_pw);
800065aa:	6d 00 29 06 	call 800071fc <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
800065ae:	02 b2       	mov %d2,%d11
800065b0:	00 90       	ret 

800065b2 <IfxScuCcu_initConfig>:


void IfxScuCcu_initConfig(IfxScuCcu_Config *cfg)
{
    *cfg = IfxScuCcu_defaultClockConfig;
800065b2:	91 00 00 f8 	movh.a %a15,32768
800065b6:	d9 ff b4 90 	lea %a15,[%a15]2676 <80000a74 <IfxScuCcu_defaultClockConfig>>
800065ba:	c5 02 14 00 	lea %a2,14 <_.+0x13>
800065be:	44 ff       	ld.w %d15,[%a15+]
800065c0:	64 4f       	st.w [%a4+],%d15
800065c2:	fc 2e       	loop %a2,800065be <IfxScuCcu_initConfig+0xc>
800065c4:	00 90       	ret 

800065c6 <IfxScuCcu_initErayPll>:
}


boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
800065c6:	40 4c       	mov.aa %a12,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
800065c8:	6d 00 e5 05 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>
800065cc:	02 2f       	mov %d15,%d2
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800065ce:	6d 00 00 06 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800065d2:	02 f4       	mov %d4,%d15
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800065d4:	02 28       	mov %d8,%d2

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800065d6:	6d 00 de 04 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800065da:	91 30 00 ff 	movh.a %a15,61443
800065de:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800065e2:	48 03       	ld.w %d3,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
800065e4:	48 02       	ld.w %d2,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800065e6:	02 f4       	mov %d4,%d15
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
800065e8:	8f 82 40 21 	or %d2,%d2,8
800065ec:	68 02       	st.w [%a15]0,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800065ee:	37 03 e1 a1 	extr.u %d10,%d3,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
800065f2:	6d 00 05 06 	call 800071fc <IfxScuWdt_setCpuEndinit>
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800065f6:	02 84       	mov %d4,%d8
800065f8:	6d 00 e8 04 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
800065fc:	91 30 00 ff 	movh.a %a15,61443
80006600:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006604:	48 02       	ld.w %d2,[%a15]0
80006606:	ef 02 0c 00 	jz.t %d2,16,8000661e <IfxScuCcu_initErayPll+0x58>
8000660a:	48 02       	ld.w %d2,[%a15]0
8000660c:	6f 12 09 80 	jnz.t %d2,1,8000661e <IfxScuCcu_initErayPll+0x58>
80006610:	91 30 00 ff 	movh.a %a15,61443
80006614:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006618:	48 02       	ld.w %d2,[%a15]0
8000661a:	6f 12 19 00 	jz.t %d2,1,8000664c <IfxScuCcu_initErayPll+0x86>
    {   // PLLPWD=0 or VCOPWD=1 or PWDSTAT=1?
      // enable PLL and leave power saving mode
        SCU_PLLERAYCON0.B.PLLPWD = 1;
8000661e:	91 30 00 ff 	movh.a %a15,61443
80006622:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006626:	48 02       	ld.w %d2,[%a15]0
80006628:	b7 f2 01 28 	insert %d2,%d2,15,16,1
8000662c:	68 02       	st.w [%a15]0,%d2
        SCU_PLLERAYCON0.B.VCOPWD = 0;
8000662e:	48 02       	ld.w %d2,[%a15]0
80006630:	8f 22 c0 21 	andn %d2,%d2,2
80006634:	68 02       	st.w [%a15]0,%d2

        while (SCU_PLLERAYSTAT.B.PWDSTAT)  // poll PWDSTAT
80006636:	91 30 00 ff 	movh.a %a15,61443
8000663a:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000663e:	48 02       	ld.w %d2,[%a15]0
80006640:	6f 12 ff ff 	jnz.t %d2,1,8000663e <IfxScuCcu_initErayPll+0x78>
        {}

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(cfg->pllInitialStep.waitTime);
80006644:	19 c4 04 00 	ld.w %d4,[%a12]4
80006648:	6d ff 32 fc 	call 80005eac <IfxScuCcu_wait>
    }

    /* Enter Prescalar mode */
    /* Update K and N dividers */
    if (!SCU_PLLERAYSTAT.B.VCOBYST)      // checking PLLERAYBYPST flag
8000664c:	91 30 00 ff 	movh.a %a15,61443
80006650:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006654:	48 02       	ld.w %d2,[%a15]0
80006656:	6f 02 15 80 	jnz.t %d2,0,80006680 <IfxScuCcu_initErayPll+0xba>
    {                                    // select "secure" K1 value - please check @silicon if K1=4 is ok
        while (!SCU_PLLERAYSTAT.B.K1RDY) // poll K1RDY before changing K
8000665a:	48 02       	ld.w %d2,[%a15]0
8000665c:	6f 42 ff 7f 	jz.t %d2,4,8000665a <IfxScuCcu_initErayPll+0x94>
        {}

        SCU_PLLERAYCON1.B.K1DIV = 3;
80006660:	91 30 00 ff 	movh.a %a15,61443
80006664:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
80006668:	48 02       	ld.w %d2,[%a15]0
8000666a:	b7 32 07 28 	insert %d2,%d2,3,16,7
8000666e:	68 02       	st.w [%a15]0,%d2

        // activate VCO bypass (bit 0: VCOBYP=1)
        SCU_PLLERAYCON0.B.VCOBYP = 1;
80006670:	91 30 00 ff 	movh.a %a15,61443
80006674:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006678:	48 02       	ld.w %d2,[%a15]0
8000667a:	8f 12 40 21 	or %d2,%d2,1
8000667e:	68 02       	st.w [%a15]0,%d2
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
80006680:	91 30 00 ff 	movh.a %a15,61443
80006684:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006688:	48 02       	ld.w %d2,[%a15]0
8000668a:	6f 52 ff 7f 	jz.t %d2,5,80006688 <IfxScuCcu_initErayPll+0xc2>
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
8000668e:	91 30 00 ff 	movh.a %a15,61443
80006692:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
80006696:	48 03       	ld.w %d3,[%a15]0
80006698:	39 c2 02 00 	ld.bu %d2,[%a12]2 <f0030000 <_SMALL_DATA4_+0x40028000>>
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000669c:	02 84       	mov %d4,%d8
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
8000669e:	37 23 07 20 	insert %d2,%d3,%d2,0,7
800066a2:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.PDIV  = cfg->pllInitialStep.pDivider;
800066a4:	91 30 00 ff 	movh.a %a15,61443
800066a8:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
800066ac:	48 03       	ld.w %d3,[%a15]0
800066ae:	14 c2       	ld.bu %d2,[%a12]
800066b0:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
800066b4:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.NDIV  = cfg->pllInitialStep.nDivider;
800066b6:	48 03       	ld.w %d3,[%a15]0
800066b8:	39 c2 01 00 	ld.bu %d2,[%a12]1
800066bc:	37 23 85 24 	insert %d2,%d3,%d2,9,5
800066c0:	68 02       	st.w [%a15]0,%d2
     *  CLRFINDIS = 1 ==> Connect OSC to PLL
     *  PLLPWD = 1    ==> PLL Power Saving Mode : Normal behaviour
     *  NDIV = NDIV
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
800066c2:	48 02       	ld.w %d2,[%a15]0
800066c4:	b7 f2 01 29 	insert %d2,%d2,15,18,1
800066c8:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;
800066ca:	48 02       	ld.w %d2,[%a15]0
800066cc:	8f 02 42 21 	or %d2,%d2,32
800066d0:	68 02       	st.w [%a15]0,%d2

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800066d2:	6d 00 01 06 	call 800072d4 <IfxScuWdt_setSafetyEndinit>

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
800066d6:	91 10 00 f0 	movh.a %a15,1
800066da:	91 30 00 2f 	movh.a %a2,61443
800066de:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800066e2:	d9 ff 0f dc 	lea %a15,[%a15]-15537 <c34f <__TRICORE_DERIVATE_MEMORY_MAP__+0x9c4f>>
800066e6:	fd f0 04 00 	loop %a15,800066ee <IfxScuCcu_initErayPll+0x128>
    {}

    // check for timeout, exit immediately (don't disable VCO bypass) of not locked
    if (!time_out_ctr)
    {
        status = TRUE;
800066ea:	82 19       	mov %d9,1
800066ec:	3c 05       	j 800066f6 <IfxScuCcu_initErayPll+0x130>
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
800066ee:	54 22       	ld.w %d2,[%a2]
800066f0:	6f 22 fb 7f 	jz.t %d2,2,800066e6 <IfxScuCcu_initErayPll+0x120>

boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
800066f4:	82 09       	mov %d9,0
    if (!time_out_ctr)
    {
        status = TRUE;
    }

    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800066f6:	02 84       	mov %d4,%d8
800066f8:	6d 00 68 04 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>
    /*Bypass VCO*/
    SCU_PLLERAYCON0.B.VCOBYP = 0U;
800066fc:	91 30 00 ff 	movh.a %a15,61443
80006700:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006704:	48 02       	ld.w %d2,[%a15]0
80006706:	8f 12 c0 21 	andn %d2,%d2,1
8000670a:	68 02       	st.w [%a15]0,%d2

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
8000670c:	91 30 00 ff 	movh.a %a15,61443
80006710:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006714:	48 02       	ld.w %d2,[%a15]0
80006716:	6f 02 ff ff 	jnz.t %d2,0,80006714 <IfxScuCcu_initErayPll+0x14e>
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
8000671a:	91 30 00 ff 	movh.a %a15,61443
8000671e:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006722:	48 02       	ld.w %d2,[%a15]0
    {
        status = TRUE;
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006724:	02 84       	mov %d4,%d8

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
80006726:	37 02 61 21 	extr.u %d2,%d2,2,1

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000672a:	91 30 00 ff 	movh.a %a15,61443
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
    {
        status = TRUE;
8000672e:	ab 19 80 92 	sel %d9,%d2,%d9,1
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006732:	6d 00 d1 05 	call 800072d4 <IfxScuWdt_setSafetyEndinit>

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006736:	02 f4       	mov %d4,%d15
80006738:	6d 00 2d 04 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
8000673c:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
80006740:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006742:	8f 3a 00 30 	sh %d3,%d10,3

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006746:	8f 82 40 21 	or %d2,%d2,8
8000674a:	68 02       	st.w [%a15]0,%d2
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000674c:	91 30 00 ff 	movh.a %a15,61443
80006750:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006754:	48 02       	ld.w %d2,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006756:	02 f4       	mov %d4,%d15
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006758:	8f 82 c0 21 	andn %d2,%d2,8
8000675c:	a6 32       	or %d2,%d3
8000675e:	68 02       	st.w [%a15]0,%d2
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006760:	6d 00 4e 05 	call 800071fc <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
80006764:	02 92       	mov %d2,%d9
80006766:	00 90       	ret 

80006768 <IfxScuCcu_initErayPllConfig>:


void IfxScuCcu_initErayPllConfig(IfxScuCcu_ErayPllConfig *cfg)
{
    *cfg = IfxScuCcu_defaultErayPllConfig;
80006768:	91 00 00 f8 	movh.a %a15,32768
8000676c:	d9 ff ac 90 	lea %a15,[%a15]2668 <80000a6c <IfxScuCcu_defaultErayPllConfig>>
80006770:	09 f2 40 09 	ld.d %e2,[%a15]
80006774:	89 42 40 09 	st.d [%a4],%e2
80006778:	00 90       	ret 

8000677a <IfxScuCcu_setCpuFrequency>:
    return status;
}


float32 IfxScuCcu_setCpuFrequency(IfxCpu_ResourceCpu cpu, float32 cpuFreq)
{
8000677a:	02 5a       	mov %d10,%d5
8000677c:	02 49       	mov %d9,%d4
    uint16  endinitSfty_pw;
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();
8000677e:	6d ff a7 fc 	call 800060cc <IfxScuCcu_getSriFrequency>
80006782:	02 2f       	mov %d15,%d2

    if (cpuFreq >= sriFreq)
80006784:	4b 2a 01 20 	cmp.f %d2,%d10,%d2
80006788:	87 22 a2 20 	or.t %d2,%d2,2,%d2,1
    {
        cpuDiv = 0;
8000678c:	82 08       	mov %d8,0
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
8000678e:	f6 29       	jnz %d2,800067a0 <IfxScuCcu_setCpuFrequency+0x26>
    {
        cpuDiv = 0;
    }
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
80006790:	7b 00 28 84 	movh %d8,17024
80006794:	4b 8a 41 80 	mul.f %d8,%d10,%d8
80006798:	4b f8 51 80 	div.f %d8,%d8,%d15
8000679c:	4b 08 71 81 	ftouz %d8,%d8
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800067a0:	6d 00 17 05 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800067a4:	02 24       	mov %d4,%d2
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800067a6:	02 2a       	mov %d10,%d2

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800067a8:	6d 00 10 04 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

        switch (cpu)
800067ac:	df 19 0f 00 	jeq %d9,1,800067ca <IfxScuCcu_setCpuFrequency+0x50>
800067b0:	76 98       	jz %d9,800067c0 <IfxScuCcu_setCpuFrequency+0x46>
800067b2:	df 29 11 80 	jne %d9,2,800067d4 <IfxScuCcu_setCpuFrequency+0x5a>
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
800067b6:	91 30 00 ff 	movh.a %a15,61443
800067ba:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
800067be:	3c 0a       	j 800067d2 <IfxScuCcu_setCpuFrequency+0x58>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        switch (cpu)
        {
        case IfxCpu_ResourceCpu_0:
            SCU_CCUCON6.U = cpuDiv;
800067c0:	91 30 00 ff 	movh.a %a15,61443
800067c4:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
800067c8:	3c 05       	j 800067d2 <IfxScuCcu_setCpuFrequency+0x58>
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
800067ca:	91 30 00 ff 	movh.a %a15,61443
800067ce:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
800067d2:	68 08       	st.w [%a15]0,%d8

        default:
            break;
        }

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800067d4:	02 a4       	mov %d4,%d10
800067d6:	6d 00 7f 05 	call 800072d4 <IfxScuWdt_setSafetyEndinit>
    }

    if (cpuDiv != 0)
800067da:	76 89       	jz %d8,800067ec <IfxScuCcu_setCpuFrequency+0x72>
    {
        sriFreq = sriFreq * (cpuDiv / 64.0f);
800067dc:	4b 08 61 81 	utof %d8,%d8
800067e0:	7b 00 c8 23 	movh %d2,15488
800067e4:	4b 28 41 80 	mul.f %d8,%d8,%d2
800067e8:	4b 8f 41 f0 	mul.f %d15,%d15,%d8
    }

    return sriFreq;
}
800067ec:	02 f2       	mov %d2,%d15
800067ee:	00 90       	ret 

800067f0 <IfxScuCcu_setGtmFrequency>:


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
800067f0:	91 30 00 ff 	movh.a %a15,61443
800067f4:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
    return sriFreq;
}


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
800067f8:	02 48       	mov %d8,%d4
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
800067fa:	4c f0       	ld.w %d15,[%a15]0

    float32         inputFreq = IfxScuCcu_getSourceFrequency();
800067fc:	6d ff 46 fb 	call 80005e88 <IfxScuCcu_getSourceFrequency>
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
80006800:	4b 82 51 20 	div.f %d2,%d2,%d8
80006804:	4b 02 31 31 	ftoiz %d3,%d2
80006808:	4b 03 41 41 	itof %d4,%d3
8000680c:	6b 04 31 22 	sub.f %d2,%d2,%d4
80006810:	7b 00 f0 43 	movh %d4,16128
80006814:	4b 42 01 20 	cmp.f %d2,%d2,%d4
80006818:	37 02 61 21 	extr.u %d2,%d2,2,1
8000681c:	42 32       	add %d2,%d3
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000681e:	82 13       	mov %d3,1
80006820:	0b 32 b0 21 	max.u %d2,%d2,%d3
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
80006824:	8b e2 00 52 	eq %d5,%d2,14
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
80006828:	1b 92 ff 4f 	addi %d4,%d2,-7
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
    {
        gtmDiv = 12;
8000682c:	ab c2 a0 95 	seln %d9,%d5,%d2,12
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
80006830:	8f 12 c0 31 	andn %d3,%d2,1
80006834:	02 92       	mov %d2,%d9
80006836:	8b 74 a0 92 	ge.u %d9,%d4,7
8000683a:	2b 32 40 99 	sel %d9,%d9,%d2,%d3
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
8000683e:	6d 00 c8 04 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006842:	02 24       	mov %d4,%d2
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006844:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006846:	6d 00 c1 03 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON1.B.LCK != 0U)
8000684a:	40 f2       	mov.aa %a2,%a15
8000684c:	54 22       	ld.w %d2,[%a2]
8000684e:	91 30 00 ff 	movh.a %a15,61443
80006852:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006856:	bf 02 fb 7f 	jlt %d2,0,8000684c <IfxScuCcu_setGtmFrequency+0x5c>
    {}

    ccucon1.B.GTMDIV = gtmDiv;
8000685a:	37 9f 04 f6 	insert %d15,%d15,%d9,12,4
    ccucon1.B.UP     = 1U;
8000685e:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON1.U    = ccucon1.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006862:	02 84       	mov %d4,%d8
    while (SCU_CCUCON1.B.LCK != 0U)
    {}

    ccucon1.B.GTMDIV = gtmDiv;
    ccucon1.B.UP     = 1U;
    SCU_CCUCON1.U    = ccucon1.U;
80006864:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006866:	6d 00 37 05 	call 800072d4 <IfxScuWdt_setSafetyEndinit>
}


IFX_INLINE float32 IfxScuCcu_getGtmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.GTMDIV;
8000686a:	6d ff 0f fb 	call 80005e88 <IfxScuCcu_getSourceFrequency>
8000686e:	4c f0       	ld.w %d15,[%a15]0
80006870:	37 0f 64 f6 	extr.u %d15,%d15,12,4
80006874:	4b 0f 41 f1 	itof %d15,%d15

    return IfxScuCcu_getGtmFrequency();
}
80006878:	4b f2 51 20 	div.f %d2,%d2,%d15
8000687c:	00 90       	ret 

8000687e <IfxScuCcu_setPll2ErayFrequency>:


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
8000687e:	02 48       	mov %d8,%d4
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
80006880:	6d 00 a7 04 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>
80006884:	02 2f       	mov %d15,%d2
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006886:	6d ff 84 fa 	call 80005d8e <IfxScuCcu_getPllErayVcoFrequency>
    {
        IfxScuWdt_clearSafetyEndinit(password);
8000688a:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
8000688c:	02 29       	mov %d9,%d2
    {
        IfxScuWdt_clearSafetyEndinit(password);
8000688e:	6d 00 9d 03 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
80006892:	4b 89 51 80 	div.f %d8,%d9,%d8
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
80006896:	91 30 00 ff 	movh.a %a15,61443
8000689a:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
8000689e:	48 02       	ld.w %d2,[%a15]0


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800068a0:	7b 00 f8 33 	movh %d3,16256
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(password);
800068a4:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800068a6:	6b 03 31 88 	sub.f %d8,%d8,%d3
800068aa:	4b 08 71 81 	ftouz %d8,%d8
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
800068ae:	37 82 04 84 	insert %d8,%d2,%d8,8,4
800068b2:	68 08       	st.w [%a15]0,%d8
        IfxScuWdt_setSafetyEndinit(password);
800068b4:	6d 00 10 05 	call 800072d4 <IfxScuWdt_setSafetyEndinit>

IFX_INLINE float32 IfxScuCcu_getPll2ErayFrequency(void)
{
    float32 pll2ErayFrequency;

    pll2ErayFrequency = IfxScuCcu_getPllErayVcoFrequency() / (SCU_PLLERAYCON1.B.K3DIV + 1);
800068b8:	6d ff 6b fa 	call 80005d8e <IfxScuCcu_getPllErayVcoFrequency>
800068bc:	4c f0       	ld.w %d15,[%a15]0
800068be:	37 0f 64 f4 	extr.u %d15,%d15,8,4
800068c2:	c2 1f       	add %d15,1
800068c4:	4b 0f 41 f1 	itof %d15,%d15
    }
    return IfxScuCcu_getPll2ErayFrequency();
}
800068c8:	4b f2 51 20 	div.f %d2,%d2,%d15
800068cc:	00 90       	ret 

800068ce <IfxScuCcu_setPll2Frequency>:


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
800068ce:	02 48       	mov %d8,%d4
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800068d0:	6d 00 7f 04 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>
800068d4:	02 2f       	mov %d15,%d2
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
800068d6:	6d ff b7 fa 	call 80005e44 <IfxScuCcu_getPllVcoFrequency>
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800068da:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
800068dc:	02 29       	mov %d9,%d2
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800068de:	6d 00 75 03 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
800068e2:	4b 89 51 80 	div.f %d8,%d9,%d8
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
800068e6:	91 30 00 ff 	movh.a %a15,61443
800068ea:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
800068ee:	48 02       	ld.w %d2,[%a15]0


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
800068f0:	7b 00 f8 33 	movh %d3,16256
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800068f4:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
800068f6:	6b 03 31 88 	sub.f %d8,%d8,%d3
800068fa:	4b 08 71 81 	ftouz %d8,%d8
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
800068fe:	37 82 07 84 	insert %d8,%d2,%d8,8,7
80006902:	68 08       	st.w [%a15]0,%d8
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006904:	6d 00 e8 04 	call 800072d4 <IfxScuWdt_setSafetyEndinit>


IFX_INLINE float32 IfxScuCcu_getPll2Frequency(void)
{
    float32 pll2Frequency;
    pll2Frequency = IfxScuCcu_getPllVcoFrequency() / (SCU_PLLCON1.B.K3DIV + 1);
80006908:	6d ff 9e fa 	call 80005e44 <IfxScuCcu_getPllVcoFrequency>
8000690c:	4c f0       	ld.w %d15,[%a15]0
8000690e:	37 0f 67 f4 	extr.u %d15,%d15,8,7
80006912:	c2 1f       	add %d15,1
80006914:	4b 0f 41 f1 	itof %d15,%d15
    }
    return IfxScuCcu_getPll2Frequency();
}
80006918:	4b f2 51 20 	div.f %d2,%d2,%d15
8000691c:	00 90       	ret 

8000691e <IfxScuCcu_setSpbFrequency>:


float32 IfxScuCcu_setSpbFrequency(float32 spbFreq)
{
8000691e:	02 4f       	mov %d15,%d4
    /* TODO: check whether it is necessary to disable trap and/or the safety */
    uint16          l_EndInitPW;
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
80006920:	6d ff b4 fa 	call 80005e88 <IfxScuCcu_getSourceFrequency>
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
80006924:	4b f2 51 20 	div.f %d2,%d2,%d15
80006928:	82 24       	mov %d4,2
8000692a:	4b 02 71 21 	ftouz %d2,%d2
8000692e:	0b 42 b0 41 	max.u %d4,%d2,%d4
    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
    {
        spbDiv = spbDiv - 1;
    }

    if (spbDiv == 14)
80006932:	8b e4 00 32 	eq %d3,%d4,14
    {
        spbDiv = 12;
80006936:	ab c4 a0 a3 	seln %d10,%d3,%d4,12
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
    spbDiv = __maxu(spbDiv, 2);

    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
8000693a:	1b 94 ff 2f 	addi %d2,%d4,-7
    {
        spbDiv = spbDiv - 1;
8000693e:	8f 14 c0 f1 	andn %d15,%d4,1
80006942:	02 a4       	mov %d4,%d10
80006944:	8b 72 a0 a2 	ge.u %d10,%d2,7
80006948:	2b f4 40 aa 	sel %d10,%d10,%d4,%d15
    if (spbDiv == 14)
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
8000694c:	6d 00 23 04 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>
80006950:	02 28       	mov %d8,%d2
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006952:	6d 00 3e 04 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006956:	02 84       	mov %d4,%d8
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006958:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
8000695a:	6d 00 1c 03 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
8000695e:	91 30 00 ff 	movh.a %a15,61443
80006962:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006966:	48 02       	ld.w %d2,[%a15]0
80006968:	3b 00 3e f0 	mov %d15,992
8000696c:	a6 2f       	or %d15,%d2
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
8000696e:	02 84       	mov %d4,%d8

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
80006970:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
80006972:	6d 00 45 04 	call 800071fc <IfxScuWdt_setCpuEndinit>

    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006976:	02 94       	mov %d4,%d9
80006978:	6d 00 28 03 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
8000697c:	91 30 00 2f 	movh.a %a2,61443
80006980:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006984:	4c 20       	ld.w %d15,[%a2]0
80006986:	91 30 00 ff 	movh.a %a15,61443
8000698a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000698e:	bf 0f fb 7f 	jlt %d15,0,80006984 <IfxScuCcu_setSpbFrequency+0x66>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80006992:	4c f0       	ld.w %d15,[%a15]0
    ccucon0.B.SPBDIV = spbDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006994:	02 94       	mov %d4,%d9

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SPBDIV = spbDiv;
80006996:	37 af 04 f8 	insert %d15,%d15,%d10,16,4
    ccucon0.B.UP     = 1;
8000699a:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
8000699e:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
800069a0:	6d 00 9a 04 	call 800072d4 <IfxScuWdt_setSafetyEndinit>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
800069a4:	02 84       	mov %d4,%d8
800069a6:	6d 00 f6 02 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
800069aa:	91 30 00 ff 	movh.a %a15,61443
800069ae:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800069b2:	4c f0       	ld.w %d15,[%a15]0
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
800069b4:	02 84       	mov %d4,%d8
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
800069b6:	b7 0f 85 f2 	insert %d15,%d15,0,5,5
800069ba:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
800069bc:	6d 00 20 04 	call 800071fc <IfxScuWdt_setCpuEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
800069c0:	91 30 00 ff 	movh.a %a15,61443
800069c4:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800069c8:	4c f0       	ld.w %d15,[%a15]0
800069ca:	bf 0f ff 7f 	jlt %d15,0,800069c8 <IfxScuCcu_setSpbFrequency+0xaa>
    {}

    return IfxScuCcu_getSpbFrequency();
800069ce:	1d ff 1e fb 	j 8000600a <IfxScuCcu_getSpbFrequency>

800069d2 <IfxScuCcu_setSriFrequency>:
}


float32 IfxScuCcu_setSriFrequency(float32 sriFreq)
{
800069d2:	02 4f       	mov %d15,%d4
    float32         freq   = 0;
    float32         source = IfxScuCcu_getSourceFrequency();
800069d4:	6d ff 5a fa 	call 80005e88 <IfxScuCcu_getSourceFrequency>
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
800069d8:	4b f2 51 20 	div.f %d2,%d2,%d15
800069dc:	4b 02 31 31 	ftoiz %d3,%d2
800069e0:	4b 03 41 f1 	itof %d15,%d3
800069e4:	6b 0f 31 22 	sub.f %d2,%d2,%d15
800069e8:	7b 00 f0 f3 	movh %d15,16128
800069ec:	4b f2 01 f0 	cmp.f %d15,%d2,%d15
800069f0:	37 0f 61 f1 	extr.u %d15,%d15,2,1
800069f4:	82 12       	mov %d2,1
800069f6:	42 3f       	add %d15,%d3
800069f8:	0b 2f b0 f1 	max.u %d15,%d15,%d2
    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
800069fc:	8b ef 00 42 	eq %d4,%d15,14
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
80006a00:	92 93       	add %d3,%d15,-7
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
    {
        sriDiv = 12;
80006a02:	ab cf a0 94 	seln %d9,%d4,%d15,12
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
80006a06:	8f 1f c0 21 	andn %d2,%d15,1
80006a0a:	02 9f       	mov %d15,%d9
80006a0c:	8b 73 a0 92 	ge.u %d9,%d3,7
80006a10:	2b 2f 40 99 	sel %d9,%d9,%d15,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006a14:	6d 00 dd 03 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006a18:	02 24       	mov %d4,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006a1a:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006a1c:	6d 00 d6 02 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006a20:	91 30 00 2f 	movh.a %a2,61443
80006a24:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006a28:	4c 20       	ld.w %d15,[%a2]0
80006a2a:	91 30 00 ff 	movh.a %a15,61443
80006a2e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006a32:	bf 0f fb 7f 	jlt %d15,0,80006a28 <IfxScuCcu_setSriFrequency+0x56>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80006a36:	4c f0       	ld.w %d15,[%a15]0
    ccucon0.B.SRIDIV = sriDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006a38:	02 84       	mov %d4,%d8

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SRIDIV = sriDiv;
80006a3a:	37 9f 04 f4 	insert %d15,%d15,%d9,8,4
    ccucon0.B.UP     = 1;
80006a3e:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
80006a42:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006a44:	6d 00 48 04 	call 800072d4 <IfxScuWdt_setSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006a48:	4c f0       	ld.w %d15,[%a15]0
80006a4a:	bf 0f ff 7f 	jlt %d15,0,80006a48 <IfxScuCcu_setSriFrequency+0x76>
    {}

    freq = IfxScuCcu_getSriFrequency();
80006a4e:	1d ff 3f fb 	j 800060cc <IfxScuCcu_getSriFrequency>

80006a52 <IfxScuCcu_switchToBackupClock>:
{
    uint16 endinit_pw, endinitSfty_pw;
    int    pllStepsCount;
    uint8  smuTrapEnable;

    if (SCU_CCUCON0.B.CLKSEL == 0) /* Already source is backup clock */
80006a52:	91 30 00 ff 	movh.a %a15,61443
80006a56:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006a5a:	4c f0       	ld.w %d15,[%a15]0
80006a5c:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80006a60:	df 0f 81 00 	jeq %d15,0,80006b62 <IfxScuCcu_switchToBackupClock+0x110>
80006a64:	40 4f       	mov.aa %a15,%a4
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006a66:	6d 00 b4 03 	call 800071ce <IfxScuWdt_getSafetyWatchdogPassword>
80006a6a:	02 29       	mov %d9,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006a6c:	6d 00 93 03 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006a70:	0c f0       	ld.bu %d15,[%a15]0
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006a72:	02 28       	mov %d8,%d2
80006a74:	53 cf 20 20 	mul %d2,%d15,12
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006a78:	91 30 00 ef 	movh.a %a14,61443
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006a7c:	91 30 00 df 	movh.a %a13,61443
80006a80:	60 22       	mov.a %a2,%d2
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006a82:	d9 ee 14 06 	lea %a14,[%a14]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80006a86:	d9 2c f4 ff 	lea %a12,[%a2]-12 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006a8a:	d9 dd 1c 06 	lea %a13,[%a13]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006a8e:	6e 1b       	jz %d15,80006ac4 <IfxScuCcu_switchToBackupClock+0x72>
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006a90:	02 94       	mov %d4,%d9
80006a92:	6d 00 9b 02 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006a96:	54 e2       	ld.w %d2,[%a14]
80006a98:	6f 52 ff 7f 	jz.t %d2,5,80006a96 <IfxScuCcu_switchToBackupClock+0x44>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006a9c:	c8 12       	ld.a %a2,[%a15]4
80006a9e:	54 d3       	ld.w %d3,[%a13]

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006aa0:	02 94       	mov %d4,%d9
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006aa2:	30 c2       	add.a %a2,%a12
80006aa4:	14 22       	ld.bu %d2,[%a2]

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006aa6:	c2 ff       	add %d15,-1
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006aa8:	37 23 07 20 	insert %d2,%d3,%d2,0,7
80006aac:	74 d2       	st.w [%a13],%d2

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006aae:	6d 00 13 04 	call 800072d4 <IfxScuWdt_setSafetyEndinit>

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount - 1].waitTime);
80006ab2:	c8 12       	ld.a %a2,[%a15]4
80006ab4:	30 c2       	add.a %a2,%a12
80006ab6:	19 24 04 00 	ld.w %d4,[%a2]4
80006aba:	6d ff f9 f9 	call 80005eac <IfxScuCcu_wait>
80006abe:	d9 cc f4 ff 	lea %a12,[%a12]-12
80006ac2:	3c e6       	j 80006a8e <IfxScuCcu_switchToBackupClock+0x3c>
        }
    }

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006ac4:	02 84       	mov %d4,%d8
80006ac6:	6d 00 66 02 	call 80006f92 <IfxScuWdt_clearCpuEndinit>

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006aca:	91 30 00 ff 	movh.a %a15,61443
80006ace:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006ad2:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
80006ad4:	4c f0       	ld.w %d15,[%a15]0

        IfxScuWdt_setCpuEndinit(endinit_pw);
80006ad6:	02 84       	mov %d4,%d8
    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80006ad8:	96 08       	or %d15,8
80006ada:	68 0f       	st.w [%a15]0,%d15

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006adc:	37 02 e1 a1 	extr.u %d10,%d2,3,1
        SCU_TRAPDIS.B.SMUT = 1U;

        IfxScuWdt_setCpuEndinit(endinit_pw);
80006ae0:	6d 00 8e 03 	call 800071fc <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006ae4:	02 94       	mov %d4,%d9
80006ae6:	6d 00 71 02 	call 80006fc8 <IfxScuWdt_clearSafetyEndinit>

        while (SCU_CCUCON0.B.LCK != 0U)
80006aea:	91 30 00 2f 	movh.a %a2,61443
80006aee:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006af2:	4c 20       	ld.w %d15,[%a2]0
80006af4:	91 30 00 ff 	movh.a %a15,61443
80006af8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006afc:	bf 0f fb 7f 	jlt %d15,0,80006af2 <IfxScuCcu_switchToBackupClock+0xa0>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80006b00:	4c f0       	ld.w %d15,[%a15]0
80006b02:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
80006b06:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
80006b08:	4c f0       	ld.w %d15,[%a15]0
80006b0a:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80006b0e:	68 0f       	st.w [%a15]0,%d15

        while (SCU_CCUCON0.B.LCK != 0U)
80006b10:	4c f0       	ld.w %d15,[%a15]0
80006b12:	bf 0f ff 7f 	jlt %d15,0,80006b10 <IfxScuCcu_switchToBackupClock+0xbe>
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006b16:	91 30 00 ff 	movh.a %a15,61443
80006b1a:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006b1e:	4c f0       	ld.w %d15,[%a15]0

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006b20:	02 94       	mov %d4,%d9
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006b22:	96 10       	or %d15,16
80006b24:	68 0f       	st.w [%a15]0,%d15

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80006b26:	4c f0       	ld.w %d15,[%a15]0
80006b28:	8f 0f c4 f1 	andn %d15,%d15,64
80006b2c:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006b2e:	6d 00 d3 03 	call 800072d4 <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006b32:	91 30 00 ff 	movh.a %a15,61443
80006b36:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006b3a:	02 84       	mov %d4,%d8
80006b3c:	6d 00 2b 02 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80006b40:	4c f0       	ld.w %d15,[%a15]0

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006b42:	8f 3a 00 20 	sh %d2,%d10,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006b46:	96 08       	or %d15,8
80006b48:	68 0f       	st.w [%a15]0,%d15

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006b4a:	91 30 00 ff 	movh.a %a15,61443
80006b4e:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006b52:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006b54:	02 84       	mov %d4,%d8
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006b56:	8f 8f c0 f1 	andn %d15,%d15,8
80006b5a:	a6 2f       	or %d15,%d2
80006b5c:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006b5e:	1d 00 4f 03 	j 800071fc <IfxScuWdt_setCpuEndinit>
80006b62:	00 90       	ret 

80006b64 <IfxScuEru_clearAllEventFlags>:
/******************************************************************************/

void IfxScuEru_clearAllEventFlags(void)
{
    uint32 mask = (0xFF << 16);
    MODULE_SCU.FMR.U = mask;
80006b64:	91 30 00 ff 	movh.a %a15,61443
80006b68:	7b f0 0f f0 	movh %d15,255
80006b6c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006b70:	59 ff 24 80 	st.w [%a15]548 <f0030224 <_SMALL_DATA4_+0x40028224>>,%d15
80006b74:	00 90       	ret 

80006b76 <IfxScuEru_clearEventFlag>:
}


void IfxScuEru_clearEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << (inputChannel + 16);
80006b76:	1b 04 01 40 	addi %d4,%d4,16
80006b7a:	82 1f       	mov %d15,1
    SCU_FMR.U = mask;
80006b7c:	91 30 00 ff 	movh.a %a15,61443
}


void IfxScuEru_clearEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << (inputChannel + 16);
80006b80:	0f 4f 00 f0 	sh %d15,%d15,%d4
    SCU_FMR.U = mask;
80006b84:	d9 ff 24 86 	lea %a15,[%a15]25124 <f0036224 <_SMALL_DATA4_+0x4002e224>>
80006b88:	68 0f       	st.w [%a15]0,%d15
80006b8a:	00 90       	ret 

80006b8c <IfxScuEru_clearInputChannelConfiguration>:


void IfxScuEru_clearInputChannelConfiguration(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006b8c:	8f f4 1f f0 	sh %d15,%d4,-1
80006b90:	06 2f       	sh %d15,2
80006b92:	60 ff       	mov.a %a15,%d15
80006b94:	d9 ff 00 06 	lea %a15,[%a15]24576
80006b98:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint32 mask  = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006b9c:	19 ff 10 80 	ld.w %d15,[%a15]528
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 mask  = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006ba0:	6f 04 05 00 	jz.t %d4,0,80006baa <IfxScuEru_clearInputChannelConfiguration+0x1e>
    {
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006ba4:	b7 0f 10 f8 	insert %d15,%d15,0,16,16
80006ba8:	3c 03       	j 80006bae <IfxScuEru_clearInputChannelConfiguration+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        mask                     = (mask << 16);
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006baa:	b7 0f 10 f0 	insert %d15,%d15,0,0,16
80006bae:	59 ff 10 80 	st.w [%a15]528,%d15
80006bb2:	00 90       	ret 

80006bb4 <IfxScuEru_clearOutputChannelConfiguration>:


void IfxScuEru_clearOutputChannelConfiguration(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006bb4:	8f f4 1f f0 	sh %d15,%d4,-1
80006bb8:	06 2f       	sh %d15,2
80006bba:	60 ff       	mov.a %a15,%d15
80006bbc:	d9 ff 00 06 	lea %a15,[%a15]24576
80006bc0:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint32 mask  = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006bc4:	19 ff 2c 80 	ld.w %d15,[%a15]556
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 mask  = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006bc8:	6f 04 05 00 	jz.t %d4,0,80006bd2 <IfxScuEru_clearOutputChannelConfiguration+0x1e>
    {
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006bcc:	b7 0f 10 f8 	insert %d15,%d15,0,16,16
80006bd0:	3c 03       	j 80006bd6 <IfxScuEru_clearOutputChannelConfiguration+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        mask                     = (mask << 16);
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006bd2:	b7 0f 10 f0 	insert %d15,%d15,0,0,16
80006bd6:	59 ff 2c 80 	st.w [%a15]556,%d15
80006bda:	00 90       	ret 

80006bdc <IfxScuEru_connectTrigger>:


void IfxScuEru_connectTrigger(IfxScuEru_InputChannel inputChannel, IfxScuEru_InputNodePointer triggerSelect)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006bdc:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.INP1 = triggerSelect;
80006be0:	91 30 00 ff 	movh.a %a15,61443
80006be4:	1b 4f 08 f0 	addi %d15,%d15,132
80006be8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006bec:	8f 75 00 51 	and %d5,%d5,7
80006bf0:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_connectTrigger(IfxScuEru_InputChannel inputChannel, IfxScuEru_InputNodePointer triggerSelect)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006bf2:	6f 04 08 00 	jz.t %d4,0,80006c02 <IfxScuEru_connectTrigger+0x26>
    {
        MODULE_SCU.EICR[index].B.INP1 = triggerSelect;
80006bf6:	4c f0       	ld.w %d15,[%a15]0
80006bf8:	8f c5 01 50 	sh %d5,%d5,28
80006bfc:	b7 0f 03 fe 	insert %d15,%d15,0,28,3
80006c00:	3c 06       	j 80006c0c <IfxScuEru_connectTrigger+0x30>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.INP0 = triggerSelect;
80006c02:	4c f0       	ld.w %d15,[%a15]0
80006c04:	8f c5 00 50 	sh %d5,%d5,12
80006c08:	b7 0f 03 f6 	insert %d15,%d15,0,12,3
80006c0c:	a6 f5       	or %d5,%d15
80006c0e:	68 05       	st.w [%a15]0,%d5
80006c10:	00 90       	ret 

80006c12 <IfxScuEru_disableAutoClear>:


void IfxScuEru_disableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006c12:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.LDEN1 = FALSE;
80006c16:	91 30 00 ff 	movh.a %a15,61443
80006c1a:	1b 4f 08 f0 	addi %d15,%d15,132
80006c1e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006c22:	90 ff       	addsc.a %a15,%a15,%d15,2
80006c24:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006c26:	6f 04 05 00 	jz.t %d4,0,80006c30 <IfxScuEru_disableAutoClear+0x1e>
    {
        MODULE_SCU.EICR[index].B.LDEN1 = FALSE;
80006c2a:	b7 0f 01 fd 	insert %d15,%d15,0,26,1
80006c2e:	3c 03       	j 80006c34 <IfxScuEru_disableAutoClear+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.LDEN0 = FALSE;
80006c30:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80006c34:	68 0f       	st.w [%a15]0,%d15
80006c36:	00 90       	ret 

80006c38 <IfxScuEru_disableFallingEdgeDetection>:


void IfxScuEru_disableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006c38:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.FEN1 = FALSE;
80006c3c:	91 30 00 ff 	movh.a %a15,61443
80006c40:	1b 4f 08 f0 	addi %d15,%d15,132
80006c44:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006c48:	90 ff       	addsc.a %a15,%a15,%d15,2
80006c4a:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006c4c:	6f 04 05 00 	jz.t %d4,0,80006c56 <IfxScuEru_disableFallingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.FEN1 = FALSE;
80006c50:	b7 0f 01 fc 	insert %d15,%d15,0,24,1
80006c54:	3c 03       	j 80006c5a <IfxScuEru_disableFallingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.FEN0 = FALSE;
80006c56:	8f 0f d0 f1 	andn %d15,%d15,256
80006c5a:	68 0f       	st.w [%a15]0,%d15
80006c5c:	00 90       	ret 

80006c5e <IfxScuEru_disablePatternDetectionTrigger>:


void IfxScuEru_disablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006c5e:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = FALSE;
80006c62:	91 30 00 ff 	movh.a %a15,61443
80006c66:	1b bf 08 f0 	addi %d15,%d15,139
80006c6a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006c6e:	90 ff       	addsc.a %a15,%a15,%d15,2
80006c70:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006c72:	6f 04 05 00 	jz.t %d4,0,80006c7c <IfxScuEru_disablePatternDetectionTrigger+0x1e>
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = FALSE;
80006c76:	b7 0f 81 fe 	insert %d15,%d15,0,29,1
80006c7a:	3c 03       	j 80006c80 <IfxScuEru_disablePatternDetectionTrigger+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.GEEN0 = FALSE;
80006c7c:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80006c80:	68 0f       	st.w [%a15]0,%d15
80006c82:	00 90       	ret 

80006c84 <IfxScuEru_disableRisingEdgeDetection>:


void IfxScuEru_disableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006c84:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.REN1 = FALSE;
80006c88:	91 30 00 ff 	movh.a %a15,61443
80006c8c:	1b 4f 08 f0 	addi %d15,%d15,132
80006c90:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006c94:	90 ff       	addsc.a %a15,%a15,%d15,2
80006c96:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006c98:	6f 04 05 00 	jz.t %d4,0,80006ca2 <IfxScuEru_disableRisingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.REN1 = FALSE;
80006c9c:	b7 0f 81 fc 	insert %d15,%d15,0,25,1
80006ca0:	3c 03       	j 80006ca6 <IfxScuEru_disableRisingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.REN0 = FALSE;
80006ca2:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
80006ca6:	68 0f       	st.w [%a15]0,%d15
80006ca8:	00 90       	ret 

80006caa <IfxScuEru_disableTriggerPulse>:


void IfxScuEru_disableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006caa:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EIEN1 = FALSE;
80006cae:	91 30 00 ff 	movh.a %a15,61443
80006cb2:	1b 4f 08 f0 	addi %d15,%d15,132
80006cb6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006cba:	90 ff       	addsc.a %a15,%a15,%d15,2
80006cbc:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006cbe:	6f 04 05 00 	jz.t %d4,0,80006cc8 <IfxScuEru_disableTriggerPulse+0x1e>
    {
        MODULE_SCU.EICR[index].B.EIEN1 = FALSE;
80006cc2:	b7 0f 81 fd 	insert %d15,%d15,0,27,1
80006cc6:	3c 03       	j 80006ccc <IfxScuEru_disableTriggerPulse+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EIEN0 = FALSE;
80006cc8:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
80006ccc:	68 0f       	st.w [%a15]0,%d15
80006cce:	00 90       	ret 

80006cd0 <IfxScuEru_enableAutoClear>:


void IfxScuEru_enableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006cd0:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.LDEN1 = TRUE;
80006cd4:	91 30 00 ff 	movh.a %a15,61443
80006cd8:	1b 4f 08 f0 	addi %d15,%d15,132
80006cdc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006ce0:	90 ff       	addsc.a %a15,%a15,%d15,2
80006ce2:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006ce4:	6f 04 05 00 	jz.t %d4,0,80006cee <IfxScuEru_enableAutoClear+0x1e>
    {
        MODULE_SCU.EICR[index].B.LDEN1 = TRUE;
80006ce8:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80006cec:	3c 03       	j 80006cf2 <IfxScuEru_enableAutoClear+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.LDEN0 = TRUE;
80006cee:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80006cf2:	68 0f       	st.w [%a15]0,%d15
80006cf4:	00 90       	ret 

80006cf6 <IfxScuEru_enableFallingEdgeDetection>:


void IfxScuEru_enableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006cf6:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.FEN1 = TRUE;
80006cfa:	91 30 00 ff 	movh.a %a15,61443
80006cfe:	1b 4f 08 f0 	addi %d15,%d15,132
80006d02:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d06:	90 ff       	addsc.a %a15,%a15,%d15,2
80006d08:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006d0a:	6f 04 05 00 	jz.t %d4,0,80006d14 <IfxScuEru_enableFallingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.FEN1 = TRUE;
80006d0e:	b7 ff 01 fc 	insert %d15,%d15,15,24,1
80006d12:	3c 03       	j 80006d18 <IfxScuEru_enableFallingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.FEN0 = TRUE;
80006d14:	8f 0f 50 f1 	or %d15,%d15,256
80006d18:	68 0f       	st.w [%a15]0,%d15
80006d1a:	00 90       	ret 

80006d1c <IfxScuEru_enablePatternDetectionTrigger>:


void IfxScuEru_enablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d1c:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = TRUE;
80006d20:	91 30 00 ff 	movh.a %a15,61443
80006d24:	1b bf 08 f0 	addi %d15,%d15,139
80006d28:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d2c:	90 ff       	addsc.a %a15,%a15,%d15,2
80006d2e:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006d30:	6f 04 05 00 	jz.t %d4,0,80006d3a <IfxScuEru_enablePatternDetectionTrigger+0x1e>
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = TRUE;
80006d34:	b7 ff 81 fe 	insert %d15,%d15,15,29,1
80006d38:	3c 03       	j 80006d3e <IfxScuEru_enablePatternDetectionTrigger+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.GEEN0 = TRUE;
80006d3a:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
80006d3e:	68 0f       	st.w [%a15]0,%d15
80006d40:	00 90       	ret 

80006d42 <IfxScuEru_enableRisingEdgeDetection>:


void IfxScuEru_enableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d42:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.REN1 = TRUE;
80006d46:	91 30 00 ff 	movh.a %a15,61443
80006d4a:	1b 4f 08 f0 	addi %d15,%d15,132
80006d4e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d52:	90 ff       	addsc.a %a15,%a15,%d15,2
80006d54:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006d56:	6f 04 05 00 	jz.t %d4,0,80006d60 <IfxScuEru_enableRisingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.REN1 = TRUE;
80006d5a:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80006d5e:	3c 03       	j 80006d64 <IfxScuEru_enableRisingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.REN0 = TRUE;
80006d60:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
80006d64:	68 0f       	st.w [%a15]0,%d15
80006d66:	00 90       	ret 

80006d68 <IfxScuEru_enableTriggerPulse>:


void IfxScuEru_enableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d68:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EIEN1 = TRUE;
80006d6c:	91 30 00 ff 	movh.a %a15,61443
80006d70:	1b 4f 08 f0 	addi %d15,%d15,132
80006d74:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d78:	90 ff       	addsc.a %a15,%a15,%d15,2
80006d7a:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006d7c:	6f 04 05 00 	jz.t %d4,0,80006d86 <IfxScuEru_enableTriggerPulse+0x1e>
    {
        MODULE_SCU.EICR[index].B.EIEN1 = TRUE;
80006d80:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80006d84:	3c 03       	j 80006d8a <IfxScuEru_enableTriggerPulse+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EIEN0 = TRUE;
80006d86:	b7 ff 81 f5 	insert %d15,%d15,15,11,1
80006d8a:	68 0f       	st.w [%a15]0,%d15
80006d8c:	00 90       	ret 

80006d8e <IfxScuEru_getAllEventFlagsStatus>:
}


uint32 IfxScuEru_getAllEventFlagsStatus(void)
{
    return MODULE_SCU.EIFR.U;
80006d8e:	91 30 00 ff 	movh.a %a15,61443
80006d92:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d96:	19 f2 20 80 	ld.w %d2,[%a15]544 <f0030220 <_SMALL_DATA4_+0x40028220>>
}
80006d9a:	00 90       	ret 

80006d9c <IfxScuEru_getEventFlagStatus>:


boolean IfxScuEru_getEventFlagStatus(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = (1U << inputChannel);
    return (MODULE_SCU.EIFR.U & mask) ? TRUE : FALSE;
80006d9c:	91 30 00 ff 	movh.a %a15,61443
80006da0:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006da4:	19 f2 20 80 	ld.w %d2,[%a15]544 <f0030220 <_SMALL_DATA4_+0x40028220>>
}
80006da8:	57 02 61 24 	extr.u %d2,%d2,%d4,1
80006dac:	00 90       	ret 

80006dae <IfxScuEru_getInputChannelConfiguration>:


uint32 IfxScuEru_getInputChannelConfiguration(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006dae:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 status, mask = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.EICR[index].U & mask);
80006db2:	91 30 00 ff 	movh.a %a15,61443
80006db6:	1b 4f 08 f0 	addi %d15,%d15,132
80006dba:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006dbe:	90 ff       	addsc.a %a15,%a15,%d15,2
80006dc0:	48 02       	ld.w %d2,[%a15]0
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 status, mask = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006dc2:	6f 04 05 00 	jz.t %d4,0,80006dcc <IfxScuEru_getInputChannelConfiguration+0x1e>
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.EICR[index].U & mask);
80006dc6:	b7 02 10 20 	insert %d2,%d2,0,0,16
80006dca:	00 90       	ret 
    }
    else    // for channels 0, 2, 4 and 6
    {
        status = (MODULE_SCU.EICR[index].U & mask);
80006dcc:	b7 02 10 28 	insert %d2,%d2,0,16,16
    }

    return status;
}
80006dd0:	00 90       	ret 

80006dd2 <IfxScuEru_getOutputChannelConfiguration>:


uint32 IfxScuEru_getOutputChannelConfiguration(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006dd2:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 status, mask = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.IGCR[index].U & mask);
80006dd6:	91 30 00 ff 	movh.a %a15,61443
80006dda:	1b bf 08 f0 	addi %d15,%d15,139
80006dde:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006de2:	90 ff       	addsc.a %a15,%a15,%d15,2
80006de4:	48 02       	ld.w %d2,[%a15]0
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 status, mask = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006de6:	6f 04 05 00 	jz.t %d4,0,80006df0 <IfxScuEru_getOutputChannelConfiguration+0x1e>
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.IGCR[index].U & mask);
80006dea:	b7 02 10 20 	insert %d2,%d2,0,0,16
80006dee:	00 90       	ret 
    }
    else    // for channels 0, 2, 4 and 6
    {
        status = (MODULE_SCU.IGCR[index].U & mask);
80006df0:	b7 02 10 28 	insert %d2,%d2,0,16,16
    }

    return status;
}
80006df4:	00 90       	ret 

80006df6 <IfxScuEru_getPatternDetectionResult>:


boolean IfxScuEru_getPatternDetectionResult(IfxScuEru_OutputChannel outputChannel)
{
    uint32 mask = (1U << outputChannel);
    return (MODULE_SCU.PDRR.U & mask) ? TRUE : FALSE;
80006df6:	91 30 00 ff 	movh.a %a15,61443
80006dfa:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006dfe:	19 f2 28 80 	ld.w %d2,[%a15]552 <f0030228 <_SMALL_DATA4_+0x40028228>>
}
80006e02:	57 02 61 24 	extr.u %d2,%d2,%d4,1
80006e06:	00 90       	ret 

80006e08 <IfxScuEru_getWholePatternDetectionResult>:


uint32 IfxScuEru_getWholePatternDetectionResult(void)
{
    return MODULE_SCU.PDRR.U;
80006e08:	91 30 00 ff 	movh.a %a15,61443
80006e0c:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e10:	19 f2 28 80 	ld.w %d2,[%a15]552 <f0030228 <_SMALL_DATA4_+0x40028228>>
}
80006e14:	00 90       	ret 

80006e16 <IfxScuEru_selectExternalInput>:


void IfxScuEru_selectExternalInput(IfxScuEru_InputChannel inputChannel, IfxScuEru_ExternalInputSelection inputSignal)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e16:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EXIS1 = inputSignal;
80006e1a:	91 30 00 ff 	movh.a %a15,61443
80006e1e:	1b 4f 08 f0 	addi %d15,%d15,132
80006e22:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e26:	8f 75 00 51 	and %d5,%d5,7
80006e2a:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_selectExternalInput(IfxScuEru_InputChannel inputChannel, IfxScuEru_ExternalInputSelection inputSignal)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006e2c:	6f 04 08 00 	jz.t %d4,0,80006e3c <IfxScuEru_selectExternalInput+0x26>
    {
        MODULE_SCU.EICR[index].B.EXIS1 = inputSignal;
80006e30:	4c f0       	ld.w %d15,[%a15]0
80006e32:	8f 45 01 50 	sh %d5,%d5,20
80006e36:	b7 0f 03 fa 	insert %d15,%d15,0,20,3
80006e3a:	3c 05       	j 80006e44 <IfxScuEru_selectExternalInput+0x2e>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EXIS0 = inputSignal;
80006e3c:	4c f0       	ld.w %d15,[%a15]0
80006e3e:	06 45       	sh %d5,4
80006e40:	8f 0f c7 f1 	andn %d15,%d15,112
80006e44:	a6 f5       	or %d5,%d15
80006e46:	68 05       	st.w [%a15]0,%d5
80006e48:	00 90       	ret 

80006e4a <IfxScuEru_setEventFlag>:
}


void IfxScuEru_setEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << inputChannel;
80006e4a:	82 1f       	mov %d15,1
    SCU_FMR.U = mask;
80006e4c:	91 30 00 ff 	movh.a %a15,61443
}


void IfxScuEru_setEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << inputChannel;
80006e50:	0f 4f 00 40 	sh %d4,%d15,%d4
    SCU_FMR.U = mask;
80006e54:	d9 ff 24 86 	lea %a15,[%a15]25124 <f0036224 <_SMALL_DATA4_+0x4002e224>>
80006e58:	68 04       	st.w [%a15]0,%d4
80006e5a:	00 90       	ret 

80006e5c <IfxScuEru_setFlagPatternDetection>:
}


void IfxScuEru_setFlagPatternDetection(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InputChannel inputChannel, boolean state)
{
80006e5c:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 shift, mask;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD) // for channels 1, 3 ,5 and 7
80006e60:	6f 04 04 00 	jz.t %d4,0,80006e68 <IfxScuEru_setFlagPatternDetection+0xc>
    {
        shift = (inputChannel + 16);                  // offset at location IPEN10
80006e64:	1b 05 01 50 	addi %d5,%d5,16
80006e68:	06 2f       	sh %d15,2
80006e6a:	60 f2       	mov.a %a2,%d15
80006e6c:	d9 2f 00 06 	lea %a15,[%a2]24576
80006e70:	11 3f 00 ff 	addih.a %a15,%a15,61443
    {
        shift = inputChannel;
        mask  = (1 << shift);
        // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
        uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & ~mask) | ((uint32)state << shift);
80006e74:	19 ff 2c 80 	ld.w %d15,[%a15]556
80006e78:	d7 0f 01 f5 	insert %d15,%d15,0,%d5,1
80006e7c:	0f 56 00 50 	sh %d5,%d6,%d5
80006e80:	a6 f5       	or %d5,%d15
80006e82:	59 f5 2c 80 	st.w [%a15]556,%d5
80006e86:	00 90       	ret 

80006e88 <IfxScuEru_setInterruptGatingPattern>:


void IfxScuEru_setInterruptGatingPattern(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InterruptGatingPattern gatingPattern)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e88:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.IGP1 = gatingPattern;
80006e8c:	91 30 00 ff 	movh.a %a15,61443
80006e90:	1b bf 08 f0 	addi %d15,%d15,139
80006e94:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e98:	8f 35 00 51 	and %d5,%d5,3
80006e9c:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_setInterruptGatingPattern(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InterruptGatingPattern gatingPattern)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006e9e:	6f 04 06 00 	jz.t %d4,0,80006eaa <IfxScuEru_setInterruptGatingPattern+0x22>
    {
        MODULE_SCU.IGCR[index].B.IGP1 = gatingPattern;
80006ea2:	4c f0       	ld.w %d15,[%a15]0
80006ea4:	37 5f 02 5f 	insert %d5,%d15,%d5,30,2
80006ea8:	3c 07       	j 80006eb6 <IfxScuEru_setInterruptGatingPattern+0x2e>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.IGP0 = gatingPattern;
80006eaa:	4c f0       	ld.w %d15,[%a15]0
80006eac:	8f e5 00 50 	sh %d5,%d5,14
80006eb0:	b7 0f 02 f7 	insert %d15,%d15,0,14,2
80006eb4:	a6 f5       	or %d5,%d15
80006eb6:	68 05       	st.w [%a15]0,%d5
80006eb8:	00 90       	ret 

80006eba <IfxScuWdt_changeCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80006eba:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80006ebe:	16 07       	and %d15,7
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScuWdt_changeCpuWatchdogPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU_WDTCPU     *watchdog = &MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()];
80006ec0:	53 cf 20 f0 	mul %d15,%d15,12
80006ec4:	60 f2       	mov.a %a2,%d15
80006ec6:	d9 2f 00 46 	lea %a15,[%a2]24832
80006eca:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
80006ece:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80006ed0:	2e 16       	jz.t %d15,1,80006edc <IfxScuWdt_changeCpuWatchdogPassword+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80006ed2:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80006ed6:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
80006eda:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80006edc:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80006ee0:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
80006ee4:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
80006ee8:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80006eea:	4c f0       	ld.w %d15,[%a15]0
80006eec:	6f 0f ff 7f 	jz.t %d15,0,80006eea <IfxScuWdt_changeCpuWatchdogPassword+0x30>
    {}
}
80006ef0:	00 90       	ret 

80006ef2 <IfxScuWdt_changeCpuWatchdogReload>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80006ef2:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80006ef6:	16 07       	and %d15,7

void IfxScuWdt_changeCpuWatchdogReload(uint16 password, uint16 reload)
{
    /* Select CPU Watchdog based on Core Id */
    uint32              coreId = IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU     *wdt    = &MODULE_SCU.WDTCPU[coreId];
80006ef8:	53 cf 20 f0 	mul %d15,%d15,12
80006efc:	60 f2       	mov.a %a2,%d15
80006efe:	d9 2f 00 46 	lea %a15,[%a2]24832
80006f02:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
80006f06:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80006f08:	2e 16       	jz.t %d15,1,80006f14 <IfxScuWdt_changeCpuWatchdogReload+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80006f0a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80006f0e:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
80006f12:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80006f14:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80006f18:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
80006f1c:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
80006f20:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
80006f22:	4c f0       	ld.w %d15,[%a15]0
80006f24:	6f 0f ff 7f 	jz.t %d15,0,80006f22 <IfxScuWdt_changeCpuWatchdogReload+0x30>
    {}
}
80006f28:	00 90       	ret 

80006f2a <IfxScuWdt_changeSafetyWatchdogPassword>:
{
    Ifx_SCU_WDTS     *watchdog = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
80006f2a:	91 30 00 ff 	movh.a %a15,61443
80006f2e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006f32:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80006f34:	2e 16       	jz.t %d15,1,80006f40 <IfxScuWdt_changeSafetyWatchdogPassword+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80006f36:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80006f3a:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
80006f3e:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80006f40:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80006f44:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
80006f48:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
80006f4c:	91 30 00 ff 	movh.a %a15,61443
80006f50:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006f54:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80006f56:	4c f0       	ld.w %d15,[%a15]0
80006f58:	6f 0f ff 7f 	jz.t %d15,0,80006f56 <IfxScuWdt_changeSafetyWatchdogPassword+0x2c>
    {}
}
80006f5c:	00 90       	ret 

80006f5e <IfxScuWdt_changeSafetyWatchdogReload>:
    /* Initialize pointer to Safety Watchdog */
    Ifx_SCU_WDTS     *wdt = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
80006f5e:	91 30 00 ff 	movh.a %a15,61443
80006f62:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006f66:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80006f68:	2e 16       	jz.t %d15,1,80006f74 <IfxScuWdt_changeSafetyWatchdogReload+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80006f6a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80006f6e:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
80006f72:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80006f74:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80006f78:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
80006f7c:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
80006f80:	91 30 00 ff 	movh.a %a15,61443
80006f84:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006f88:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
80006f8a:	4c f0       	ld.w %d15,[%a15]0
80006f8c:	6f 0f ff 7f 	jz.t %d15,0,80006f8a <IfxScuWdt_changeSafetyWatchdogReload+0x2c>
    {}
}
80006f90:	00 90       	ret 

80006f92 <IfxScuWdt_clearCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80006f92:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80006f96:	16 07       	and %d15,7


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80006f98:	53 cf 20 f0 	mul %d15,%d15,12
80006f9c:	06 24       	sh %d4,2
80006f9e:	60 f2       	mov.a %a2,%d15
80006fa0:	d9 2f 00 46 	lea %a15,[%a2]24832
80006fa4:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80006fa8:	4c f0       	ld.w %d15,[%a15]0
80006faa:	2e 16       	jz.t %d15,1,80006fb6 <IfxScuWdt_clearCpuEndinit+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80006fac:	4c f0       	ld.w %d15,[%a15]0
80006fae:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80006fb2:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80006fb4:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80006fb6:	4c f0       	ld.w %d15,[%a15]0
80006fb8:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80006fbc:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80006fbe:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80006fc0:	4c f0       	ld.w %d15,[%a15]0
80006fc2:	6f 0f ff ff 	jnz.t %d15,0,80006fc0 <IfxScuWdt_clearCpuEndinit+0x2e>
}
80006fc6:	00 90       	ret 

80006fc8 <IfxScuWdt_clearSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80006fc8:	91 30 00 ff 	movh.a %a15,61443
80006fcc:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006fd0:	4c f0       	ld.w %d15,[%a15]0
80006fd2:	06 24       	sh %d4,2
80006fd4:	2e 16       	jz.t %d15,1,80006fe0 <IfxScuWdt_clearSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80006fd6:	4c f0       	ld.w %d15,[%a15]0
80006fd8:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80006fdc:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80006fde:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80006fe0:	91 30 00 ff 	movh.a %a15,61443
80006fe4:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006fe8:	4c f0       	ld.w %d15,[%a15]0
80006fea:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80006fee:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80006ff0:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80006ff2:	4c f0       	ld.w %d15,[%a15]0
80006ff4:	6f 0f ff ff 	jnz.t %d15,0,80006ff2 <IfxScuWdt_clearSafetyEndinit+0x2a>


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
}
80006ff8:	00 90       	ret 

80006ffa <IfxScuWdt_disableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80006ffa:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80006ffe:	16 07       	and %d15,7

void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
80007000:	53 cf 20 f0 	mul %d15,%d15,12
80007004:	06 24       	sh %d4,2
80007006:	60 f2       	mov.a %a2,%d15
80007008:	d9 2f 00 46 	lea %a15,[%a2]24832
8000700c:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007010:	4c f0       	ld.w %d15,[%a15]0
80007012:	2e 16       	jz.t %d15,1,8000701e <IfxScuWdt_disableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007014:	4c f0       	ld.w %d15,[%a15]0
80007016:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000701a:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000701c:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000701e:	4c f0       	ld.w %d15,[%a15]0
80007020:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007024:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007026:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80007028:	4c f0       	ld.w %d15,[%a15]0
8000702a:	6f 0f ff ff 	jnz.t %d15,0,80007028 <IfxScuWdt_disableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
8000702e:	4c f1       	ld.w %d15,[%a15]4
80007030:	96 08       	or %d15,8
80007032:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007034:	4c f0       	ld.w %d15,[%a15]0
80007036:	2e 16       	jz.t %d15,1,80007042 <IfxScuWdt_disableCpuWatchdog+0x48>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007038:	4c f0       	ld.w %d15,[%a15]0
8000703a:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000703e:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007040:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007042:	4c f0       	ld.w %d15,[%a15]0
80007044:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007048:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000704a:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000704c:	4c f0       	ld.w %d15,[%a15]0
8000704e:	6f 0f ff 7f 	jz.t %d15,0,8000704c <IfxScuWdt_disableCpuWatchdog+0x52>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80007052:	00 90       	ret 

80007054 <IfxScuWdt_disableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007054:	91 30 00 ff 	movh.a %a15,61443
80007058:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000705c:	4c f0       	ld.w %d15,[%a15]0
8000705e:	06 24       	sh %d4,2
80007060:	2e 16       	jz.t %d15,1,8000706c <IfxScuWdt_disableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007062:	4c f0       	ld.w %d15,[%a15]0
80007064:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007068:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000706a:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000706c:	91 30 00 ff 	movh.a %a15,61443
80007070:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007074:	4c f0       	ld.w %d15,[%a15]0

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80007076:	40 f2       	mov.aa %a2,%a15
80007078:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000707c:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000707e:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80007080:	4c 20       	ld.w %d15,[%a2]0
80007082:	91 30 00 ff 	movh.a %a15,61443
80007086:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000708a:	6f 0f fb ff 	jnz.t %d15,0,80007080 <IfxScuWdt_disableSafetyWatchdog+0x2c>


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
8000708e:	91 30 00 2f 	movh.a %a2,61443
80007092:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
80007096:	4c 20       	ld.w %d15,[%a2]0
80007098:	96 08       	or %d15,8
8000709a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000709c:	4c f0       	ld.w %d15,[%a15]0
8000709e:	2e 16       	jz.t %d15,1,800070aa <IfxScuWdt_disableSafetyWatchdog+0x56>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800070a0:	4c f0       	ld.w %d15,[%a15]0
800070a2:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800070a6:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800070a8:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800070aa:	91 30 00 ff 	movh.a %a15,61443
800070ae:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800070b2:	4c f0       	ld.w %d15,[%a15]0
800070b4:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800070b8:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800070ba:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800070bc:	4c f0       	ld.w %d15,[%a15]0
800070be:	6f 0f ff 7f 	jz.t %d15,0,800070bc <IfxScuWdt_disableSafetyWatchdog+0x68>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800070c2:	00 90       	ret 

800070c4 <IfxScuWdt_enableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800070c4:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800070c8:	16 07       	and %d15,7

void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
800070ca:	53 cf 20 f0 	mul %d15,%d15,12
800070ce:	06 24       	sh %d4,2
800070d0:	60 f2       	mov.a %a2,%d15
800070d2:	d9 2f 00 46 	lea %a15,[%a2]24832
800070d6:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800070da:	4c f0       	ld.w %d15,[%a15]0
800070dc:	2e 16       	jz.t %d15,1,800070e8 <IfxScuWdt_enableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800070de:	4c f0       	ld.w %d15,[%a15]0
800070e0:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800070e4:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800070e6:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800070e8:	4c f0       	ld.w %d15,[%a15]0
800070ea:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800070ee:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800070f0:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
800070f2:	4c f0       	ld.w %d15,[%a15]0
800070f4:	6f 0f ff ff 	jnz.t %d15,0,800070f2 <IfxScuWdt_enableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
800070f8:	4c f1       	ld.w %d15,[%a15]4
800070fa:	8f 8f c0 f1 	andn %d15,%d15,8
800070fe:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007100:	4c f0       	ld.w %d15,[%a15]0
80007102:	2e 16       	jz.t %d15,1,8000710e <IfxScuWdt_enableCpuWatchdog+0x4a>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007104:	4c f0       	ld.w %d15,[%a15]0
80007106:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000710a:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000710c:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000710e:	4c f0       	ld.w %d15,[%a15]0
80007110:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007114:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007116:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80007118:	4c f0       	ld.w %d15,[%a15]0
8000711a:	6f 0f ff 7f 	jz.t %d15,0,80007118 <IfxScuWdt_enableCpuWatchdog+0x54>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
8000711e:	00 90       	ret 

80007120 <IfxScuWdt_enableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007120:	91 30 00 ff 	movh.a %a15,61443
80007124:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007128:	4c f0       	ld.w %d15,[%a15]0
8000712a:	06 24       	sh %d4,2
8000712c:	2e 16       	jz.t %d15,1,80007138 <IfxScuWdt_enableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000712e:	4c f0       	ld.w %d15,[%a15]0
80007130:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007134:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007136:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007138:	91 30 00 ff 	movh.a %a15,61443
8000713c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007140:	4c f0       	ld.w %d15,[%a15]0

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80007142:	40 f2       	mov.aa %a2,%a15
80007144:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007148:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000714a:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000714c:	4c 20       	ld.w %d15,[%a2]0
8000714e:	91 30 00 ff 	movh.a %a15,61443
80007152:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007156:	6f 0f fb ff 	jnz.t %d15,0,8000714c <IfxScuWdt_enableSafetyWatchdog+0x2c>


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
8000715a:	91 30 00 2f 	movh.a %a2,61443
8000715e:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
80007162:	4c 20       	ld.w %d15,[%a2]0
80007164:	8f 8f c0 f1 	andn %d15,%d15,8
80007168:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000716a:	4c f0       	ld.w %d15,[%a15]0
8000716c:	2e 16       	jz.t %d15,1,80007178 <IfxScuWdt_enableSafetyWatchdog+0x58>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000716e:	4c f0       	ld.w %d15,[%a15]0
80007170:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007174:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007176:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007178:	91 30 00 ff 	movh.a %a15,61443
8000717c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007180:	4c f0       	ld.w %d15,[%a15]0
80007182:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007186:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007188:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000718a:	4c f0       	ld.w %d15,[%a15]0
8000718c:	6f 0f ff 7f 	jz.t %d15,0,8000718a <IfxScuWdt_enableSafetyWatchdog+0x6a>
    IfxScuWdt_setSafetyEndinitInline(password);
}
80007190:	00 90       	ret 

80007192 <IfxScuWdt_getCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80007192:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007196:	16 07       	and %d15,7


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
80007198:	53 cf 20 f0 	mul %d15,%d15,12
8000719c:	60 f2       	mov.a %a2,%d15
8000719e:	d9 2f 00 46 	lea %a15,[%a2]24832
800071a2:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
800071a6:	48 02       	ld.w %d2,[%a15]0
800071a8:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
800071ac:	8f f2 83 21 	xor %d2,%d2,63
800071b0:	00 90       	ret 

800071b2 <IfxScuWdt_getCpuWatchdogEndInit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800071b2:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800071b6:	16 07       	and %d15,7


boolean IfxScuWdt_getCpuWatchdogEndInit(void)
{
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
800071b8:	53 cf 20 f0 	mul %d15,%d15,12
800071bc:	60 f2       	mov.a %a2,%d15
800071be:	d9 2f 00 46 	lea %a15,[%a2]24832
800071c2:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog)
{
    return (boolean)watchdog->CON0.B.ENDINIT;
800071c6:	48 02       	ld.w %d2,[%a15]0
}
800071c8:	8f 12 00 21 	and %d2,%d2,1
800071cc:	00 90       	ret 

800071ce <IfxScuWdt_getSafetyWatchdogPassword>:
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
800071ce:	91 30 00 ff 	movh.a %a15,61443
800071d2:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800071d6:	48 02       	ld.w %d2,[%a15]0
800071d8:	37 02 6e 21 	extr.u %d2,%d2,2,14


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
800071dc:	8f f2 83 21 	xor %d2,%d2,63
800071e0:	00 90       	ret 

800071e2 <IfxScuWdt_initConfig>:


void IfxScuWdt_initConfig(IfxScuWdt_Config *config)
{
    config->password                      = IFXSCUWDT_RESET_PASSWORD;
800071e2:	da 3c       	mov %d15,60
800071e4:	ac 40       	st.h [%a4]0,%d15
    config->reload                        = 0xFFFC;
800071e6:	82 cf       	mov %d15,-4
800071e8:	ac 41       	st.h [%a4]2,%d15
    config->inputFrequency                = IfxScu_WDTCON1_IR_divBy16384;
800071ea:	82 0f       	mov %d15,0
800071ec:	2c 44       	st.b [%a4]4,%d15
    config->disableWatchdog               = FALSE;
800071ee:	2c 45       	st.b [%a4]5,%d15
    config->enableSmuRestriction          = FALSE;
800071f0:	2c 46       	st.b [%a4]6,%d15
    config->enableAutomaticPasswordChange = FALSE;
800071f2:	2c 47       	st.b [%a4]7,%d15
    config->enableTimerCheck              = FALSE;
800071f4:	2c 48       	st.b [%a4]8,%d15
    config->enableTimerCheckTolerance     = FALSE;
800071f6:	2c 49       	st.b [%a4]9,%d15
    config->clrInternalResetFlag          = FALSE;
800071f8:	2c 4a       	st.b [%a4]10,%d15
800071fa:	00 90       	ret 

800071fc <IfxScuWdt_setCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800071fc:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80007200:	16 07       	and %d15,7
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80007202:	53 cf 20 f0 	mul %d15,%d15,12
80007206:	06 24       	sh %d4,2
80007208:	60 f2       	mov.a %a2,%d15
8000720a:	d9 2f 00 46 	lea %a15,[%a2]24832
8000720e:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007212:	4c f0       	ld.w %d15,[%a15]0
80007214:	2e 16       	jz.t %d15,1,80007220 <IfxScuWdt_setCpuEndinit+0x24>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007216:	4c f0       	ld.w %d15,[%a15]0
80007218:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000721c:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000721e:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007220:	4c f0       	ld.w %d15,[%a15]0
80007222:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007226:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007228:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000722a:	4c f0       	ld.w %d15,[%a15]0
8000722c:	6f 0f ff 7f 	jz.t %d15,0,8000722a <IfxScuWdt_setCpuEndinit+0x2e>
}
80007230:	00 90       	ret 

80007232 <IfxScuWdt_initCpuWatchdog>:
{
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    Ifx_SCU_WDTCPU_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
80007232:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
80007234:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
80007236:	6f 12 0b 00 	jz.t %d2,1,8000724c <IfxScuWdt_initCpuWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000723a:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
8000723e:	37 02 6e 31 	extr.u %d3,%d2,2,14
80007242:	8f f3 83 31 	xor %d3,%d3,63
80007246:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
8000724a:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
8000724c:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
8000724e:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
80007252:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
80007256:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
8000725a:	b9 53 02 00 	ld.hu %d3,[%a5]2
8000725e:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
80007262:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
80007264:	54 42       	ld.w %d2,[%a4]
80007266:	6f 02 ff ff 	jnz.t %d2,0,80007264 <IfxScuWdt_initCpuWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
8000726a:	39 52 04 00 	ld.bu %d2,[%a5]4
8000726e:	df 12 0a 00 	jeq %d2,1,80007282 <IfxScuWdt_initCpuWatchdog+0x50>
80007272:	76 26       	jz %d2,8000727e <IfxScuWdt_initCpuWatchdog+0x4c>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
80007274:	8b 22 20 22 	ne %d2,%d2,2
80007278:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
8000727c:	3c 07       	j 8000728a <IfxScuWdt_initCpuWatchdog+0x58>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
8000727e:	82 0f       	mov %d15,0
        break;
80007280:	3c 05       	j 8000728a <IfxScuWdt_initCpuWatchdog+0x58>
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
80007282:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
80007286:	8f 0f c2 f1 	andn %d15,%d15,32
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR   = config->disableWatchdog ? 1 : 0;
8000728a:	39 52 05 00 	ld.bu %d2,[%a5]5
8000728e:	8b 02 20 22 	ne %d2,%d2,0
80007292:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR   = config->enableSmuRestriction ? 1 : 0;
80007296:	39 52 06 00 	ld.bu %d2,[%a5]6
8000729a:	8b 02 20 22 	ne %d2,%d2,0
8000729e:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR  = config->enableAutomaticPasswordChange ? 1 : 0;
800072a2:	39 52 07 00 	ld.bu %d2,[%a5]7
800072a6:	8b 02 20 22 	ne %d2,%d2,0
800072aa:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR  = config->enableTimerCheck ? 1 : 0;
800072ae:	39 52 08 00 	ld.bu %d2,[%a5]8
800072b2:	8b 02 20 22 	ne %d2,%d2,0
800072b6:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR = config->enableTimerCheckTolerance ? 1 : 0;
800072ba:	39 52 09 00 	ld.bu %d2,[%a5]9
800072be:	8b 02 20 22 	ne %d2,%d2,0
800072c2:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
800072c6:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set CPU ENDINIT protection */
    IfxScuWdt_setCpuEndinit(config->password);
800072c8:	b9 54 00 00 	ld.hu %d4,[%a5]0
800072cc:	1d ff 98 ff 	j 800071fc <IfxScuWdt_setCpuEndinit>

800072d0 <IfxScuWdt_serviceCpuWatchdog>:
}


void IfxScuWdt_serviceCpuWatchdog(uint16 password)
{
    IfxScuWdt_setCpuEndinit(password);
800072d0:	1d ff 96 ff 	j 800071fc <IfxScuWdt_setCpuEndinit>

800072d4 <IfxScuWdt_setSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800072d4:	91 30 00 ff 	movh.a %a15,61443
800072d8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800072dc:	4c f0       	ld.w %d15,[%a15]0
800072de:	06 24       	sh %d4,2
800072e0:	2e 16       	jz.t %d15,1,800072ec <IfxScuWdt_setSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800072e2:	4c f0       	ld.w %d15,[%a15]0
800072e4:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800072e8:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800072ea:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800072ec:	91 30 00 ff 	movh.a %a15,61443
800072f0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800072f4:	4c f0       	ld.w %d15,[%a15]0
800072f6:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800072fa:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800072fc:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800072fe:	4c f0       	ld.w %d15,[%a15]0
80007300:	6f 0f ff 7f 	jz.t %d15,0,800072fe <IfxScuWdt_setSafetyEndinit+0x2a>


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
    IfxScuWdt_setSafetyEndinitInline(password);
}
80007304:	00 90       	ret 

80007306 <IfxScuWdt_initSafetyWatchdog>:
{
    Ifx_SCU_WDTS_CON0 wdt_con0;
    Ifx_SCU_WDTS_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
80007306:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
80007308:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
8000730a:	6f 12 0b 00 	jz.t %d2,1,80007320 <IfxScuWdt_initSafetyWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000730e:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
80007312:	37 02 6e 31 	extr.u %d3,%d2,2,14
80007316:	8f f3 83 31 	xor %d3,%d3,63
8000731a:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
8000731e:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
80007320:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
80007322:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
80007326:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
8000732a:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
8000732e:	b9 53 02 00 	ld.hu %d3,[%a5]2
80007332:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
80007336:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
80007338:	54 42       	ld.w %d2,[%a4]
8000733a:	6f 02 ff ff 	jnz.t %d2,0,80007338 <IfxScuWdt_initSafetyWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
8000733e:	39 52 04 00 	ld.bu %d2,[%a5]4
80007342:	df 12 0a 00 	jeq %d2,1,80007356 <IfxScuWdt_initSafetyWatchdog+0x50>
80007346:	76 26       	jz %d2,80007352 <IfxScuWdt_initSafetyWatchdog+0x4c>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
80007348:	8b 22 20 22 	ne %d2,%d2,2
8000734c:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
80007350:	3c 07       	j 8000735e <IfxScuWdt_initSafetyWatchdog+0x58>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
80007352:	82 0f       	mov %d15,0
        break;
80007354:	3c 05       	j 8000735e <IfxScuWdt_initSafetyWatchdog+0x58>
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
80007356:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
8000735a:	8f 0f c2 f1 	andn %d15,%d15,32
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR     = config->disableWatchdog ? 1 : 0;
8000735e:	39 52 05 00 	ld.bu %d2,[%a5]5
80007362:	8b 02 20 22 	ne %d2,%d2,0
80007366:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR     = config->enableSmuRestriction ? 1 : 0;
8000736a:	39 52 06 00 	ld.bu %d2,[%a5]6
8000736e:	8b 02 20 22 	ne %d2,%d2,0
80007372:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR    = config->enableAutomaticPasswordChange ? 1 : 0;
80007376:	39 52 07 00 	ld.bu %d2,[%a5]7
8000737a:	8b 02 20 22 	ne %d2,%d2,0
8000737e:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR    = config->enableTimerCheck ? 1 : 0;
80007382:	39 52 08 00 	ld.bu %d2,[%a5]8
80007386:	8b 02 20 22 	ne %d2,%d2,0
8000738a:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR   = config->enableTimerCheckTolerance ? 1 : 0;
8000738e:	39 52 09 00 	ld.bu %d2,[%a5]9
80007392:	8b 02 20 22 	ne %d2,%d2,0
80007396:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7
    wdt_con1.B.CLRIRF = config->clrInternalResetFlag ? 0 : 1;
8000739a:	39 52 0a 00 	ld.bu %d2,[%a5]10
8000739e:	8b 02 00 22 	eq %d2,%d2,0
800073a2:	67 2f 00 f0 	ins.t %d15,%d15,0,%d2,0

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
800073a6:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set Safety ENDINIT protection */
    IfxScuWdt_setSafetyEndinit(config->password);
800073a8:	b9 54 00 00 	ld.hu %d4,[%a5]0
800073ac:	1d ff 94 ff 	j 800072d4 <IfxScuWdt_setSafetyEndinit>

800073b0 <IfxScuWdt_serviceSafetyWatchdog>:
}


void IfxScuWdt_serviceSafetyWatchdog(uint16 password)
{
    IfxScuWdt_setSafetyEndinit(password);
800073b0:	1d ff 92 ff 	j 800072d4 <IfxScuWdt_setSafetyEndinit>

800073b4 <IfxScuWdt_enableWatchdogWithDebugger>:
    volatile uint32 *oecPtr    = (volatile uint32 *)0xF0000478;
    volatile uint32 *ostatePtr = (volatile uint32 *)0xF0000480;
    volatile uint32 *ocntrlPtr = (volatile uint32 *)0xF000047C;

    /* read OSTATE.OEN */
    ostateValue = *ostatePtr;
800073b4:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
    oenEnabled  = (ostateValue & 0x00000001);

    if (!oenEnabled)
800073b8:	2e 07       	jz.t %d15,0,800073c6 <IfxScuWdt_enableWatchdogWithDebugger+0x12>
    }

    if (oenEnabled)
    {
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
800073ba:	3b 00 00 f3 	mov %d15,12288
800073be:	a5 ff 7c 10 	st.w f000047c <_SMALL_DATA4_+0x3fff847c>,%d15
}


boolean IfxScuWdt_enableWatchdogWithDebugger(void)
{
    boolean          status = 0, oenEnabled = 0, watchdogEnabled = 0;
800073c2:	82 0f       	mov %d15,0
800073c4:	3c 11       	j 800073e6 <IfxScuWdt_enableWatchdogWithDebugger+0x32>

    if (!oenEnabled)
    {
        /* enable the debug interface (OSTATE.OEN )if it is not already enabled */
        /* pattern for enabling OSTATE.OEN */
        *oecPtr = 0xA1;
800073c6:	3b 10 0a 20 	mov %d2,161
800073ca:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
800073ce:	da 5e       	mov %d15,94
800073d0:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15
        *oecPtr = 0xA1;
800073d4:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
800073d8:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15

        /* read OSTATE.OEN again*/
        ostateValue = *ostatePtr;
800073dc:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
        oenEnabled  = (ostateValue & 0x00000001);
    }

    if (oenEnabled)
800073e0:	6f 0f ed ff 	jnz.t %d15,0,800073ba <IfxScuWdt_enableWatchdogWithDebugger+0x6>
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
    }
    else
    {
        status = 1;
800073e4:	82 1f       	mov %d15,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, oenEnabled == 1);

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
800073e6:	85 f2 40 20 	ld.w %d2,f0000480 <_SMALL_DATA4_+0x3fff8480>
    watchdogEnabled = (ostateValue & 0x00000080);

    if (!watchdogEnabled)
800073ea:	37 02 e1 23 	extr.u %d2,%d2,7,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, watchdogEnabled == 1);

    return status;
}
800073ee:	ab 1f 80 22 	sel %d2,%d2,%d15,1
800073f2:	00 90       	ret 

800073f4 <IfxVadc_Adc_deInitGroup>:
    Ifx_VADC_G     *vadcG      = IfxVadc_Adc_getGroupRegsFromGroup(group);
    /* Get group index */
    IfxVadc_GroupId groupIndex = group->groupId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800073f4:	0c 48       	ld.bu %d15,[%a4]8
800073f6:	d4 4c       	ld.a %a12,[%a4]
800073f8:	1b 0f 01 f0 	addi %d15,%d15,16
800073fc:	16 ff       	and %d15,255
800073fe:	99 4d 04 00 	ld.a %a13,[%a4]4
80007402:	02 f4       	mov %d4,%d15
80007404:	40 c4       	mov.aa %a4,%a12
80007406:	6d ff 91 e8 	call 80004528 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_resetGroup(Ifx_VADC_G *vadcG)
{
    vadcG->ARBCFG.B.ANONC = IfxVadc_AnalogConverterMode_off;   /* turn off group */
8000740a:	54 d2       	ld.w %d2,[%a13]
    IfxVadc_resetGroup(vadcG);
    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
8000740c:	40 c4       	mov.aa %a4,%a12
8000740e:	8f 32 c0 21 	andn %d2,%d2,3
80007412:	74 d2       	st.w [%a13],%d2
80007414:	02 f4       	mov %d4,%d15
80007416:	1d ff 6d e8 	j 800044f0 <IfxVadc_disableAccess>

8000741a <IfxVadc_Adc_disableModule>:
}


void IfxVadc_Adc_disableModule(Ifx_VADC *vadc)
{
8000741a:	40 4f       	mov.aa %a15,%a4
}


IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000741c:	6d ff bb fe 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80007420:	02 24       	mov %d4,%d2
}


IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007422:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80007424:	6d ff b7 fd 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.B.DISR = 1;
80007428:	48 02       	ld.w %d2,[%a15]0
    IfxScuWdt_setCpuEndinit(passwd);
8000742a:	02 f4       	mov %d4,%d15

IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);
    vadc->CLC.B.DISR = 1;
8000742c:	8f 12 40 21 	or %d2,%d2,1
80007430:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80007432:	1d ff e5 fe 	j 800071fc <IfxScuWdt_setCpuEndinit>

80007436 <IfxVadc_Adc_getChannelConfig>:
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
    Ifx_VADC_G       *vadcG        = IfxVadc_Adc_getGroupRegsFromGroup(channel->group);
80007436:	99 42 04 00 	ld.a %a2,[%a4]4
8000743a:	99 2d 04 00 	ld.a %a13,[%a2]4
    IfxVadc_ChannelId channelIndex = channel->channel;
8000743e:	79 42 00 00 	ld.b %d2,[%a4]0

    config->channelId = channel->channel;
    config->group     = channel->group;
80007442:	b5 52 14 00 	st.a [%a5]20,%a2


IFX_INLINE Ifx_VADC_CHCTR IfxVadc_getChannelControlConfig(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U = vadcG->CHCTR[channelIndex].U;
80007446:	1b 02 06 f0 	addi %d15,%d2,96
8000744a:	90 d2       	addsc.a %a2,%a13,%d15,2
void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
    Ifx_VADC_G       *vadcG        = IfxVadc_Adc_getGroupRegsFromGroup(channel->group);
    IfxVadc_ChannelId channelIndex = channel->channel;

    config->channelId = channel->channel;
8000744c:	e9 52 0c 00 	st.b [%a5]12,%d2
80007450:	4c 20       	ld.w %d15,[%a2]0
    IfxVadc_disableModule(vadc);
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
80007452:	40 4c       	mov.aa %a12,%a4

    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U                 = 0;
    tempChctr                   = IfxVadc_getChannelControlConfig(vadcG, channelIndex);

    config->inputClass          = (IfxVadc_InputClasses)tempChctr.B.ICLSEL;
80007454:	37 0f 62 30 	extr.u %d3,%d15,0,2
    IfxVadc_disableModule(vadc);
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
80007458:	40 5f       	mov.aa %a15,%a5

    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U                 = 0;
    tempChctr                   = IfxVadc_getChannelControlConfig(vadcG, channelIndex);

    config->inputClass          = (IfxVadc_InputClasses)tempChctr.B.ICLSEL;
8000745a:	e9 53 0d 00 	st.b [%a5]13,%d3
    config->reference           = (IfxVadc_ChannelReference)tempChctr.B.REFSEL;
8000745e:	37 0f e1 35 	extr.u %d3,%d15,11,1
80007462:	e9 53 0e 00 	st.b [%a5]14,%d3
    config->resultRegister      = (IfxVadc_ChannelResult)tempChctr.B.RESREG;
80007466:	37 0f 64 38 	extr.u %d3,%d15,16,4
8000746a:	e9 53 0f 00 	st.b [%a5]15,%d3
    config->globalResultUsage   = tempChctr.B.RESTBS;
8000746e:	37 0f 61 3a 	extr.u %d3,%d15,20,1
80007472:	34 53       	st.b [%a5],%d3
    config->lowerBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELL;
80007474:	37 0f 62 32 	extr.u %d3,%d15,4,2
80007478:	e9 53 10 00 	st.b [%a5]16,%d3
    config->upperBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELU;
8000747c:	37 0f 62 33 	extr.u %d3,%d15,6,2
80007480:	e9 53 11 00 	st.b [%a5]17,%d3
    config->boundaryMode        = (IfxVadc_BoundaryExtension)tempChctr.B.BNDSELX;
80007484:	37 0f 64 36 	extr.u %d3,%d15,12,4
80007488:	e9 53 12 00 	st.b [%a5]18,%d3
    config->limitCheck          = (IfxVadc_LimitCheck)tempChctr.B.CHEVMODE;
8000748c:	37 0f 62 34 	extr.u %d3,%d15,8,2
80007490:	e9 53 13 00 	st.b [%a5]19,%d3
    config->synchonize          = tempChctr.B.SYNC;
80007494:	37 0f 61 35 	extr.u %d3,%d15,10,1
    config->rightAlignedStorage = tempChctr.B.RESPOS;
80007498:	37 0f e1 fa 	extr.u %d15,%d15,21,1
    config->globalResultUsage   = tempChctr.B.RESTBS;
    config->lowerBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELL;
    config->upperBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELU;
    config->boundaryMode        = (IfxVadc_BoundaryExtension)tempChctr.B.BNDSELX;
    config->limitCheck          = (IfxVadc_LimitCheck)tempChctr.B.CHEVMODE;
    config->synchonize          = tempChctr.B.SYNC;
8000749c:	e9 53 01 00 	st.b [%a5]1,%d3
    config->rightAlignedStorage = tempChctr.B.RESPOS;
800074a0:	2c 53       	st.b [%a5]3,%d15


IFX_INLINE Ifx_VADC_G_CHASS IfxVadc_getAssignedChannels(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_CHASS assignChannels;
    assignChannels.U = vadcG->CHASS.U;
800074a2:	4c d2       	ld.w %d15,[%a13]8

    config->backgroundChannel   = ((IfxVadc_getAssignedChannels(vadcG)).U & (1 << channelIndex)) ? FALSE : TRUE;
800074a4:	57 0f 61 22 	extr.u %d2,%d15,%d2,1
800074a8:	8f 12 80 21 	xor %d2,%d2,1
800074ac:	e9 52 02 00 	st.b [%a5]2,%d2
    uint32                 channelServiceRequestNodePtr;
    /* Get Channel index */
    IfxVadc_GroupId        groupIndex = channel->group->groupId;
800074b0:	99 42 04 00 	ld.a %a2,[%a4]4
    channelServiceRequestNodePtr = ((IfxVadc_getChannelServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
800074b4:	79 4f 00 00 	ld.b %d15,[%a4]0


IFX_INLINE Ifx_VADC_G_CEVNP0 IfxVadc_getChannelServiceRequestNodePointer0(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_CEVNP0 serviceRequestNodePtr;
    serviceRequestNodePtr.U = vadcG->CEVNP0.U;
800074b8:	19 d2 20 40 	ld.w %d2,[%a13]288
800074bc:	06 2f       	sh %d15,2
    volatile Ifx_SRC_SRCR *src        = IfxVadc_getSrcAddress(groupIndex, (IfxVadc_SrcNr)channelServiceRequestNodePtr);
800074be:	57 02 64 ff 	extr.u %d15,%d2,%d15,4
    config->rightAlignedStorage = tempChctr.B.RESPOS;

    config->backgroundChannel   = ((IfxVadc_getAssignedChannels(vadcG)).U & (1 << channelIndex)) ? FALSE : TRUE;
    uint32                 channelServiceRequestNodePtr;
    /* Get Channel index */
    IfxVadc_GroupId        groupIndex = channel->group->groupId;
800074c2:	39 28 08 00 	ld.bu %d8,[%a2]8
    channelServiceRequestNodePtr = ((IfxVadc_getChannelServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
    volatile Ifx_SRC_SRCR *src        = IfxVadc_getSrcAddress(groupIndex, (IfxVadc_SrcNr)channelServiceRequestNodePtr);
800074c6:	0b 8f 10 48 	mov %e4,%d15,%d8
800074ca:	6d ff 60 e9 	call 8000478a <IfxVadc_getSrcAddress>

    if (src->B.SRE == 1)
800074ce:	54 22       	ld.w %d2,[%a2]
800074d0:	6f a2 0a 00 	jz.t %d2,10,800074e4 <IfxVadc_Adc_getChannelConfig+0xae>
    {
        config->channelSrcNr        = (IfxVadc_SrcNr)channelServiceRequestNodePtr;
800074d4:	28 bf       	st.b [%a15]11,%d15
        config->channelPriority     = (Ifx_Priority)src->B.SRPN;
800074d6:	4c 20       	ld.w %d15,[%a2]0
800074d8:	16 ff       	and %d15,255
800074da:	a8 3f       	st.h [%a15]6,%d15
        config->channelServProvider = (IfxSrc_Tos)src->B.TOS;
800074dc:	4c 20       	ld.w %d15,[%a2]0
800074de:	37 0f e2 f5 	extr.u %d15,%d15,11,2
800074e2:	3c 05       	j 800074ec <IfxVadc_Adc_getChannelConfig+0xb6>
    }
    else
    {
        config->channelSrcNr        = (IfxVadc_SrcNr)0;
800074e4:	82 0f       	mov %d15,0
800074e6:	28 bf       	st.b [%a15]11,%d15
        config->channelPriority     = (Ifx_Priority)0;
800074e8:	82 0f       	mov %d15,0
800074ea:	a8 3f       	st.h [%a15]6,%d15
        config->channelServProvider = (IfxSrc_Tos)0;
800074ec:	28 9f       	st.b [%a15]9,%d15
    }

    uint32 resultServiceRequestNodePtr;

    if (config->resultRegister < IfxVadc_ChannelResult_8)
800074ee:	0c ff       	ld.bu %d15,[%a15]15
800074f0:	79 c2 00 00 	ld.b %d2,[%a12]0
800074f4:	ff 8f 08 80 	jge.u %d15,8,80007504 <IfxVadc_Adc_getChannelConfig+0xce>


IFX_INLINE Ifx_VADC_G_REVNP0 IfxVadc_getChannelResultServiceRequestNodePointer0(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_REVNP0 resultServiceRequestNodePtr0;
    resultServiceRequestNodePtr0.U = vadcG->REVNP0.U;
800074f8:	19 df 30 40 	ld.w %d15,[%a13]304
    {
        resultServiceRequestNodePtr = ((IfxVadc_getChannelResultServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
800074fc:	06 22       	sh %d2,2
800074fe:	57 0f 64 f2 	extr.u %d15,%d15,%d2,4
80007502:	3c 08       	j 80007512 <IfxVadc_Adc_getChannelConfig+0xdc>
    }
    else
    {
        resultServiceRequestNodePtr = ((IfxVadc_getChannelResultServiceRequestNodePointer1(vadcG)).U >> ((channel->channel - IfxVadc_ChannelResult_8) * 4)) & 0xF;
80007504:	9a 82       	add %d15,%d2,-8


IFX_INLINE Ifx_VADC_G_REVNP1 IfxVadc_getChannelResultServiceRequestNodePointer1(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_REVNP1 resultServiceRequestNodePtr1;
    resultServiceRequestNodePtr1.U = vadcG->REVNP1.U;
80007506:	19 d3 34 40 	ld.w %d3,[%a13]308
8000750a:	8f 2f 00 20 	sh %d2,%d15,2
8000750e:	57 03 64 f2 	extr.u %d15,%d3,%d2,4
    }

    src = IfxVadc_getSrcAddress(groupIndex, resultServiceRequestNodePtr);
80007512:	16 ff       	and %d15,255
80007514:	0b 8f 10 48 	mov %e4,%d15,%d8
80007518:	6d ff 39 e9 	call 8000478a <IfxVadc_getSrcAddress>

    if (src->B.SRE == 1)
8000751c:	54 22       	ld.w %d2,[%a2]
8000751e:	6f a2 0a 00 	jz.t %d2,10,80007532 <IfxVadc_Adc_getChannelConfig+0xfc>
    {
        config->resultSrcNr        = (IfxVadc_SrcNr)resultServiceRequestNodePtr;
80007522:	28 af       	st.b [%a15]10,%d15
        config->resultPriority     = (Ifx_Priority)src->B.SRPN;
80007524:	4c 20       	ld.w %d15,[%a2]0
80007526:	16 ff       	and %d15,255
80007528:	a8 2f       	st.h [%a15]4,%d15
        config->resultServProvider = (IfxSrc_Tos)src->B.TOS;
8000752a:	4c 20       	ld.w %d15,[%a2]0
8000752c:	37 0f e2 f5 	extr.u %d15,%d15,11,2
80007530:	3c 05       	j 8000753a <IfxVadc_Adc_getChannelConfig+0x104>
    }
    else
    {
        config->resultSrcNr        = (IfxVadc_SrcNr)0;
80007532:	82 0f       	mov %d15,0
80007534:	28 af       	st.b [%a15]10,%d15
        config->resultPriority     = (Ifx_Priority)0;
80007536:	82 0f       	mov %d15,0
80007538:	a8 2f       	st.h [%a15]4,%d15
        config->resultServProvider = (IfxSrc_Tos)0;
8000753a:	28 8f       	st.b [%a15]8,%d15
8000753c:	00 90       	ret 

8000753e <IfxVadc_Adc_getChannelConversionTime>:
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
8000753e:	cc 41       	ld.a %a15,[%a4]4
80007540:	c8 12       	ld.a %a2,[%a15]4
}


IFX_INLINE IfxVadc_InputClasses IfxVadc_getChannelInputClass(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    return (IfxVadc_InputClasses)vadcG->CHCTR[channelIndex].B.ICLSEL;
80007542:	79 4f 00 00 	ld.b %d15,[%a4]0
80007546:	08 8a       	ld.bu %d10,[%a15]8
80007548:	c8 0f       	ld.a %a15,[%a15]0
8000754a:	1b 0f 06 f0 	addi %d15,%d15,96
8000754e:	90 22       	addsc.a %a2,%a2,%d15,2
    }
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
80007550:	20 08       	sub.a %sp,8
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
80007552:	40 f4       	mov.aa %a4,%a15
    }
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
80007554:	02 49       	mov %d9,%d4
80007556:	54 28       	ld.w %d8,[%a2]
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
80007558:	6d ff 9a e8 	call 8000468c <IfxVadc_getAdcAnalogFrequency>
8000755c:	02 2f       	mov %d15,%d2
8000755e:	6d ff b0 e8 	call 800046be <IfxVadc_getAdcModuleFrequency>
80007562:	8f 38 00 81 	and %d8,%d8,3
80007566:	74 a9       	st.w [%sp],%d9
80007568:	40 f4       	mov.aa %a4,%a15
8000756a:	0b a8 10 48 	mov %e4,%d8,%d10
8000756e:	0b f2 10 68 	mov %e6,%d2,%d15
}
80007572:	1d ff c1 e9 	j 800048f4 <IfxVadc_getChannelConversionTime>

80007576 <IfxVadc_Adc_getGroupConfig>:

void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
80007576:	d4 4d       	ld.a %a13,[%a4]
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
}


void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
80007578:	40 4e       	mov.aa %a14,%a4
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
8000757a:	99 4c 04 00 	ld.a %a12,[%a4]4
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
8000757e:	40 d4       	mov.aa %a4,%a13
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
}


void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
80007580:	40 5f       	mov.aa %a15,%a5
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007582:	6d ff 85 e8 	call 8000468c <IfxVadc_getAdcAnalogFrequency>

    config->groupId                    = group->groupId;
80007586:	0c e8       	ld.bu %d15,[%a14]8
    config->module                     = &group->module;
80007588:	e8 0e       	st.a [%a15]0,%a14
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);

    config->groupId                    = group->groupId;
8000758a:	28 4f       	st.b [%a15]4,%d15
}


IFX_INLINE IfxVadc_ArbitrationRounds IfxVadc_getArbiterRoundLength(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_ArbitrationRounds)vadcG->ARBCFG.B.ARBRND;
8000758c:	4c c0       	ld.w %d15,[%a12]0
8000758e:	37 0f 62 f2 	extr.u %d15,%d15,4,2
    config->module                     = &group->module;

    config->arbiter.arbiterRoundLength = IfxVadc_getArbiterRoundLength(vadcG);
80007592:	e9 ff 32 00 	st.b [%a15]50,%d15
80007596:	82 0f       	mov %d15,0
}


IFX_INLINE IfxVadc_ChannelResolution IfxVadc_getGroupResolution(Ifx_VADC_G *vadcG, uint8 inputClassNum)
{
    return (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
80007598:	1b 8f 00 30 	addi %d3,%d15,8
8000759c:	01 c3 02 26 	addsc.a %a2,%a12,%d3,2

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
    {
        config->inputClass[inputClassNum].resolution = IfxVadc_getGroupResolution(vadcG, inputClassNum);
800075a0:	d0 f3       	addsc.a %a3,%a15,%d15,3
800075a2:	54 23       	ld.w %d3,[%a2]
800075a4:	37 03 63 34 	extr.u %d3,%d3,8,3
800075a8:	e9 33 0c 00 	st.b [%a3]12,%d3
}


IFX_INLINE float32 IfxVadc_getGroupSampleTime(Ifx_VADC_G *vadcG, uint8 inputClassNum, float32 analogFrequency)
{
    uint32 sampleTime = vadcG->ICLASS[inputClassNum].B.STCS;
800075ac:	54 23       	ld.w %d3,[%a2]
800075ae:	8f f3 01 31 	and %d3,%d3,31

    if (sampleTime > 16)
800075b2:	8b 13 61 42 	lt.u %d4,%d3,17
800075b6:	f6 44       	jnz %d4,800075be <IfxVadc_Adc_getGroupConfig+0x48>
    {
        sampleTime = (sampleTime - 15) * 16;
800075b8:	1b 13 ff 3f 	addi %d3,%d3,-15
800075bc:	06 43       	sh %d3,4
    }

    return (float32)(IFXVADC_SAMPLETIME_MIN + sampleTime) / analogFrequency;
800075be:	c2 23       	add %d3,2
800075c0:	4b 03 41 31 	itof %d3,%d3
        config->inputClass[inputClassNum].sampleTime = IfxVadc_getGroupSampleTime(vadcG, inputClassNum, analogFrequency);
800075c4:	92 14       	add %d4,%d15,1
800075c6:	4b 23 51 30 	div.f %d3,%d3,%d2
800075ca:	01 f4 03 26 	addsc.a %a2,%a15,%d4,3
800075ce:	74 23       	st.w [%a2],%d3
    config->groupId                    = group->groupId;
    config->module                     = &group->module;

    config->arbiter.arbiterRoundLength = IfxVadc_getArbiterRoundLength(vadcG);

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
800075d0:	1e 13       	jeq %d15,1,800075d6 <IfxVadc_Adc_getGroupConfig+0x60>
800075d2:	82 1f       	mov %d15,1
800075d4:	3c e2       	j 80007598 <IfxVadc_Adc_getGroupConfig+0x22>
}


IFX_INLINE boolean IfxVadc_isRequestScanSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN1;
800075d6:	19 c2 04 00 	ld.w %d2,[%a12]4
    {
        config->inputClass[inputClassNum].resolution = IfxVadc_getGroupResolution(vadcG, inputClassNum);
        config->inputClass[inputClassNum].sampleTime = IfxVadc_getGroupSampleTime(vadcG, inputClassNum, analogFrequency);
    }

    if (IfxVadc_isRequestScanSlotEnabled(vadcG) == TRUE)
800075da:	ef 92 33 00 	jz.t %d2,25,80007640 <IfxVadc_Adc_getGroupConfig+0xca>
    {
        config->arbiter.requestSlotScanEnabled          = TRUE;
800075de:	e9 ff 34 00 	st.b [%a15]52,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getScanSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO1;
800075e2:	19 c2 04 00 	ld.w %d2,[%a12]4
800075e6:	37 02 62 22 	extr.u %d2,%d2,4,2
        config->scanRequest.requestSlotPrio             = IfxVadc_getScanSlotPriority(vadcG);
800075ea:	e9 f2 1e 00 	st.b [%a15]30,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getScanSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM1;
800075ee:	19 c2 04 00 	ld.w %d2,[%a12]4
800075f2:	37 02 e1 23 	extr.u %d2,%d2,7,1
        config->scanRequest.requestSlotStartMode        = IfxVadc_getScanSlotStartMode(vadcG);
800075f6:	e9 f2 1f 00 	st.b [%a15]31,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getScanSlotTriggerInput(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerSource)vadcG->ASCTRL.B.XTSEL;
800075fa:	19 c3 20 20 	ld.w %d3,[%a12]160
800075fe:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->scanRequest.triggerConfig.triggerSource = IfxVadc_getScanSlotTriggerInput(vadcG);
80007602:	e9 f3 1b 00 	st.b [%a15]27,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getScanSlotTriggerMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerMode)vadcG->ASCTRL.B.XTMODE;
80007606:	19 c2 20 20 	ld.w %d2,[%a12]160
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_getScanSlotTriggerMode(vadcG);

        if (config->scanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
8000760a:	8b f3 00 32 	eq %d3,%d3,15
8000760e:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotScanEnabled          = TRUE;
        config->scanRequest.requestSlotPrio             = IfxVadc_getScanSlotPriority(vadcG);
        config->scanRequest.requestSlotStartMode        = IfxVadc_getScanSlotStartMode(vadcG);

        config->scanRequest.triggerConfig.triggerSource = IfxVadc_getScanSlotTriggerInput(vadcG);
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_getScanSlotTriggerMode(vadcG);
80007612:	e9 f2 1d 00 	st.b [%a15]29,%d2

        if (config->scanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007616:	f6 35       	jnz %d3,80007620 <IfxVadc_Adc_getGroupConfig+0xaa>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getScanSlotGatingMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingMode)vadcG->ASMR.B.ENGT;
80007618:	19 cf 24 20 	ld.w %d15,[%a12]164
8000761c:	16 03       	and %d15,3
8000761e:	3c 02       	j 80007622 <IfxVadc_Adc_getGroupConfig+0xac>
        {
            config->scanRequest.triggerConfig.gatingMode = IfxVadc_getScanSlotGatingMode(vadcG);
        }
        else if (config->scanRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007620:	76 23       	jz %d2,80007626 <IfxVadc_Adc_getGroupConfig+0xb0>
        {
            config->scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
80007622:	e9 ff 1c 00 	st.b [%a15]28,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getScanSlotGatingSource(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingSource)vadcG->ASCTRL.B.GTSEL;
80007626:	19 cf 20 20 	ld.w %d15,[%a12]160
8000762a:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->scanRequest.triggerConfig.gatingSource = IfxVadc_getScanSlotGatingSource(vadcG);
8000762e:	e9 ff 1a 00 	st.b [%a15]26,%d15
}


IFX_INLINE boolean IfxVadc_isAutoScanEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ASMR.B.SCAN;
80007632:	19 cf 24 20 	ld.w %d15,[%a12]164
80007636:	37 0f 61 f2 	extr.u %d15,%d15,4,1
        config->scanRequest.autoscanEnabled            = IfxVadc_isAutoScanEnabled(vadcG);
8000763a:	e9 ff 18 00 	st.b [%a15]24,%d15
8000763e:	3c 0c       	j 80007656 <IfxVadc_Adc_getGroupConfig+0xe0>
    }
    else
    {
        config->scanRequest.autoscanEnabled             = FALSE;
80007640:	82 0f       	mov %d15,0
80007642:	e9 ff 18 00 	st.b [%a15]24,%d15
        config->scanRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
80007646:	e9 ff 1c 00 	st.b [%a15]28,%d15
        config->scanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;    /* Use CCU6061 TRIG0 */
8000764a:	e9 ff 1a 00 	st.b [%a15]26,%d15
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
8000764e:	e9 ff 1d 00 	st.b [%a15]29,%d15
        config->scanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;   /* Trigger source taken from Gating Input */
80007652:	e9 ff 1b 00 	st.b [%a15]27,%d15
}


IFX_INLINE boolean IfxVadc_isRequestQueueSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN0;
80007656:	4c c1       	ld.w %d15,[%a12]4
80007658:	37 0f 61 fc 	extr.u %d15,%d15,24,1
    }

    if (IfxVadc_isRequestQueueSlotEnabled(vadcG) == TRUE)
8000765c:	df 1f 30 80 	jne %d15,1,800076bc <IfxVadc_Adc_getGroupConfig+0x146>
    {
        config->arbiter.requestSlotQueueEnabled          = TRUE;
80007660:	e9 ff 33 00 	st.b [%a15]51,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getQueueSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO0;
80007664:	19 c2 04 00 	ld.w %d2,[%a12]4
80007668:	8f 32 00 21 	and %d2,%d2,3
        config->queueRequest.requestSlotPrio             = IfxVadc_getQueueSlotPriority(vadcG);
8000766c:	e9 f2 26 00 	st.b [%a15]38,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getQueueSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM0;
80007670:	19 c2 04 00 	ld.w %d2,[%a12]4
80007674:	37 02 e1 21 	extr.u %d2,%d2,3,1
        config->queueRequest.requestSlotStartMode        = IfxVadc_getQueueSlotStartMode(vadcG);
80007678:	e9 f2 27 00 	st.b [%a15]39,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getQueueSlotTriggerInput(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerSource)vadcG->QCTRL0.B.XTSEL;
8000767c:	19 c3 00 20 	ld.w %d3,[%a12]128
80007680:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->queueRequest.triggerConfig.triggerSource = IfxVadc_getQueueSlotTriggerInput(vadcG);
80007684:	e9 f3 23 00 	st.b [%a15]35,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getQueueSlotTriggerMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerMode)vadcG->QCTRL0.B.XTMODE;
80007688:	19 c2 00 20 	ld.w %d2,[%a12]128
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_getQueueSlotTriggerMode(vadcG);

        if (config->queueRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
8000768c:	8b f3 00 32 	eq %d3,%d3,15
80007690:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotQueueEnabled          = TRUE;
        config->queueRequest.requestSlotPrio             = IfxVadc_getQueueSlotPriority(vadcG);
        config->queueRequest.requestSlotStartMode        = IfxVadc_getQueueSlotStartMode(vadcG);

        config->queueRequest.triggerConfig.triggerSource = IfxVadc_getQueueSlotTriggerInput(vadcG);
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_getQueueSlotTriggerMode(vadcG);
80007694:	e9 f2 25 00 	st.b [%a15]37,%d2

        if (config->queueRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007698:	f6 35       	jnz %d3,800076a2 <IfxVadc_Adc_getGroupConfig+0x12c>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getQueueSlotGatingMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingMode)vadcG->QMR0.B.ENGT;
8000769a:	19 cf 04 20 	ld.w %d15,[%a12]132
8000769e:	16 03       	and %d15,3
800076a0:	3c 02       	j 800076a4 <IfxVadc_Adc_getGroupConfig+0x12e>
        {
            config->queueRequest.triggerConfig.gatingMode = IfxVadc_getQueueSlotGatingMode(vadcG);
        }
        else if (config->queueRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
800076a2:	76 23       	jz %d2,800076a8 <IfxVadc_Adc_getGroupConfig+0x132>
        {
            config->queueRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
800076a4:	e9 ff 24 00 	st.b [%a15]36,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getQueueSlotGatingSource(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingSource)vadcG->QCTRL0.B.GTSEL;
800076a8:	19 cf 00 20 	ld.w %d15,[%a12]128
800076ac:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->queueRequest.triggerConfig.gatingSource = IfxVadc_getQueueSlotGatingSource(vadcG);
800076b0:	e9 ff 22 00 	st.b [%a15]34,%d15
        config->queueRequest.flushQueueAfterInit        = FALSE;
800076b4:	82 0f       	mov %d15,0
800076b6:	e9 ff 20 00 	st.b [%a15]32,%d15
800076ba:	3c 0c       	j 800076d2 <IfxVadc_Adc_getGroupConfig+0x15c>
    }
    else
    {
        config->queueRequest.flushQueueAfterInit         = FALSE;
800076bc:	82 0f       	mov %d15,0
800076be:	e9 ff 20 00 	st.b [%a15]32,%d15
        config->queueRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
800076c2:	e9 ff 24 00 	st.b [%a15]36,%d15
        config->queueRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;        /* Use CCU6061 TRIG0 */
800076c6:	e9 ff 22 00 	st.b [%a15]34,%d15
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
800076ca:	e9 ff 25 00 	st.b [%a15]37,%d15
        config->queueRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;       /* Trigger source taken from Gating Input */
800076ce:	e9 ff 23 00 	st.b [%a15]35,%d15
}


IFX_INLINE boolean IfxVadc_isRequestBackgroundScanSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN2;
800076d2:	4c c1       	ld.w %d15,[%a12]4
800076d4:	37 0f 61 fd 	extr.u %d15,%d15,26,1
    }

    if (IfxVadc_isRequestBackgroundScanSlotEnabled(vadcG) == TRUE)
800076d8:	df 1f 33 80 	jne %d15,1,8000773e <IfxVadc_Adc_getGroupConfig+0x1c8>
    {
        config->arbiter.requestSlotBackgroundScanEnabled          = TRUE;
800076dc:	e9 ff 35 00 	st.b [%a15]53,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getBackgroundScanSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO2;
800076e0:	19 c2 04 00 	ld.w %d2,[%a12]4
800076e4:	37 02 62 24 	extr.u %d2,%d2,8,2
        config->backgroundScanRequest.requestSlotPrio             = IfxVadc_getBackgroundScanSlotPriority(vadcG);
800076e8:	e9 f2 2e 00 	st.b [%a15]46,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getBackgroundScanSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM2;
800076ec:	19 c2 04 00 	ld.w %d2,[%a12]4
800076f0:	37 02 e1 25 	extr.u %d2,%d2,11,1
        config->backgroundScanRequest.requestSlotStartMode        = IfxVadc_getBackgroundScanSlotStartMode(vadcG);
800076f4:	e9 f2 2f 00 	st.b [%a15]47,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getBackgroundScanTriggerInput(Ifx_VADC *vadc)
{
    return (IfxVadc_TriggerSource)vadc->BRSCTRL.B.XTSEL;
800076f8:	19 d3 00 80 	ld.w %d3,[%a13]512
800076fc:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_getBackgroundScanTriggerInput(vadc);
80007700:	e9 f3 2b 00 	st.b [%a15]43,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getBackgroundScanTriggerMode(Ifx_VADC *vadc)
{
    return (IfxVadc_TriggerMode)vadc->BRSCTRL.B.XTMODE;
80007704:	19 d2 00 80 	ld.w %d2,[%a13]512
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_getBackgroundScanTriggerMode(vadc);

        if (config->backgroundScanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007708:	8b f3 00 32 	eq %d3,%d3,15
8000770c:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotBackgroundScanEnabled          = TRUE;
        config->backgroundScanRequest.requestSlotPrio             = IfxVadc_getBackgroundScanSlotPriority(vadcG);
        config->backgroundScanRequest.requestSlotStartMode        = IfxVadc_getBackgroundScanSlotStartMode(vadcG);

        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_getBackgroundScanTriggerInput(vadc);
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_getBackgroundScanTriggerMode(vadc);
80007710:	e9 f2 2d 00 	st.b [%a15]45,%d2

        if (config->backgroundScanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007714:	f6 35       	jnz %d3,8000771e <IfxVadc_Adc_getGroupConfig+0x1a8>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getBackgroundScanGatingMode(Ifx_VADC *vadc)
{
    return (IfxVadc_GatingMode)vadc->BRSMR.B.ENGT;
80007716:	19 df 04 80 	ld.w %d15,[%a13]516
8000771a:	16 03       	and %d15,3
8000771c:	3c 02       	j 80007720 <IfxVadc_Adc_getGroupConfig+0x1aa>
        {
            config->backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_getBackgroundScanGatingMode(vadc);
        }
        else if (config->backgroundScanRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
8000771e:	76 23       	jz %d2,80007724 <IfxVadc_Adc_getGroupConfig+0x1ae>
        {
            config->backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
80007720:	e9 ff 2c 00 	st.b [%a15]44,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getBackgroundScanGatingSource(Ifx_VADC *vadc)
{
    return (IfxVadc_GatingSource)vadc->BRSCTRL.B.GTSEL;
80007724:	19 df 00 80 	ld.w %d15,[%a13]512
80007728:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->backgroundScanRequest.triggerConfig.gatingSource = IfxVadc_getBackgroundScanGatingSource(vadc);
8000772c:	e9 ff 2a 00 	st.b [%a15]42,%d15
}


IFX_INLINE boolean IfxVadc_isAutoBackgroundScanEnabled(Ifx_VADC *vadc)
{
    return (boolean)vadc->BRSMR.B.SCAN;
80007730:	19 df 04 80 	ld.w %d15,[%a13]516
80007734:	37 0f 61 f2 	extr.u %d15,%d15,4,1
        config->backgroundScanRequest.autoBackgroundScanEnabled  = IfxVadc_isAutoBackgroundScanEnabled(vadc);
80007738:	e9 ff 28 00 	st.b [%a15]40,%d15
8000773c:	3c 0c       	j 80007754 <IfxVadc_Adc_getGroupConfig+0x1de>
    }
    else
    {
        config->backgroundScanRequest.autoBackgroundScanEnabled   = FALSE;
8000773e:	82 0f       	mov %d15,0
80007740:	e9 ff 28 00 	st.b [%a15]40,%d15
        config->backgroundScanRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
80007744:	e9 ff 2c 00 	st.b [%a15]44,%d15
        config->backgroundScanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;  /* Use CCU6061 TRIG0 */
80007748:	e9 ff 2a 00 	st.b [%a15]42,%d15
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
8000774c:	e9 ff 2d 00 	st.b [%a15]45,%d15
        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0; /* Trigger source taken from Gating Input */
80007750:	e9 ff 2b 00 	st.b [%a15]43,%d15


IFX_INLINE uint8 IfxVadc_getMasterIndex(Ifx_VADC_G *vadcG)
{
    uint8 masterIndex = 0;
    masterIndex = vadcG->SYNCTR.B.STSEL;
80007754:	19 c3 00 10 	ld.w %d3,[%a12]64
    }

    config->master                 = IfxVadc_Adc_getMasterId(group->groupId, IfxVadc_getMasterIndex(vadcG));
80007758:	39 e7 08 00 	ld.bu %d7,[%a14]8
8000775c:	8f 33 00 31 	and %d3,%d3,3
80007760:	02 72       	mov %d2,%d7
IFX_INLINE IfxVadc_GroupId IfxVadc_Adc_getMasterId(IfxVadc_GroupId slave, IfxVadc_Adc_SYNCTR_STSEL masterIndex)
{
    uint8           i, idxOffset;
    IfxVadc_GroupId masterId = slave;

    if (masterIndex == 0)
80007762:	df 03 1f 00 	jeq %d3,0,800077a0 <IfxVadc_Adc_getGroupConfig+0x22a>
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
80007766:	7b 00 00 58 	movh %d5,32768
8000776a:	1b 45 d6 50 	addi %d5,%d5,3428
8000776e:	13 87 20 55 	madd %d5,%d5,%d7,8
    {
        masterId = slave;
    }
    else
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */
80007772:	8b 47 60 42 	lt.u %d4,%d7,4
80007776:	82 02       	mov %d2,0
80007778:	ab 42 80 24 	sel %d2,%d4,%d2,4

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
8000777c:	1a 25       	add %d15,%d5,%d2
8000777e:	60 f4       	mov.a %a4,%d15
    {
        masterId = slave;
    }
    else
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */
80007780:	82 04       	mov %d4,0

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
80007782:	a0 32       	mov.a %a2,3
80007784:	01 44 00 36 	addsc.a %a3,%a4,%d4,0
80007788:	8f f4 0f 61 	and %d6,%d4,255
8000778c:	14 35       	ld.bu %d5,[%a3]
8000778e:	5f 35 06 80 	jne %d5,%d3,8000779a <IfxVadc_Adc_getGroupConfig+0x224>
            {
                return (IfxVadc_GroupId)(i + idxOffset);
80007792:	42 62       	add %d2,%d6
80007794:	8f f2 0f 21 	and %d2,%d2,255
80007798:	3c 04       	j 800077a0 <IfxVadc_Adc_getGroupConfig+0x22a>
8000779a:	c2 14       	add %d4,1
8000779c:	fc 24       	loop %a2,80007784 <IfxVadc_Adc_getGroupConfig+0x20e>
        config->backgroundScanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;  /* Use CCU6061 TRIG0 */
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0; /* Trigger source taken from Gating Input */
    }

    config->master                 = IfxVadc_Adc_getMasterId(group->groupId, IfxVadc_getMasterIndex(vadcG));
8000779e:	02 72       	mov %d2,%d7
800077a0:	28 52       	st.b [%a15]5,%d2


IFX_INLINE Ifx_VADC_GLOBCFG IfxVadc_getGlobalConfigValue(Ifx_VADC *vadc)
{
    Ifx_VADC_GLOBCFG globCfg;
    globCfg.U = vadc->GLOBCFG.U;
800077a2:	19 d2 00 20 	ld.w %d2,[%a13]128

    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
800077a6:	1b 07 01 f0 	addi %d15,%d7,16
800077aa:	57 02 61 ff 	extr.u %d15,%d2,%d15,1
800077ae:	e9 ff 30 00 	st.b [%a15]48,%d15
800077b2:	00 90       	ret 

800077b4 <IfxVadc_Adc_initChannel>:


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
800077b4:	99 52 14 00 	ld.a %a2,[%a5]20
800077b8:	d4 2e       	ld.a %a14,[%a2]
800077ba:	99 2c 04 00 	ld.a %a12,[%a2]4
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
800077be:	39 28 08 00 	ld.bu %d8,[%a2]8
{
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
800077c2:	b5 42 04 00 	st.a [%a4]4,%a2
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
800077c6:	02 84       	mov %d4,%d8
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
800077c8:	40 4d       	mov.aa %a13,%a4
    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
800077ca:	40 e4       	mov.aa %a4,%a14
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
800077cc:	40 5f       	mov.aa %a15,%a5
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;
800077ce:	79 59 0c 00 	ld.b %d9,[%a5]12

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
800077d2:	6d ff ab e6 	call 80004528 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_setReferenceInput(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelReference reference)
{
    vadcG->CHCTR[channelIndex].B.REFSEL = reference;
800077d6:	1b 09 06 20 	addi %d2,%d9,96
800077da:	01 c2 02 26 	addsc.a %a2,%a12,%d2,2
800077de:	0c fe       	ld.bu %d15,[%a15]14
800077e0:	54 22       	ld.w %d2,[%a2]
        IfxVadc_setResultPosition(vadcG, channelIndex, config->rightAlignedStorage);
        IfxVadc_setBackgroundResultTarget(vadcG, channelIndex, config->globalResultUsage);
        IfxVadc_setBoundaryMode(vadcG, channelIndex, config->boundaryMode);
    }

    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800077e2:	40 e4       	mov.aa %a4,%a14
800077e4:	67 f2 0b f0 	ins.t %d15,%d2,11,%d15,0
800077e8:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_storeGroupResult(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelResult resultRegister)
{
    vadcG->CHCTR[channelIndex].B.RESREG = resultRegister;
800077ea:	54 22       	ld.w %d2,[%a2]
800077ec:	0c ff       	ld.bu %d15,[%a15]15
800077ee:	37 f2 04 f8 	insert %d15,%d2,%d15,16,4
800077f2:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setLowerBoundary(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundarySelection lowerBoundary)
{
    vadcG->CHCTR[channelIndex].B.BNDSELL = lowerBoundary;
800077f4:	54 22       	ld.w %d2,[%a2]
800077f6:	39 ff 10 00 	ld.bu %d15,[%a15]16
800077fa:	37 f2 02 f2 	insert %d15,%d2,%d15,4,2
800077fe:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setUpperBoundary(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundarySelection upperBoundary)
{
    vadcG->CHCTR[channelIndex].B.BNDSELU = upperBoundary;
80007800:	54 22       	ld.w %d2,[%a2]
80007802:	39 ff 11 00 	ld.bu %d15,[%a15]17
80007806:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
8000780a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setSyncRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean synchonize)
{
    vadcG->CHCTR[channelIndex].B.SYNC = synchonize;
8000780c:	54 22       	ld.w %d2,[%a2]
8000780e:	0c f1       	ld.bu %d15,[%a15]1
80007810:	67 f2 0a f0 	ins.t %d15,%d2,10,%d15,0
80007814:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setChannelInputClass(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_InputClasses inputClass)
{
    vadcG->CHCTR[channelIndex].B.ICLSEL = inputClass;
80007816:	54 22       	ld.w %d2,[%a2]
80007818:	0c fd       	ld.bu %d15,[%a15]13
8000781a:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
8000781e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setChannelLimitCheckMode(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_LimitCheck limitCheck)
{
    vadcG->CHCTR[channelIndex].B.CHEVMODE = limitCheck;
80007820:	54 22       	ld.w %d2,[%a2]
80007822:	39 ff 13 00 	ld.bu %d15,[%a15]19
80007826:	37 f2 02 f4 	insert %d15,%d2,%d15,8,2
8000782a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setResultPosition(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean rightAlignedStorage)
{
    vadcG->CHCTR[channelIndex].B.RESPOS = rightAlignedStorage;
8000782c:	54 22       	ld.w %d2,[%a2]
8000782e:	0c f3       	ld.bu %d15,[%a15]3
80007830:	67 f2 15 f0 	ins.t %d15,%d2,21,%d15,0
80007834:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setBackgroundResultTarget(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean globalResultUsage)
{
    vadcG->CHCTR[channelIndex].B.RESTBS = globalResultUsage;
80007836:	54 22       	ld.w %d2,[%a2]
80007838:	0c f0       	ld.bu %d15,[%a15]0
8000783a:	67 f2 14 f0 	ins.t %d15,%d2,20,%d15,0
8000783e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setBoundaryMode(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundaryExtension boundaryMode)
{
    vadcG->CHCTR[channelIndex].B.BNDSELX = boundaryMode;
80007840:	54 22       	ld.w %d2,[%a2]
80007842:	39 ff 12 00 	ld.bu %d15,[%a15]18
80007846:	37 f2 04 f6 	insert %d15,%d2,%d15,12,4
8000784a:	6c 20       	st.w [%a2]0,%d15
8000784c:	1b 08 01 f0 	addi %d15,%d8,16
80007850:	16 ff       	and %d15,255
80007852:	02 f4       	mov %d4,%d15
80007854:	6d ff 6a e6 	call 80004528 <IfxVadc_enableAccess>

    if (config->backgroundChannel == FALSE)
80007858:	08 23       	ld.bu %d3,[%a15]2
8000785a:	82 12       	mov %d2,1
8000785c:	0f 92 00 20 	sh %d2,%d2,%d9
80007860:	f6 35       	jnz %d3,8000786a <IfxVadc_Adc_initChannel+0xb6>
}


IFX_INLINE void IfxVadc_setGroupPriorityChannel(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    vadcG->CHASS.U |= (1 << channelIndex);
80007862:	19 c3 08 00 	ld.w %d3,[%a12]8
80007866:	a6 32       	or %d2,%d3
80007868:	3c 05       	j 80007872 <IfxVadc_Adc_initChannel+0xbe>
}


IFX_INLINE void IfxVadc_setBackgroundPriorityChannel(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    vadcG->CHASS.U &= ~(1 << channelIndex);
8000786a:	19 c3 08 00 	ld.w %d3,[%a12]8
8000786e:	0f 23 e0 20 	andn %d2,%d3,%d2
    else
    {
        IfxVadc_setBackgroundPriorityChannel(vadcG, channelIndex);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007872:	02 f4       	mov %d4,%d15
80007874:	59 c2 08 00 	st.w [%a12]8,%d2
80007878:	40 e4       	mov.aa %a4,%a14
8000787a:	6d ff 3b e6 	call 800044f0 <IfxVadc_disableAccess>
}


IFX_INLINE void IfxVadc_setChannelEventNodePointer0(Ifx_VADC_G *vadcG, IfxVadc_SrcNr channelSrcNr, IfxVadc_ChannelId channel)
{
    vadcG->CEVNP0.U &= ~(IFX_VADC_G_CEVNP0_CEV0NP_MSK << (channel * 4));
8000787e:	79 d3 00 00 	ld.b %d3,[%a13]0
80007882:	19 c5 20 40 	ld.w %d5,[%a12]288
80007886:	8f 23 00 f0 	sh %d15,%d3,2
8000788a:	3b f0 00 20 	mov %d2,15
8000788e:	0f f2 00 20 	sh %d2,%d2,%d15
80007892:	0f 25 e0 20 	andn %d2,%d5,%d2

    IfxVadc_setChannelEventNodePointer0(vadcG, config->channelSrcNr, channel->channel);
80007896:	08 b4       	ld.bu %d4,[%a15]11
80007898:	59 c2 20 40 	st.w [%a12]288,%d2
    vadcG->CEVNP0.U |= (channelSrcNr << (channel * 4));
8000789c:	19 c2 20 40 	ld.w %d2,[%a12]288
800078a0:	0f f4 00 f0 	sh %d15,%d4,%d15
800078a4:	a6 2f       	or %d15,%d2
800078a6:	59 cf 20 40 	st.w [%a12]288,%d15

    if (config->channelPriority > 0)
800078aa:	b9 ff 06 00 	ld.hu %d15,[%a15]6
800078ae:	6e 1f       	jz %d15,800078ec <IfxVadc_Adc_initChannel+0x138>
    {
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->channelSrcNr);
800078b0:	02 84       	mov %d4,%d8
800078b2:	08 b5       	ld.bu %d5,[%a15]11
800078b4:	6d ff 6b e7 	call 8000478a <IfxVadc_getSrcAddress>
}


IFX_INLINE void IfxVadc_clearChannelRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelId)
{
    vadcG->CEFCLR.U = 1 << channelId;
800078b8:	79 f2 0c 00 	ld.b %d2,[%a15]12
800078bc:	82 1f       	mov %d15,1
800078be:	0f 2f 00 f0 	sh %d15,%d15,%d2
800078c2:	59 cf 10 40 	st.w [%a12]272,%d15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
800078c6:	54 22       	ld.w %d2,[%a2]
800078c8:	08 63       	ld.bu %d3,[%a15]6
800078ca:	8f f2 cf 21 	andn %d2,%d2,255
800078ce:	a6 32       	or %d2,%d3

        IfxVadc_clearChannelRequest(vadcG, config->channelId);
        IfxSrc_init(src, config->channelServProvider, config->channelPriority);
800078d0:	0c f9       	ld.bu %d15,[%a15]9
800078d2:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800078d4:	54 22       	ld.w %d2,[%a2]
800078d6:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
800078da:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
800078dc:	4c 20       	ld.w %d15,[%a2]0
800078de:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
800078e2:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
800078e4:	4c 20       	ld.w %d15,[%a2]0
800078e6:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
800078ea:	6c 20       	st.w [%a2]0,%d15
    else
    {
        /* do nothing */
    }

    if (config->resultRegister < IfxVadc_ChannelResult_8)
800078ec:	0c ff       	ld.bu %d15,[%a15]15
800078ee:	08 a2       	ld.bu %d2,[%a15]10
800078f0:	ff 8f 15 80 	jge.u %d15,8,8000791a <IfxVadc_Adc_initChannel+0x166>
}


IFX_INLINE void IfxVadc_setResultNodeEventPointer0(Ifx_VADC_G *vadcG, IfxVadc_SrcNr resultSrcNr, IfxVadc_ChannelResult resultRegister)
{
    vadcG->REVNP0.U &= ~(IFX_VADC_G_REVNP0_REV0NP_MSK << (resultRegister * 4));
800078f4:	19 c4 30 40 	ld.w %d4,[%a12]304
800078f8:	06 2f       	sh %d15,2
800078fa:	3b f0 00 30 	mov %d3,15
800078fe:	0f f3 00 30 	sh %d3,%d3,%d15
80007902:	0f 34 e0 30 	andn %d3,%d4,%d3
80007906:	59 c3 30 40 	st.w [%a12]304,%d3
    vadcG->REVNP0.U |= (resultSrcNr << (resultRegister * 4));
8000790a:	19 c3 30 40 	ld.w %d3,[%a12]304
8000790e:	0f f2 00 f0 	sh %d15,%d2,%d15
80007912:	a6 3f       	or %d15,%d3
80007914:	59 cf 30 40 	st.w [%a12]304,%d15
80007918:	3c 14       	j 80007940 <IfxVadc_Adc_initChannel+0x18c>
}


IFX_INLINE void IfxVadc_setResultNodeEventPointer1(Ifx_VADC_G *vadcG, IfxVadc_SrcNr resultSrcNr, IfxVadc_ChannelResult resultRegister)
{
    vadcG->REVNP1.U &= ~(IFX_VADC_G_REVNP1_REV8NP_MSK << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
8000791a:	c2 8f       	add %d15,-8
8000791c:	19 c4 34 40 	ld.w %d4,[%a12]308
80007920:	06 2f       	sh %d15,2
80007922:	3b f0 00 30 	mov %d3,15
80007926:	0f f3 00 30 	sh %d3,%d3,%d15
8000792a:	0f 34 e0 30 	andn %d3,%d4,%d3
8000792e:	59 c3 34 40 	st.w [%a12]308,%d3
    vadcG->REVNP1.U |= (resultSrcNr << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80007932:	19 c3 34 40 	ld.w %d3,[%a12]308
80007936:	0f f2 00 f0 	sh %d15,%d2,%d15
8000793a:	a6 3f       	or %d15,%d3
8000793c:	59 cf 34 40 	st.w [%a12]308,%d15
    else
    {
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
    }

    if (config->resultPriority > 0)
80007940:	b9 ff 04 00 	ld.hu %d15,[%a15]4
80007944:	6e 24       	jz %d15,8000798c <IfxVadc_Adc_initChannel+0x1d8>
    {
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->resultSrcNr);
80007946:	02 84       	mov %d4,%d8
80007948:	08 a5       	ld.bu %d5,[%a15]10
8000794a:	6d ff 20 e7 	call 8000478a <IfxVadc_getSrcAddress>
}


IFX_INLINE void IfxVadc_enableServiceRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelResult resultRegister)
{
    vadcG->RCR[resultRegister].B.SRGEN = 1;
8000794e:	0c ff       	ld.bu %d15,[%a15]15
80007950:	1b 0f 08 f0 	addi %d15,%d15,128
80007954:	90 c3       	addsc.a %a3,%a12,%d15,2
80007956:	4c 30       	ld.w %d15,[%a3]0
80007958:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
8000795c:	6c 30       	st.w [%a3]0,%d15
}


IFX_INLINE void IfxVadc_clearAllResultRequests(Ifx_VADC_G *vadcG)
{
    vadcG->REFCLR.U = 0x0000FFFFu;
8000795e:	bb f0 ff ff 	mov.u %d15,65535
80007962:	59 cf 14 40 	st.w [%a12]276,%d15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80007966:	54 22       	ld.w %d2,[%a2]
80007968:	08 43       	ld.bu %d3,[%a15]4
8000796a:	8f f2 cf 21 	andn %d2,%d2,255
8000796e:	a6 32       	or %d2,%d3

        IfxVadc_enableServiceRequest(vadcG, config->resultRegister);
        IfxVadc_clearAllResultRequests(vadcG);
        IfxSrc_init(src, config->resultServProvider, config->resultPriority);
80007970:	0c f8       	ld.bu %d15,[%a15]8
80007972:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80007974:	54 22       	ld.w %d2,[%a2]
80007976:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
8000797a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
8000797c:	4c 20       	ld.w %d15,[%a2]0
8000797e:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80007982:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80007984:	4c 20       	ld.w %d15,[%a2]0
80007986:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000798a:	6c 20       	st.w [%a2]0,%d15
    else
    {
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
8000798c:	40 e4       	mov.aa %a4,%a14
8000798e:	02 84       	mov %d4,%d8
80007990:	6d ff b0 e5 	call 800044f0 <IfxVadc_disableAccess>
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80007994:	0c ff       	ld.bu %d15,[%a15]15
    channel->channel   = config->channelId;

    return Status;
}
80007996:	82 02       	mov %d2,0
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80007998:	2c d1       	st.b [%a13]1,%d15
    channel->channel   = config->channelId;
8000799a:	0c fc       	ld.bu %d15,[%a15]12
8000799c:	2c d0       	st.b [%a13]0,%d15

    return Status;
}
8000799e:	00 90       	ret 

800079a0 <IfxVadc_Adc_initChannelConfig>:
        .resultServProvider  = IfxSrc_Tos_cpu0,
        .channelPriority     = 0,
        .channelSrcNr        = IfxVadc_SrcNr_group0,
        .channelServProvider = IfxSrc_Tos_cpu0
    };
    *config       = IfxVadc_Adc_defaultChannelConfig;
800079a0:	40 42       	mov.aa %a2,%a4
800079a2:	d2 02       	mov %e2,0
800079a4:	89 22 48 01 	st.d [%a2+]8,%e2
800079a8:	89 22 48 01 	st.d [%a2+]8,%e2
800079ac:	89 22 48 01 	st.d [%a2+]8,%e2
    config->group = group;
800079b0:	b5 45 14 00 	st.a [%a4]20,%a5
800079b4:	00 90       	ret 

800079b6 <IfxVadc_Adc_initGroup>:


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
800079b6:	d4 52       	ld.a %a2,[%a5]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
800079b8:	39 58 04 00 	ld.bu %d8,[%a5]4


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
800079bc:	d4 2c       	ld.a %a12,[%a2]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
800079be:	8f a8 00 90 	sh %d9,%d8,10
800079c2:	1b 09 48 f0 	addi %d15,%d9,1152
800079c6:	10 cd       	addsc.a %a13,%a12,%d15,0

    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
800079c8:	4c 20       	ld.w %d15,[%a2]0
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];

    /* check for write access */
    group->group   = vadcG;
800079ca:	b5 4d 04 00 	st.a [%a4]4,%a13
    group->module  = *config->module;
800079ce:	6c 40       	st.w [%a4]0,%d15
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
800079d0:	e9 48 08 00 	st.b [%a4]8,%d8
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
800079d4:	40 c4       	mov.aa %a4,%a12
    config->group = group;
}


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
800079d6:	40 5f       	mov.aa %a15,%a5
    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
800079d8:	6d ff 5a e6 	call 8000468c <IfxVadc_getAdcAnalogFrequency>

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800079dc:	1b 08 01 f0 	addi %d15,%d8,16
800079e0:	8f ff 0f a1 	and %d10,%d15,255
800079e4:	40 c4       	mov.aa %a4,%a12
800079e6:	02 a4       	mov %d4,%d10
    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
800079e8:	02 2b       	mov %d11,%d2

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800079ea:	6d ff 9f e5 	call 80004528 <IfxVadc_enableAccess>

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
800079ee:	39 ff 33 00 	ld.bu %d15,[%a15]51
    {
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
800079f2:	40 d4       	mov.aa %a4,%a13
    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
800079f4:	5e 17       	jne %d15,1,80007a02 <IfxVadc_Adc_initGroup+0x4c>
    {
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
800079f6:	82 14       	mov %d4,1
800079f8:	39 f5 26 00 	ld.bu %d5,[%a15]38
800079fc:	39 f6 27 00 	ld.bu %d6,[%a15]39
80007a00:	3c 03       	j 80007a06 <IfxVadc_Adc_initGroup+0x50>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
80007a02:	d2 04       	mov %e4,0
80007a04:	82 06       	mov %d6,0
80007a06:	82 07       	mov %d7,0
80007a08:	6d ff 06 e8 	call 80004a14 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007a0c:	39 ff 34 00 	ld.bu %d15,[%a15]52
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80007a10:	40 d4       	mov.aa %a4,%a13
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007a12:	5e 17       	jne %d15,1,80007a20 <IfxVadc_Adc_initGroup+0x6a>
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80007a14:	82 14       	mov %d4,1
80007a16:	39 f5 1e 00 	ld.bu %d5,[%a15]30
80007a1a:	39 f6 1f 00 	ld.bu %d6,[%a15]31
80007a1e:	3c 03       	j 80007a24 <IfxVadc_Adc_initGroup+0x6e>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
80007a20:	d2 04       	mov %e4,0
80007a22:	82 06       	mov %d6,0
80007a24:	82 17       	mov %d7,1
80007a26:	6d ff f7 e7 	call 80004a14 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007a2a:	39 ff 35 00 	ld.bu %d15,[%a15]53
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80007a2e:	40 d4       	mov.aa %a4,%a13
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007a30:	5e 17       	jne %d15,1,80007a3e <IfxVadc_Adc_initGroup+0x88>
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80007a32:	82 14       	mov %d4,1
80007a34:	39 f5 2e 00 	ld.bu %d5,[%a15]46
80007a38:	39 f6 2f 00 	ld.bu %d6,[%a15]47
80007a3c:	3c 03       	j 80007a42 <IfxVadc_Adc_initGroup+0x8c>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_background);
80007a3e:	d2 04       	mov %e4,0
80007a40:	82 06       	mov %d6,0
80007a42:	82 27       	mov %d7,2
80007a44:	6d ff e8 e7 	call 80004a14 <IfxVadc_setArbiterPriority>
    }

    /* master slave configuration */
    if (config->master != groupIndex)
80007a48:	0c f5       	ld.bu %d15,[%a15]5
80007a4a:	be 8b       	jeq %d15,%d8,80007a80 <IfxVadc_Adc_initGroup+0xca>
}


IFX_INLINE IfxVadc_Adc_SYNCTR_STSEL IfxVadc_Adc_getMasterKernelIndex(IfxVadc_GroupId slave, IfxVadc_GroupId master)
{
    return IfxVadc_Adc_masterIndex[slave][master];
80007a4c:	13 88 20 ff 	madd %d15,%d15,%d8,8
80007a50:	91 00 00 28 	movh.a %a2,32768
80007a54:	d9 22 e4 50 	lea %a2,[%a2]3428 <80000d64 <IfxVadc_Adc_masterIndex>>
80007a58:	10 22       	addsc.a %a2,%a2,%d15,0
80007a5a:	0c 20       	ld.bu %d15,[%a2]0
}


IFX_INLINE void IfxVadc_setMasterIndex(Ifx_VADC_G *vadcG, uint8 masterIndex)
{
    vadcG->SYNCTR.B.STSEL = (masterIndex % 4);
80007a5c:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007a60:	8f 3f 00 21 	and %d2,%d15,3
80007a64:	19 23 40 30 	ld.w %d3,[%a2]1216
80007a68:	37 f3 02 f0 	insert %d15,%d3,%d15,0,2
80007a6c:	59 2f 40 30 	st.w [%a2]1216,%d15
    vadcG->SYNCTR.U      |= (0x00000008U << (masterIndex % 4));
80007a70:	19 23 40 30 	ld.w %d3,[%a2]1216
80007a74:	da 08       	mov %d15,8
80007a76:	0f 2f 00 f0 	sh %d15,%d15,%d2
80007a7a:	a6 3f       	or %d15,%d3
80007a7c:	59 2f 40 30 	st.w [%a2]1216,%d15
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007a80:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007a84:	19 2f 40 20 	ld.w %d15,[%a2]1152
80007a88:	8f 3f c0 f1 	andn %d15,%d15,3
80007a8c:	59 2f 40 20 	st.w [%a2]1152,%d15
}


IFX_INLINE void IfxVadc_setArbitrationRoundLength(Ifx_VADC_G *vadcG, IfxVadc_ArbitrationRounds arbiterRoundLength)
{
    vadcG->ARBCFG.B.ARBRND = arbiterRoundLength;
80007a90:	39 ff 32 00 	ld.bu %d15,[%a15]50
80007a94:	19 22 40 20 	ld.w %d2,[%a2]1152
80007a98:	37 f2 02 f2 	insert %d15,%d2,%d15,4,2
80007a9c:	59 2f 40 20 	st.w [%a2]1152,%d15
    IfxVadc_setAnalogConvertControl(vadcG, IfxVadc_AnalogConverterMode_off);

    IfxVadc_setArbitrationRoundLength(vadcG, config->arbiter.arbiterRoundLength);

    /* Setup queue request if enabled */
    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007aa0:	39 ff 33 00 	ld.bu %d15,[%a15]51
80007aa4:	df 1f 5a 80 	jne %d15,1,80007b58 <IfxVadc_Adc_initGroup+0x1a2>
    {
        const IfxVadc_Adc_QueueConfig *queueSlot = &config->queueRequest;

        /* configure external Trigger if enabled */
        if (queueSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007aa8:	39 ff 25 00 	ld.bu %d15,[%a15]37
80007aac:	6e 28       	jz %d15,80007afc <IfxVadc_Adc_initGroup+0x146>
}


IFX_INLINE void IfxVadc_enableQueueSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->QMR0.B.ENTR = 1;     /* enable external trigger */
80007aae:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007ab2:	96 04       	or %d15,4
80007ab4:	59 2f 44 40 	st.w [%a2]1284,%d15


IFX_INLINE void IfxVadc_setQueueSlotTriggerOperatingConfig(Ifx_VADC_G *vadcG, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U        = vadcG->QCTRL0.U;
80007ab8:	19 23 40 40 	ld.w %d3,[%a2]1280
        {
            /* enable external trigger */
            IfxVadc_enableQueueSlotExternalTrigger(vadcG);
            IfxVadc_setQueueSlotTriggerOperatingConfig(vadcG, queueSlot->triggerConfig.triggerMode, queueSlot->triggerConfig.triggerSource);
80007abc:	39 f2 25 00 	ld.bu %d2,[%a15]37
80007ac0:	39 ff 23 00 	ld.bu %d15,[%a15]35
    qctrl0.B.XTWC   = 1;
80007ac4:	b7 13 81 37 	insert %d3,%d3,1,15,1
    qctrl0.B.XTMODE = triggerMode;
80007ac8:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    qctrl0.B.XTSEL  = triggerSource;
80007acc:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadcG->QCTRL0.U = qctrl0.U;
80007ad0:	59 23 40 40 	st.w [%a2]1280,%d3

            /* if last input is used the trigger input selection is extend by Gating inputs */
            if (queueSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)
80007ad4:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007ad8:	8b ff 20 f2 	ne %d15,%d15,15
80007adc:	ee 16       	jnz %d15,80007b08 <IfxVadc_Adc_initGroup+0x152>


IFX_INLINE void IfxVadc_setQueueSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U           = vadcG->QCTRL0.U;
80007ade:	19 23 40 40 	ld.w %d3,[%a2]1280
            {
                IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007ae2:	39 ff 22 00 	ld.bu %d15,[%a15]34
    qctrl0.B.GTWC      = 1;
80007ae6:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80007aea:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80007aee:	59 23 40 40 	st.w [%a2]1280,%d3
    vadcG->QMR0.B.ENGT = gatingMode;
80007af2:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007af6:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007afa:	3c 05       	j 80007b04 <IfxVadc_Adc_initGroup+0x14e>
}


IFX_INLINE void IfxVadc_disableQueueSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->QMR0.B.ENTR = 0; /* disable external trigger */
80007afc:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007b00:	8f 4f c0 f1 	andn %d15,%d15,4
80007b04:	59 2f 44 40 	st.w [%a2]1284,%d15
            /* disable external trigger */
            IfxVadc_disableQueueSlotExternalTrigger(vadcG);
        }

        /* configure Gating if enabled */
        if ((queueSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007b08:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007b0c:	8b ff 00 f2 	eq %d15,%d15,15
80007b10:	ee 15       	jnz %d15,80007b3a <IfxVadc_Adc_initGroup+0x184>


IFX_INLINE void IfxVadc_setQueueSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U           = vadcG->QCTRL0.U;
80007b12:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
        {
            IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, queueSlot->triggerConfig.gatingMode);
80007b16:	39 f2 22 00 	ld.bu %d2,[%a15]34
80007b1a:	19 23 40 40 	ld.w %d3,[%a2]1280
80007b1e:	39 ff 24 00 	ld.bu %d15,[%a15]36
    qctrl0.B.GTWC      = 1;
80007b22:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80007b26:	37 23 04 38 	insert %d3,%d3,%d2,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80007b2a:	59 23 40 40 	st.w [%a2]1280,%d3
    vadcG->QMR0.B.ENGT = gatingMode;
80007b2e:	19 22 44 40 	ld.w %d2,[%a2]1284
80007b32:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007b36:	59 2f 44 40 	st.w [%a2]1284,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_clearQueue(vadcG, (queueSlot->flushQueueAfterInit) ? 1 : 0);
80007b3a:	39 f2 20 00 	ld.bu %d2,[%a15]32
}


IFX_INLINE void IfxVadc_clearQueue(Ifx_VADC_G *vadcG, boolean flushQueue)
{
    vadcG->QMR0.B.FLUSH = flushQueue;
80007b3e:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007b42:	3b 00 40 f0 	mov %d15,1024
80007b46:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80007b4a:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007b4e:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80007b52:	a6 2f       	or %d15,%d2
80007b54:	59 2f 44 40 	st.w [%a2]1284,%d15
    {
        /* do nothing */
    }

    /* Setup scan request if enabled */
    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007b58:	39 ff 34 00 	ld.bu %d15,[%a15]52
80007b5c:	df 1f 5a 80 	jne %d15,1,80007c10 <IfxVadc_Adc_initGroup+0x25a>
    {
        const IfxVadc_Adc_ScanConfig *scanSlot = &config->scanRequest;

        /* configure external Trigger if enabled */
        if (scanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007b60:	39 ff 1d 00 	ld.bu %d15,[%a15]29
}


IFX_INLINE void IfxVadc_enableScanSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->ASMR.B.ENTR = 1; /* enable external trigger */
80007b64:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007b68:	6e 28       	jz %d15,80007bb8 <IfxVadc_Adc_initGroup+0x202>
80007b6a:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007b6e:	96 04       	or %d15,4
80007b70:	59 2f 64 40 	st.w [%a2]1316,%d15


IFX_INLINE void IfxVadc_setScanSlotTriggerConfig(Ifx_VADC_G *vadcG, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U        = vadcG->ASCTRL.U;
80007b74:	19 23 60 40 	ld.w %d3,[%a2]1312
        {
            /* enable external trigger */
            IfxVadc_enableScanSlotExternalTrigger(vadcG);

            IfxVadc_setScanSlotTriggerConfig(vadcG, scanSlot->triggerConfig.triggerMode, scanSlot->triggerConfig.triggerSource);
80007b78:	39 f2 1d 00 	ld.bu %d2,[%a15]29
80007b7c:	39 ff 1b 00 	ld.bu %d15,[%a15]27
    asctrl.B.XTWC   = 1;
80007b80:	b7 13 81 37 	insert %d3,%d3,1,15,1
    asctrl.B.XTMODE = triggerMode;
80007b84:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    asctrl.B.XTSEL  = triggerSource;
80007b88:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadcG->ASCTRL.U = asctrl.U;
80007b8c:	59 23 60 40 	st.w [%a2]1312,%d3

            if (scanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80007b90:	39 ff 1b 00 	ld.bu %d15,[%a15]27
80007b94:	8b ff 20 f2 	ne %d15,%d15,15
80007b98:	ee 16       	jnz %d15,80007bc4 <IfxVadc_Adc_initGroup+0x20e>


IFX_INLINE void IfxVadc_setScanSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U           = vadcG->ASCTRL.U;
80007b9a:	19 23 60 40 	ld.w %d3,[%a2]1312
            {
                IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007b9e:	39 ff 1a 00 	ld.bu %d15,[%a15]26
    asctrl.B.GTWC      = 1;
80007ba2:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80007ba6:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80007baa:	59 23 60 40 	st.w [%a2]1312,%d3
    vadcG->ASMR.B.ENGT = gatingMode;
80007bae:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007bb2:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007bb6:	3c 05       	j 80007bc0 <IfxVadc_Adc_initGroup+0x20a>
}


IFX_INLINE void IfxVadc_disableScanSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->ASMR.B.ENTR = 0; /* disable external trigger */
80007bb8:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007bbc:	8f 4f c0 f1 	andn %d15,%d15,4
80007bc0:	59 2f 64 40 	st.w [%a2]1316,%d15
        {
            IfxVadc_disableScanSlotExternalTrigger(vadcG);
        }

        /* configure Gating if enabled */
        if ((scanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007bc4:	39 ff 1b 00 	ld.bu %d15,[%a15]27
80007bc8:	8b ff 00 f2 	eq %d15,%d15,15
80007bcc:	ee 15       	jnz %d15,80007bf6 <IfxVadc_Adc_initGroup+0x240>


IFX_INLINE void IfxVadc_setScanSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U           = vadcG->ASCTRL.U;
80007bce:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
        {
            IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, scanSlot->triggerConfig.gatingMode);
80007bd2:	39 f2 1a 00 	ld.bu %d2,[%a15]26
80007bd6:	19 23 60 40 	ld.w %d3,[%a2]1312
80007bda:	39 ff 1c 00 	ld.bu %d15,[%a15]28
    asctrl.B.GTWC      = 1;
80007bde:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80007be2:	37 23 04 38 	insert %d3,%d3,%d2,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80007be6:	59 23 60 40 	st.w [%a2]1312,%d3
    vadcG->ASMR.B.ENGT = gatingMode;
80007bea:	19 22 64 40 	ld.w %d2,[%a2]1316
80007bee:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007bf2:	59 2f 64 40 	st.w [%a2]1316,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_setAutoScan(vadcG, scanSlot->autoscanEnabled ? 1 : 0);
80007bf6:	39 ff 18 00 	ld.bu %d15,[%a15]24
}


IFX_INLINE void IfxVadc_setAutoScan(Ifx_VADC_G *vadcG, boolean autoscanEnable)
{
    vadcG->ASMR.B.SCAN = autoscanEnable;
80007bfa:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007bfe:	ab 0f a1 2f 	seln %d2,%d15,%d15,16
80007c02:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007c06:	8f 0f c1 f1 	andn %d15,%d15,16
80007c0a:	a6 2f       	or %d15,%d2
80007c0c:	59 2f 64 40 	st.w [%a2]1316,%d15
    else
    {
        /* do nothing */
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007c10:	39 ff 35 00 	ld.bu %d15,[%a15]53
80007c14:	df 1f 4f 80 	jne %d15,1,80007cb2 <IfxVadc_Adc_initGroup+0x2fc>
    {
        const IfxVadc_Adc_BackgroundScanConfig *backgroundScanSlot = &config->backgroundScanRequest;

        /* configure external Trigger if enabled */
        if (backgroundScanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007c18:	39 ff 2d 00 	ld.bu %d15,[%a15]45
80007c1c:	6e 29       	jz %d15,80007c6e <IfxVadc_Adc_initGroup+0x2b8>
}


IFX_INLINE void IfxVadc_enableBackgroundScanSlotExternalTrigger(Ifx_VADC *vadc)
{
    vadc->BRSMR.B.ENTR = 1; /* enable external trigger */
80007c1e:	19 cf 04 80 	ld.w %d15,[%a12]516
80007c22:	96 04       	or %d15,4
80007c24:	59 cf 04 80 	st.w [%a12]516,%d15


IFX_INLINE void IfxVadc_setBackgroundScanSlotTriggerConfig(Ifx_VADC *vadc, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U        = vadc->BRSCTRL.U;
80007c28:	19 c3 00 80 	ld.w %d3,[%a12]512
        {
            IfxVadc_enableBackgroundScanSlotExternalTrigger(vadc);

            IfxVadc_setBackgroundScanSlotTriggerConfig(vadc, backgroundScanSlot->triggerConfig.triggerMode, backgroundScanSlot->triggerConfig.triggerSource);
80007c2c:	39 f2 2d 00 	ld.bu %d2,[%a15]45
80007c30:	39 ff 2b 00 	ld.bu %d15,[%a15]43
    brsctrl.B.XTWC   = 1;
80007c34:	b7 13 81 37 	insert %d3,%d3,1,15,1
    brsctrl.B.XTMODE = triggerMode;
80007c38:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    brsctrl.B.XTSEL  = triggerSource;
80007c3c:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadc->BRSCTRL.U  = brsctrl.U;
80007c40:	59 c3 00 80 	st.w [%a12]512,%d3

            if (backgroundScanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80007c44:	39 ff 2b 00 	ld.bu %d15,[%a15]43
80007c48:	8b ff 20 f2 	ne %d15,%d15,15
80007c4c:	ee 11       	jnz %d15,80007c6e <IfxVadc_Adc_initGroup+0x2b8>


IFX_INLINE void IfxVadc_setBackgroundScanSlotGatingConfig(Ifx_VADC *vadc, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U          = vadc->BRSCTRL.U;
80007c4e:	19 c3 00 80 	ld.w %d3,[%a12]512
            {
                IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007c52:	39 ff 2a 00 	ld.bu %d15,[%a15]42
    brsctrl.B.GTWC     = 1;
80007c56:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80007c5a:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
80007c5e:	59 c3 00 80 	st.w [%a12]512,%d3
    vadc->BRSMR.B.ENGT = gatingMode;
80007c62:	19 cf 04 80 	ld.w %d15,[%a12]516
80007c66:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007c6a:	59 cf 04 80 	st.w [%a12]516,%d15
        {
            /* do nothing */
        }

        /* configure Gating if enabled */
        if ((backgroundScanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007c6e:	39 ff 2b 00 	ld.bu %d15,[%a15]43
80007c72:	8b ff 00 f2 	eq %d15,%d15,15
80007c76:	ee 13       	jnz %d15,80007c9c <IfxVadc_Adc_initGroup+0x2e6>


IFX_INLINE void IfxVadc_setBackgroundScanSlotGatingConfig(Ifx_VADC *vadc, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U          = vadc->BRSCTRL.U;
80007c78:	19 c3 00 80 	ld.w %d3,[%a12]512
        {
            IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, backgroundScanSlot->triggerConfig.gatingMode);
80007c7c:	39 f2 2a 00 	ld.bu %d2,[%a15]42
    brsctrl.B.GTWC     = 1;
80007c80:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80007c84:	37 23 04 38 	insert %d3,%d3,%d2,16,4
80007c88:	39 ff 2c 00 	ld.bu %d15,[%a15]44
    vadc->BRSCTRL.U    = brsctrl.U;
80007c8c:	59 c3 00 80 	st.w [%a12]512,%d3
    vadc->BRSMR.B.ENGT = gatingMode;
80007c90:	19 c2 04 80 	ld.w %d2,[%a12]516
80007c94:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007c98:	59 cf 04 80 	st.w [%a12]516,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_setAutoBackgroundScan(vadc, backgroundScanSlot->autoBackgroundScanEnabled ? 1 : 0);
80007c9c:	39 ff 28 00 	ld.bu %d15,[%a15]40
}


IFX_INLINE void IfxVadc_setAutoBackgroundScan(Ifx_VADC *vadc, boolean autoBackgroundScanEnable)
{
    vadc->BRSMR.B.SCAN = autoBackgroundScanEnable;
80007ca0:	ab 0f a1 2f 	seln %d2,%d15,%d15,16
80007ca4:	19 cf 04 80 	ld.w %d15,[%a12]516
80007ca8:	8f 0f c1 f1 	andn %d15,%d15,16
80007cac:	a6 2f       	or %d15,%d2
80007cae:	59 cf 04 80 	st.w [%a12]516,%d15
    {
        /* do nothing */
    }

    /* turn on group after initialisation, only in master mode */
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
80007cb2:	0c f5       	ld.bu %d15,[%a15]5
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007cb4:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007cb8:	3a 8f       	eq %d15,%d15,%d8
80007cba:	ab 3f a0 2f 	seln %d2,%d15,%d15,3
80007cbe:	19 2f 40 20 	ld.w %d15,[%a2]1152
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);
80007cc2:	02 84       	mov %d4,%d8
80007cc4:	8f 3f c0 f1 	andn %d15,%d15,3
80007cc8:	a6 2f       	or %d15,%d2
80007cca:	59 2f 40 20 	st.w [%a2]1152,%d15
80007cce:	39 f5 30 00 	ld.bu %d5,[%a15]48
80007cd2:	40 c4       	mov.aa %a4,%a12
80007cd4:	6d ff 69 e4 	call 800045a6 <IfxVadc_disablePostCalibration>
}


IFX_INLINE void IfxVadc_setGroupResolution(Ifx_VADC_G *vadcG, uint8 inputClassNum, IfxVadc_ChannelResolution resolution)
{
    vadcG->ICLASS[inputClassNum].B.CMS = resolution;
80007cd8:	8f 88 00 80 	sh %d8,%d8,8
80007cdc:	82 05       	mov %d5,0
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80007cde:	3b f0 0f 40 	mov %d4,255

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
    {
        /* configure Group input class registers */
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
80007ce2:	01 f5 03 26 	addsc.a %a2,%a15,%d5,3
80007ce6:	0b 58 00 20 	add %d2,%d8,%d5
80007cea:	1b 82 12 20 	addi %d2,%d2,296
80007cee:	0c 2c       	ld.bu %d15,[%a2]12
80007cf0:	01 c2 02 26 	addsc.a %a2,%a12,%d2,2
80007cf4:	54 22       	ld.w %d2,[%a2]
80007cf6:	37 f2 03 f4 	insert %d15,%d2,%d15,8,3
80007cfa:	6c 20       	st.w [%a2]0,%d15
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
80007cfc:	9a 15       	add %d15,%d5,1
80007cfe:	d0 f2       	addsc.a %a2,%a15,%d15,3

IFX_INLINE uint32 IfxVadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80007d00:	54 23       	ld.w %d3,[%a2]
80007d02:	4b 3b 41 30 	mul.f %d3,%d11,%d3
80007d06:	4b 03 71 31 	ftouz %d3,%d3
80007d0a:	c2 e3       	add %d3,-2

    if (ticks > 31)
80007d0c:	8b 03 62 f2 	lt.u %d15,%d3,32
80007d10:	ee 04       	jnz %d15,80007d18 <IfxVadc_Adc_initGroup+0x362>
    {
        ticks = (ticks / 16) + 15;
80007d12:	06 c3       	sh %d3,-4
80007d14:	1b f3 00 30 	addi %d3,%d3,15
80007d18:	0b 43 90 31 	min.u %d3,%d3,%d4
}


IFX_INLINE void IfxVadc_setGroupSampleTime(Ifx_VADC_G *vadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    vadcG->ICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80007d1c:	1a 58       	add %d15,%d8,%d5
80007d1e:	1b 8f 12 f0 	addi %d15,%d15,296
80007d22:	90 c2       	addsc.a %a2,%a12,%d15,2
80007d24:	4c 20       	ld.w %d15,[%a2]0
80007d26:	37 3f 05 30 	insert %d3,%d15,%d3,0,5
80007d2a:	74 23       	st.w [%a2],%d3
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
80007d2c:	df 15 04 00 	jeq %d5,1,80007d34 <IfxVadc_Adc_initGroup+0x37e>
80007d30:	82 15       	mov %d5,1
80007d32:	3c d8       	j 80007ce2 <IfxVadc_Adc_initGroup+0x32c>
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007d34:	40 c4       	mov.aa %a4,%a12
80007d36:	02 a4       	mov %d4,%d10
80007d38:	6d ff dc e3 	call 800044f0 <IfxVadc_disableAccess>

    return status;
}
80007d3c:	82 02       	mov %d2,0
80007d3e:	00 90       	ret 

80007d40 <IfxVadc_Adc_initGroupConfig>:
        .inputClass[0].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
        .inputClass[1].resolution = IfxVadc_ChannelResolution_12bit,
        .inputClass[1].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
    };

    *config                        = IfxVadc_Adc_defaultGroupConfig;
80007d40:	40 42       	mov.aa %a2,%a4
80007d42:	7b 60 58 f3 	movh %d15,13702
80007d46:	d2 02       	mov %e2,0
80007d48:	a0 6f       	mov.a %a15,6
80007d4a:	89 22 48 01 	st.d [%a2+]8,%e2
80007d4e:	fc fe       	loop %a15,80007d4a <IfxVadc_Adc_initGroupConfig+0xa>
80007d50:	1b df 7b f3 	addi %d15,%d15,14269
80007d54:	6c 42       	st.w [%a4]8,%d15
80007d56:	6c 44       	st.w [%a4]16,%d15
80007d58:	82 1f       	mov %d15,1
80007d5a:	e9 4f 1e 00 	st.b [%a4]30,%d15
80007d5e:	e9 4f 20 00 	st.b [%a4]32,%d15
80007d62:	e9 4f 26 00 	st.b [%a4]38,%d15
80007d66:	e9 4f 2e 00 	st.b [%a4]46,%d15
    config->groupId                = IfxVadc_GroupId_0;
    config->module                 = vadc;
80007d6a:	f4 45       	st.a [%a4],%a5
80007d6c:	00 90       	ret 

80007d6e <IfxVadc_Adc_initModule>:


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
80007d6e:	cc 50       	ld.a %a15,[%a5]0
    config->disablePostCalibration = FALSE;
}


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
80007d70:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
    vadc->vadc = vadcSFR;
80007d72:	ec 40       	st.a [%a4]0,%a15
}


IFX_INLINE void IfxVadc_enableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007d74:	6d ff 0f fa 	call 80007192 <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80007d78:	02 24       	mov %d4,%d2
}


IFX_INLINE void IfxVadc_enableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007d7a:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80007d7c:	6d ff 0b f9 	call 80006f92 <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.U = 0x00000000;
80007d80:	82 02       	mov %d2,0
80007d82:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80007d84:	02 f4       	mov %d4,%d15
80007d86:	6d ff 3b fa 	call 800071fc <IfxScuWdt_setCpuEndinit>
    float32        analogFrequency;
    uint8          inputClassNum, groupNum;

    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);
80007d8a:	40 f4       	mov.aa %a4,%a15
80007d8c:	39 c4 21 00 	ld.bu %d4,[%a12]33
80007d90:	6d ff 30 e6 	call 800049f0 <IfxVadc_selectPowerSupplyVoltage>

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80007d94:	19 c4 18 00 	ld.w %d4,[%a12]24
80007d98:	40 f4       	mov.aa %a4,%a15
80007d9a:	4b 04 71 41 	ftouz %d4,%d4
    {
        return IfxVadc_Status_notInitialised;
80007d9e:	82 1f       	mov %d15,1
    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80007da0:	6d ff 42 e5 	call 80004824 <IfxVadc_initializeFAdcI>
80007da4:	df 02 57 00 	jeq %d2,0,80007e52 <IfxVadc_Adc_initModule+0xe4>
    {
        /* do nothing */
    }

    /* Set digital Frequency */
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);
80007da8:	19 c4 14 00 	ld.w %d4,[%a12]20
80007dac:	40 f4       	mov.aa %a4,%a15
80007dae:	4b 04 71 41 	ftouz %d4,%d4
80007db2:	6d ff 24 e5 	call 800047fa <IfxVadc_initializeFAdcD>

    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);
80007db6:	40 f4       	mov.aa %a4,%a15
80007db8:	6d ff 6a e4 	call 8000468c <IfxVadc_getAdcAnalogFrequency>
80007dbc:	82 03       	mov %d3,0
80007dbe:	3b f0 0f 60 	mov %d6,255

    /* configure Global input class registers */
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
    {
        /* configure ADC channel resolution ( conversion mode ) */
        IfxVadc_setGlobalResolution(vadcSFR, inputClassNum, config->globalInputClass[inputClassNum].resolution);
80007dc2:	9a 13       	add %d15,%d3,1
}


IFX_INLINE void IfxVadc_setGlobalResolution(Ifx_VADC *vadc, uint8 inputClassNum, IfxVadc_ChannelResolution resolution)
{
    vadc->GLOBICLASS[inputClassNum].B.CMS = resolution;
80007dc4:	1b 83 02 40 	addi %d4,%d3,40
80007dc8:	d0 c2       	addsc.a %a2,%a12,%d15,3
80007dca:	01 f4 02 36 	addsc.a %a3,%a15,%d4,2
80007dce:	0c 20       	ld.bu %d15,[%a2]0
80007dd0:	54 35       	ld.w %d5,[%a3]
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
80007dd2:	01 c3 03 26 	addsc.a %a2,%a12,%d3,3
80007dd6:	37 f5 03 f4 	insert %d15,%d5,%d15,8,3
80007dda:	6c 30       	st.w [%a3]0,%d15

IFX_INLINE uint32 IfxVadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80007ddc:	4c 21       	ld.w %d15,[%a2]4
80007dde:	4b f2 41 f0 	mul.f %d15,%d2,%d15
80007de2:	4b 0f 71 f1 	ftouz %d15,%d15
80007de6:	c2 ef       	add %d15,-2

    if (ticks > 31)
80007de8:	8b 0f 62 52 	lt.u %d5,%d15,32
80007dec:	f6 54       	jnz %d5,80007df4 <IfxVadc_Adc_initModule+0x86>
    {
        ticks = (ticks / 16) + 15;
80007dee:	06 cf       	sh %d15,-4
80007df0:	1b ff 00 f0 	addi %d15,%d15,15
80007df4:	0b 6f 90 f1 	min.u %d15,%d15,%d6
}


IFX_INLINE void IfxVadc_setGlobalSampleTime(Ifx_VADC *vadc, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    vadc->GLOBICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80007df8:	01 f4 02 26 	addsc.a %a2,%a15,%d4,2
80007dfc:	54 24       	ld.w %d4,[%a2]
80007dfe:	37 f4 05 f0 	insert %d15,%d4,%d15,0,5
80007e02:	6c 20       	st.w [%a2]0,%d15
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);

    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);

    /* configure Global input class registers */
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
80007e04:	df 13 04 00 	jeq %d3,1,80007e0c <IfxVadc_Adc_initModule+0x9e>
80007e08:	82 13       	mov %d3,1
80007e0a:	3c dc       	j 80007dc2 <IfxVadc_Adc_initModule+0x54>
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
    }

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
80007e0c:	39 c2 20 00 	ld.bu %d2,[%a12]32

        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
    }

    return status;
80007e10:	82 0f       	mov %d15,0
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
    }

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
80007e12:	df 12 20 80 	jne %d2,1,80007e52 <IfxVadc_Adc_initModule+0xe4>
80007e16:	82 08       	mov %d8,0
80007e18:	1b 08 01 f0 	addi %d15,%d8,16
80007e1c:	16 ff       	and %d15,255
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
        {
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007e1e:	02 f4       	mov %d4,%d15
80007e20:	40 f4       	mov.aa %a4,%a15
80007e22:	6d ff 83 e3 	call 80004528 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007e26:	8f a8 00 20 	sh %d2,%d8,10
80007e2a:	01 f2 00 26 	addsc.a %a2,%a15,%d2,0
80007e2e:	c2 18       	add %d8,1
80007e30:	19 22 40 20 	ld.w %d2,[%a2]1152
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007e34:	02 f4       	mov %d4,%d15
80007e36:	8f 32 40 21 	or %d2,%d2,3
80007e3a:	59 22 40 20 	st.w [%a2]1152,%d2
80007e3e:	40 f4       	mov.aa %a4,%a15

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
80007e40:	8b 88 20 f2 	ne %d15,%d8,8
        {
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007e44:	6d ff 56 e3 	call 800044f0 <IfxVadc_disableAccess>

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
80007e48:	ee e8       	jnz %d15,80007e18 <IfxVadc_Adc_initModule+0xaa>
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
        }

        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
80007e4a:	40 f4       	mov.aa %a4,%a15
80007e4c:	6d ff 19 e6 	call 80004a7e <IfxVadc_startupCalibration>
    }

    return status;
80007e50:	82 0f       	mov %d15,0
}
80007e52:	02 f2       	mov %d2,%d15
80007e54:	00 90       	ret 

80007e56 <IfxVadc_Adc_initModuleConfig>:


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80007e56:	7b 90 b9 f4 	movh %d15,19353
    return status;
}


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
80007e5a:	40 4f       	mov.aa %a15,%a4
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80007e5c:	1b 0f 68 f9 	addi %d15,%d15,-27008
    return status;
}


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
80007e60:	40 54       	mov.aa %a4,%a5
    config->vadc                           = vadc;
80007e62:	e8 05       	st.a [%a15]0,%a5
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80007e64:	68 6f       	st.w [%a15]24,%d15

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
80007e66:	6d ff 1f e4 	call 800046a4 <IfxVadc_getAdcDigitalFrequency>
80007e6a:	68 52       	st.w [%a15]20,%d2
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
80007e6c:	6d ff cf f0 	call 8000600a <IfxScuCcu_getSpbFrequency>
80007e70:	68 72       	st.w [%a15]28,%d2
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
    config->globalInputClass[0].sampleTime = 1.0e-6;
80007e72:	7b 60 58 23 	movh %d2,13702
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80007e76:	82 0f       	mov %d15,0
    config->globalInputClass[0].sampleTime = 1.0e-6;
80007e78:	1b d2 7b 23 	addi %d2,%d2,14269
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80007e7c:	28 8f       	st.b [%a15]8,%d15
    config->globalInputClass[0].sampleTime = 1.0e-6;
80007e7e:	68 12       	st.w [%a15]4,%d2
    config->globalInputClass[1].resolution = IfxVadc_ChannelResolution_12bit;
80007e80:	e9 ff 10 00 	st.b [%a15]16,%d15
    config->globalInputClass[1].sampleTime = 1.0e-6;
80007e84:	68 32       	st.w [%a15]12,%d2
    config->startupCalibration             = FALSE;
80007e86:	e9 ff 20 00 	st.b [%a15]32,%d15
    config->supplyVoltage                  = IfxVadc_LowSupplyVoltageSelect_5V;
80007e8a:	e9 ff 21 00 	st.b [%a15]33,%d15
80007e8e:	00 90       	ret 

80007e90 <IfxVadc_Adc_initExternalMultiplexerModeConfig>:
}


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
80007e90:	20 10       	sub.a %sp,16
    emuxConfig->vadc                  = vadc;
    emuxConfig->channels              = 0;
80007e92:	82 0f       	mov %d15,0
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80007e94:	40 a2       	mov.aa %a2,%sp


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
    emuxConfig->vadc                  = vadc;
    emuxConfig->channels              = 0;
80007e96:	2c 49       	st.b [%a4]9,%d15
    emuxConfig->groupId               = IfxVadc_GroupId_0;
80007e98:	2c 48       	st.b [%a4]8,%d15
    emuxConfig->emuxInterface         = IfxVadc_EmuxInterface_0;
80007e9a:	2c 4a       	st.b [%a4]10,%d15
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
80007e9c:	2c 45       	st.b [%a4]5,%d15
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
80007e9e:	2c 46       	st.b [%a4]6,%d15
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
80007ea0:	2c 47       	st.b [%a4]7,%d15
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
80007ea2:	2c 44       	st.b [%a4]4,%d15
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
80007ea4:	e9 4f 1c 00 	st.b [%a4]28,%d15
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80007ea8:	d2 02       	mov %e2,0
80007eaa:	89 22 48 01 	st.d [%a2+]8,%e2
80007eae:	89 22 48 01 	st.d [%a2+]8,%e2
        .pins       = {NULL_PTR},
        .outputMode = IfxPort_OutputMode_pushPull,
        .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
    };

    emuxConfig->emuxOutPinConfig = defaultConfig;
80007eb2:	3b 00 f8 ff 	mov %d15,-128
}


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
    emuxConfig->vadc                  = vadc;
80007eb6:	f4 45       	st.a [%a4],%a5
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80007eb8:	40 af       	mov.aa %a15,%sp
        .pins       = {NULL_PTR},
        .outputMode = IfxPort_OutputMode_pushPull,
        .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
    };

    emuxConfig->emuxOutPinConfig = defaultConfig;
80007eba:	2c ac       	st.b [%sp]12,%d15
80007ebc:	d9 44 0c 00 	lea %a4,[%a4]12
80007ec0:	09 f2 48 01 	ld.d %e2,[%a15+]8
80007ec4:	89 42 48 01 	st.d [%a4+]8,%e2
80007ec8:	09 f2 48 01 	ld.d %e2,[%a15+]8
80007ecc:	89 42 48 01 	st.d [%a4+]8,%e2
80007ed0:	00 90       	ret 

80007ed2 <IfxVadc_Adc_initExternalMultiplexerMode>:


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
80007ed2:	0c 58       	ld.bu %d15,[%a5]8
    emuxConfig->emuxOutPinConfig = defaultConfig;
}


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
80007ed4:	20 08       	sub.a %sp,8
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
80007ed6:	8f af 00 20 	sh %d2,%d15,10
80007eda:	1b 02 48 20 	addi %d2,%d2,1152
80007ede:	01 42 00 e6 	addsc.a %a14,%a4,%d2,0
}


IFX_INLINE void IfxVadc_setEmuxInterfaceForGroup(Ifx_VADC *vadc, IfxVadc_EmuxInterface emuxInterface, IfxVadc_GroupId group)
{
    if (emuxInterface == IfxVadc_EmuxInterface_0)
80007ee2:	39 52 0a 00 	ld.bu %d2,[%a5]10
    emuxConfig->emuxOutPinConfig = defaultConfig;
}


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
80007ee6:	40 4c       	mov.aa %a12,%a4
80007ee8:	40 5f       	mov.aa %a15,%a5
80007eea:	16 0f       	and %d15,15
80007eec:	f6 2a       	jnz %d2,80007f00 <IfxVadc_Adc_initExternalMultiplexerMode+0x2e>
    {
        vadc->EMUXSEL.B.EMUXGRP0 = group;
80007eee:	19 42 30 f0 	ld.w %d2,[%a4]1008
80007ef2:	8f f2 c0 21 	andn %d2,%d2,15
80007ef6:	a6 2f       	or %d15,%d2
80007ef8:	59 cf 30 f0 	st.w [%a12]1008,%d15
80007efc:	82 0f       	mov %d15,0
80007efe:	3c 07       	j 80007f0c <IfxVadc_Adc_initExternalMultiplexerMode+0x3a>
    }
    else
    {
        vadc->EMUXSEL.B.EMUXGRP1 = group;
80007f00:	19 42 30 f0 	ld.w %d2,[%a4]1008
80007f04:	06 4f       	sh %d15,4
80007f06:	8f 02 cf 21 	andn %d2,%d2,240
80007f0a:	3c f6       	j 80007ef6 <IfxVadc_Adc_initExternalMultiplexerMode+0x24>
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
    IfxVadc_setEmuxInterfaceForGroup(vadc, emuxControl->emuxInterface, emuxControl->groupId);

    for (count = 0; count < 3; count++)
    {
        if (emuxControl->emuxOutPinConfig.pins[count] != NULL_PTR)
80007f0c:	90 f2       	addsc.a %a2,%a15,%d15,2
80007f0e:	99 2d 0c 00 	ld.a %a13,[%a2]12
80007f12:	bd 0d 19 00 	jz.a %a13,80007f44 <IfxVadc_Adc_initExternalMultiplexerMode+0x72>
80007f16:	39 d3 0c 00 	ld.bu %d3,[%a13]12
80007f1a:	39 f2 18 00 	ld.bu %d2,[%a15]24
80007f1e:	99 d4 04 00 	ld.a %a4,[%a13]4
80007f22:	0f 23 a0 50 	or %d5,%d3,%d2
80007f26:	39 d4 08 00 	ld.bu %d4,[%a13]8
80007f2a:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxVadc_initEmuxPin(emuxControl->emuxOutPinConfig.pins[count], emuxControl->emuxOutPinConfig.outputMode, emuxControl->emuxOutPinConfig.padDriver);
80007f2e:	39 f8 19 00 	ld.bu %d8,[%a15]25
80007f32:	6d ff c4 ed 	call 80005aba <IfxPort_setPinMode>


IFX_INLINE void IfxVadc_initEmuxPin(const IfxVadc_Emux_Out *emux, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(emux->pin.port, emux->pin.pinIndex, outputMode, emux->select);
    IfxPort_setPinPadDriver(emux->pin.port, emux->pin.pinIndex, padDriver);
80007f36:	99 d4 04 00 	ld.a %a4,[%a13]4
80007f3a:	39 d4 08 00 	ld.bu %d4,[%a13]8
80007f3e:	02 85       	mov %d5,%d8
80007f40:	6d ff 3b ee 	call 80005bb6 <IfxPort_setPinPadDriver>
80007f44:	c2 1f       	add %d15,1
{
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
    IfxVadc_setEmuxInterfaceForGroup(vadc, emuxControl->emuxInterface, emuxControl->groupId);

    for (count = 0; count < 3; count++)
80007f46:	df 3f e3 ff 	jne %d15,3,80007f0c <IfxVadc_Adc_initExternalMultiplexerMode+0x3a>
        {
            IfxVadc_initEmuxPin(emuxControl->emuxOutPinConfig.pins[count], emuxControl->emuxOutPinConfig.outputMode, emuxControl->emuxOutPinConfig.padDriver);
        }
    }

    IfxVadc_configExternalMultiplexerMode(vadc, vadcG, emuxControl->mode, emuxControl->channels, emuxControl->startChannel, emuxControl->code, emuxControl->sampleTimeControl, emuxControl->channelSelectionStyle);
80007f4a:	0c f7       	ld.bu %d15,[%a15]7
80007f4c:	08 44       	ld.bu %d4,[%a15]4
80007f4e:	78 00       	st.w [%sp]0,%d15
80007f50:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80007f54:	08 95       	ld.bu %d5,[%a15]9
80007f56:	08 56       	ld.bu %d6,[%a15]5
80007f58:	08 67       	ld.bu %d7,[%a15]6
80007f5a:	78 01       	st.w [%sp]4,%d15
80007f5c:	40 c4       	mov.aa %a4,%a12
80007f5e:	40 e5       	mov.aa %a5,%a14
80007f60:	1d ff 00 e3 	j 80004560 <IfxVadc_configExternalMultiplexerMode>

80007f64 <Ifx_CircularBuffer_get32>:

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
80007f64:	cc 40       	ld.a %a15,[%a4]0
80007f66:	b9 4f 04 00 	ld.hu %d15,[%a4]4

    buffer->index += 4;

    if (buffer->index >= buffer->length)
80007f6a:	b9 43 06 00 	ld.hu %d3,[%a4]6

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
80007f6e:	90 ff       	addsc.a %a15,%a15,%d15,2

    buffer->index += 4;
80007f70:	c2 4f       	add %d15,4
80007f72:	37 0f 70 f0 	extr.u %d15,%d15,0,16

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
80007f76:	48 02       	ld.w %d2,[%a15]0

    buffer->index += 4;
80007f78:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
80007f7a:	3f 3f 04 80 	jlt.u %d15,%d3,80007f82 <Ifx_CircularBuffer_get32+0x1e>
    {
        buffer->index = 0;
80007f7e:	82 0f       	mov %d15,0
80007f80:	ac 42       	st.h [%a4]4,%d15
    }

    return data;
}
80007f82:	00 90       	ret 

80007f84 <Ifx_CircularBuffer_get16>:


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
80007f84:	cc 40       	ld.a %a15,[%a4]0
80007f86:	b9 4f 04 00 	ld.hu %d15,[%a4]4

    buffer->index += 2;

    if (buffer->index >= buffer->length)
80007f8a:	b9 43 06 00 	ld.hu %d3,[%a4]6
}


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
80007f8e:	50 ff       	addsc.a %a15,%a15,%d15,1

    buffer->index += 2;
80007f90:	c2 2f       	add %d15,2
80007f92:	37 0f 70 f0 	extr.u %d15,%d15,0,16
}


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
80007f96:	b9 f2 00 00 	ld.hu %d2,[%a15]0

    buffer->index += 2;
80007f9a:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
80007f9c:	3f 3f 04 80 	jlt.u %d15,%d3,80007fa4 <Ifx_CircularBuffer_get16+0x20>
    {
        buffer->index = 0;
80007fa0:	82 0f       	mov %d15,0
80007fa2:	ac 42       	st.h [%a4]4,%d15
    }

    return data;
}
80007fa4:	00 90       	ret 

80007fa6 <Ifx_CircularBuffer_addDataIncr>:
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
80007fa6:	cc 40       	ld.a %a15,[%a4]0
80007fa8:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    buffer->index                          += 4;

    if (buffer->index >= buffer->length)
80007fac:	b9 42 06 00 	ld.hu %d2,[%a4]6
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
80007fb0:	90 ff       	addsc.a %a15,%a15,%d15,2
    buffer->index                          += 4;
80007fb2:	c2 4f       	add %d15,4
80007fb4:	37 0f 70 f0 	extr.u %d15,%d15,0,16
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
80007fb8:	68 04       	st.w [%a15]0,%d4
    buffer->index                          += 4;
80007fba:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
80007fbc:	3f 2f 04 80 	jlt.u %d15,%d2,80007fc4 <Ifx_CircularBuffer_addDataIncr+0x1e>
    {
        buffer->index = 0;
80007fc0:	82 0f       	mov %d15,0
80007fc2:	ac 42       	st.h [%a4]4,%d15
80007fc4:	00 90       	ret 

80007fc6 <Ifx_CircularBuffer_read8>:
    }
}


void *Ifx_CircularBuffer_read8(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
80007fc6:	80 52       	mov.d %d2,%a5
80007fc8:	37 04 70 40 	extr.u %d4,%d4,0,16
80007fcc:	8f 02 60 31 	nor %d3,%d2,0
80007fd0:	1a 42       	add %d15,%d2,%d4
80007fd2:	42 3f       	add %d15,%d3
80007fd4:	42 23       	add %d3,%d2
80007fd6:	42 43       	add %d3,%d4
    uint8 *Dest = (uint8 *)data;
80007fd8:	40 5f       	mov.aa %a15,%a5
        Dest  = &Dest[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80007fda:	82 06       	mov %d6,0
80007fdc:	37 0f 70 f0 	extr.u %d15,%d15,0,16
80007fe0:	6f f3 03 00 	jz.t %d3,15,80007fe6 <Ifx_CircularBuffer_read8+0x20>
80007fe4:	82 0f       	mov %d15,0
    uint8 *Dest = (uint8 *)data;

    do
    {
        count--;
        *Dest = ((uint8 *)buffer->base)[buffer->index];
80007fe6:	b9 43 04 00 	ld.hu %d3,[%a4]4
80007fea:	d4 42       	ld.a %a2,[%a4]
80007fec:	60 33       	mov.a %a3,%d3
80007fee:	30 32       	add.a %a2,%a3
80007ff0:	14 23       	ld.bu %d3,[%a2]
80007ff2:	24 f3       	st.b [%a15+],%d3
        Dest  = &Dest[1];
        buffer->index++;
80007ff4:	c9 43 04 00 	ld.h %d3,[%a4]4

        if (buffer->index >= buffer->length)
80007ff8:	b9 45 06 00 	ld.hu %d5,[%a4]6
    do
    {
        count--;
        *Dest = ((uint8 *)buffer->base)[buffer->index];
        Dest  = &Dest[1];
        buffer->index++;
80007ffc:	c2 13       	add %d3,1
80007ffe:	37 03 70 30 	extr.u %d3,%d3,0,16
80008002:	f9 43 04 00 	st.h [%a4]4,%d3

        if (buffer->index >= buffer->length)
80008006:	3f 53 04 80 	jlt.u %d3,%d5,8000800e <_SMALL_DATA2_+0xe>
        {
            buffer->index = 0;
8000800a:	f9 46 04 00 	st.h [%a4]4,%d6
        }
    } while (count > 0);
8000800e:	9f 0f ec ff 	jned %d15,0,80007fe6 <Ifx_CircularBuffer_read8+0x20>
80008012:	c2 f4       	add %d4,-1
80008014:	37 04 50 40 	extr %d4,%d4,0,16
80008018:	8b 04 40 43 	max %d4,%d4,0
8000801c:	c2 14       	add %d4,1

    return Dest;
}
8000801e:	1a 42       	add %d15,%d2,%d4
80008020:	60 f2       	mov.a %a2,%d15
80008022:	00 90       	ret 

80008024 <Ifx_CircularBuffer_read32>:


void *Ifx_CircularBuffer_read32(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
80008024:	37 04 70 40 	extr.u %d4,%d4,0,16
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;
80008028:	d4 42       	ld.a %a2,[%a4]
8000802a:	1b f4 ff 5f 	addi %d5,%d4,-1
8000802e:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;

        if (buffer->index >= buffer->length)
80008032:	b9 46 06 00 	ld.hu %d6,[%a4]6
80008036:	82 03       	mov %d3,0
80008038:	37 05 70 20 	extr.u %d2,%d5,0,16
8000803c:	6f f5 03 00 	jz.t %d5,15,80008042 <Ifx_CircularBuffer_read32+0x1e>
80008040:	82 02       	mov %d2,0
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
80008042:	10 2f       	addsc.a %a15,%a2,%d15,0
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;
80008044:	c2 4f       	add %d15,4
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
80008046:	48 05       	ld.w %d5,[%a15]0
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;
80008048:	37 0f 70 f0 	extr.u %d15,%d15,0,16
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
8000804c:	01 53 02 f6 	addsc.a %a15,%a5,%d3,2
80008050:	c2 13       	add %d3,1
80008052:	68 05       	st.w [%a15]0,%d5
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80008054:	0b 6f 30 51 	lt.u %d5,%d15,%d6
80008058:	ab 0f 80 f5 	sel %d15,%d5,%d15,0
        }

        count--;
    } while (count > 0);
8000805c:	9f 02 f3 ff 	jned %d2,0,80008042 <Ifx_CircularBuffer_read32+0x1e>
80008060:	c2 f4       	add %d4,-1
80008062:	37 04 50 40 	extr %d4,%d4,0,16
80008066:	ac 42       	st.h [%a4]4,%d15
80008068:	8b 04 40 43 	max %d4,%d4,0
8000806c:	c2 14       	add %d4,1

    return Dest;
}
8000806e:	01 54 02 26 	addsc.a %a2,%a5,%d4,2
80008072:	00 90       	ret 

80008074 <Ifx_CircularBuffer_write8>:


const void *Ifx_CircularBuffer_write8(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
80008074:	80 52       	mov.d %d2,%a5
80008076:	37 04 70 40 	extr.u %d4,%d4,0,16
8000807a:	8f 02 60 31 	nor %d3,%d2,0
8000807e:	1a 42       	add %d15,%d2,%d4
80008080:	42 3f       	add %d15,%d3
80008082:	42 23       	add %d3,%d2
80008084:	42 43       	add %d3,%d4
    const uint8 *source = (const uint8 *)data;
80008086:	40 5f       	mov.aa %a15,%a5
        source                                 = &source[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80008088:	82 06       	mov %d6,0
8000808a:	37 0f 70 f0 	extr.u %d15,%d15,0,16
8000808e:	6f f3 03 00 	jz.t %d3,15,80008094 <Ifx_CircularBuffer_write8+0x20>
80008092:	82 0f       	mov %d15,0
    const uint8 *source = (const uint8 *)data;

    do
    {
        count--;
        ((uint8 *)buffer->base)[buffer->index] = *source;
80008094:	b9 43 04 00 	ld.hu %d3,[%a4]4
80008098:	d4 42       	ld.a %a2,[%a4]
8000809a:	60 33       	mov.a %a3,%d3
8000809c:	04 f5       	ld.bu %d5,[%a15+]
8000809e:	30 32       	add.a %a2,%a3
800080a0:	34 25       	st.b [%a2],%d5
        source                                 = &source[1];
        buffer->index++;
800080a2:	c9 43 04 00 	ld.h %d3,[%a4]4

        if (buffer->index >= buffer->length)
800080a6:	b9 45 06 00 	ld.hu %d5,[%a4]6
    do
    {
        count--;
        ((uint8 *)buffer->base)[buffer->index] = *source;
        source                                 = &source[1];
        buffer->index++;
800080aa:	c2 13       	add %d3,1
800080ac:	37 03 70 30 	extr.u %d3,%d3,0,16
800080b0:	f9 43 04 00 	st.h [%a4]4,%d3

        if (buffer->index >= buffer->length)
800080b4:	3f 53 04 80 	jlt.u %d3,%d5,800080bc <Ifx_CircularBuffer_write8+0x48>
        {
            buffer->index = 0;
800080b8:	f9 46 04 00 	st.h [%a4]4,%d6
        }
    } while (count > 0);
800080bc:	9f 0f ec ff 	jned %d15,0,80008094 <Ifx_CircularBuffer_write8+0x20>
800080c0:	c2 f4       	add %d4,-1
800080c2:	37 04 50 40 	extr %d4,%d4,0,16
800080c6:	8b 04 40 43 	max %d4,%d4,0
800080ca:	c2 14       	add %d4,1

    return source;
}
800080cc:	1a 42       	add %d15,%d2,%d4
800080ce:	60 f2       	mov.a %a2,%d15
800080d0:	00 90       	ret 

800080d2 <Ifx_CircularBuffer_write32>:


const void *Ifx_CircularBuffer_write32(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
800080d2:	37 04 70 40 	extr.u %d4,%d4,0,16
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;
800080d6:	d4 42       	ld.a %a2,[%a4]
800080d8:	1b f4 ff 5f 	addi %d5,%d4,-1
800080dc:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    {
        *((uint32 *)(&base[buffer->index])) = *source;
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;

        if (buffer->index >= buffer->length)
800080e0:	b9 46 06 00 	ld.hu %d6,[%a4]6
800080e4:	82 03       	mov %d3,0
800080e6:	37 05 70 20 	extr.u %d2,%d5,0,16
800080ea:	6f f5 03 00 	jz.t %d5,15,800080f0 <Ifx_CircularBuffer_write32+0x1e>
800080ee:	82 02       	mov %d2,0
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;

    do
    {
        *((uint32 *)(&base[buffer->index])) = *source;
800080f0:	01 53 02 f6 	addsc.a %a15,%a5,%d3,2
800080f4:	c2 13       	add %d3,1
800080f6:	48 05       	ld.w %d5,[%a15]0
800080f8:	10 2f       	addsc.a %a15,%a2,%d15,0
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;
800080fa:	c2 4f       	add %d15,4
800080fc:	37 0f 70 f0 	extr.u %d15,%d15,0,16
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;

    do
    {
        *((uint32 *)(&base[buffer->index])) = *source;
80008100:	68 05       	st.w [%a15]0,%d5
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80008102:	0b 6f 30 51 	lt.u %d5,%d15,%d6
80008106:	ab 0f 80 f5 	sel %d15,%d5,%d15,0
        }

        count--;
    } while (count > 0);
8000810a:	9f 02 f3 ff 	jned %d2,0,800080f0 <Ifx_CircularBuffer_write32+0x1e>
8000810e:	c2 f4       	add %d4,-1
80008110:	37 04 50 40 	extr %d4,%d4,0,16
80008114:	ac 42       	st.h [%a4]4,%d15
80008116:	8b 04 40 43 	max %d4,%d4,0
8000811a:	c2 14       	add %d4,1

    return source;
}
8000811c:	01 54 02 26 	addsc.a %a2,%a5,%d4,2
80008120:	00 90       	ret 

80008122 <Ifx_Fifo_destroy>:
}


void Ifx_Fifo_destroy(Ifx_Fifo *fifo)
{
    free(fifo);
80008122:	1d 00 8b 13 	j 8000a838 <free>

80008126 <Ifx_Fifo_init>:
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
80008126:	82 0f       	mov %d15,0
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
80008128:	80 42       	mov.d %d2,%a4
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
8000812a:	e9 4f 1c 00 	st.b [%a4]28,%d15
        fifo->eventWriter        = TRUE;
8000812e:	82 1f       	mov %d15,1
80008130:	e9 4f 1d 00 	st.b [%a4]29,%d15
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
80008134:	1b 72 02 f0 	addi %d15,%d2,39
80008138:	8f 7f c0 f1 	andn %d15,%d15,7
8000813c:	6c 40       	st.w [%a4]0,%d15

Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
8000813e:	c2 34       	add %d4,3
    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
80008140:	82 0f       	mov %d15,0
80008142:	ac 42       	st.h [%a4]4,%d15
        fifo->shared.maxcount    = 0;
80008144:	ac 48       	st.h [%a4]16,%d15

Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
80008146:	8f 34 c0 41 	andn %d4,%d4,3
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
        fifo->shared.maxcount    = 0;
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
8000814a:	82 0f       	mov %d15,0
    free(fifo);
}


Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
8000814c:	40 42       	mov.aa %a2,%a4
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
        fifo->shared.maxcount    = 0;
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
8000814e:	6c 43       	st.w [%a4]12,%d15
80008150:	6c 42       	st.w [%a4]8,%d15
        fifo->startIndex         = fifo->endIndex = 0;
80008152:	ac 4b       	st.h [%a4]22,%d15
80008154:	ac 4a       	st.h [%a4]20,%d15
        fifo->size               = size;
80008156:	f9 44 18 00 	st.h [%a4]24,%d4
        fifo->elementSize        = elementSize;
8000815a:	f9 45 1a 00 	st.h [%a4]26,%d5
    }

    return fifo;
}
8000815e:	00 90       	ret 

80008160 <Ifx_Fifo_create>:
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
80008160:	c2 34       	add %d4,3
80008162:	37 04 50 f0 	extr %d15,%d4,0,16
 * This is valid is an OS is used.
 *
 */
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
80008166:	02 58       	mov %d8,%d5
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
80008168:	8f 3f c0 f1 	andn %d15,%d15,3

    fifo = malloc(size + sizeof(Ifx_Fifo) + 8); /* +8 because of padding in case the pointer is not aligned on 64 */
8000816c:	1b 8f 02 40 	addi %d4,%d15,40
80008170:	6d 00 5e 13 	call 8000a82c <malloc>
80008174:	40 24       	mov.aa %a4,%a2

    if (IFX_VALIDATE(IFX_VERBOSE_LEVEL_ERROR, (fifo != NULL_PTR)))
80008176:	bc 25       	jz.a %a2,80008180 <Ifx_Fifo_create+0x20>
    {
        fifo = Ifx_Fifo_init(fifo, size, elementSize);
80008178:	0b f8 10 48 	mov %e4,%d8,%d15
8000817c:	1d ff d5 ff 	j 80008126 <Ifx_Fifo_init>
    }

    return fifo;
}
80008180:	00 90       	ret 

80008182 <Ifx_Fifo_canReadCount>:
{
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);

    if ((count < fifo->elementSize) || (count > fifo->size))
80008182:	8c 4d       	ld.h %d15,[%a4]26
    {                           /* Only complete elements can be read from the buffer */
        result = FALSE;
80008184:	82 02       	mov %d2,0
{
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);

    if ((count < fifo->elementSize) || (count > fifo->size))
80008186:	3f f4 6a 00 	jlt %d4,%d15,8000825a <Ifx_Fifo_canReadCount+0xd8>
8000818a:	8c 4c       	ld.h %d15,[%a4]24
8000818c:	3f 4f 67 00 	jlt %d15,%d4,8000825a <Ifx_Fifo_canReadCount+0xd8>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008190:	4d c0 e2 0f 	mfcr %d0,$icr
    return reg.B.IE != 0;
80008194:	37 00 e1 07 	extr.u %d0,%d0,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008198:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
8000819c:	00 00       	nop 
    else
    {
        boolean interruptState;
        sint32  waitCount;
        interruptState = IfxCpu_disableInterrupts();
        waitCount      = count - Ifx_Fifo_readCount(fifo);
8000819e:	8c 42       	ld.h %d15,[%a4]4
800081a0:	a2 f4       	sub %d4,%d15

        if (waitCount <= 0)
800081a2:	4e 4c       	jgtz %d4,800081ba <Ifx_Fifo_canReadCount+0x38>
        {
            fifo->shared.readerWaitx = 0;
            fifo->eventReader        = TRUE;
800081a4:	82 1f       	mov %d15,1
        interruptState = IfxCpu_disableInterrupts();
        waitCount      = count - Ifx_Fifo_readCount(fifo);

        if (waitCount <= 0)
        {
            fifo->shared.readerWaitx = 0;
800081a6:	59 42 08 00 	st.w [%a4]8,%d2
            fifo->eventReader        = TRUE;
800081aa:	e9 4f 1c 00 	st.b [%a4]28,%d15
            IfxCpu_restoreInterrupts(interruptState);
            result                   = TRUE;
800081ae:	82 12       	mov %d2,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800081b0:	df 00 55 00 	jeq %d0,0,8000825a <Ifx_Fifo_canReadCount+0xd8>
    {
        __enable();
800081b4:	0d 00 00 03 	enable 
800081b8:	00 90       	ret 

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800081ba:	82 f2       	mov %d2,-1
800081bc:	06 f2       	sh %d2,-1
800081be:	ba f6       	eq %d15,%d6,-1
800081c0:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
800081c4:	82 f5       	mov %d5,-1
800081c6:	02 23       	mov %d3,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800081c8:	ee 16       	jnz %d15,800081f4 <Ifx_Fifo_canReadCount+0x72>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800081ca:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800081ce:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800081d2:	0d 00 40 03 	disable 
800081d6:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800081d8:	85 f1 10 00 	ld.w %d1,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800081dc:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800081e0:	02 15       	mov %d5,%d1
800081e2:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800081e6:	76 23       	jz %d2,800081ec <Ifx_Fifo_canReadCount+0x6a>
    {
        __enable();
800081e8:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
800081ec:	0b 65 40 50 	addx %d5,%d5,%d6
800081f0:	0b 73 50 30 	addc %d3,%d3,%d7
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventReader        = FALSE;
800081f4:	82 0f       	mov %d15,0
800081f6:	e9 4f 1c 00 	st.b [%a4]28,%d15
            fifo->shared.readerWaitx = waitCount;
800081fa:	59 44 08 00 	st.w [%a4]8,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800081fe:	76 03       	jz %d0,80008204 <Ifx_Fifo_canReadCount+0x82>
    {
        __enable();
80008200:	0d 00 00 03 	enable 

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008204:	82 f6       	mov %d6,-1
80008206:	06 f6       	sh %d6,-1
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008208:	39 4f 1c 00 	ld.bu %d15,[%a4]28
8000820c:	6e 08       	jz %d15,8000821c <Ifx_Fifo_canReadCount+0x9a>
            {}
            /* After the timeout, the reader is not waiting for any data */
            fifo->shared.readerWaitx = 0;
            result = fifo->eventReader == TRUE;
8000820e:	39 42 1c 00 	ld.bu %d2,[%a4]28
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
            {}
            /* After the timeout, the reader is not waiting for any data */
            fifo->shared.readerWaitx = 0;
80008212:	82 0f       	mov %d15,0
80008214:	6c 42       	st.w [%a4]8,%d15
            result = fifo->eventReader == TRUE;
80008216:	8b 12 00 22 	eq %d2,%d2,1
8000821a:	00 90       	ret 
8000821c:	ba f5       	eq %d15,%d5,-1
8000821e:	0b 36 00 f2 	and.eq %d15,%d6,%d3
80008222:	ee f3       	jnz %d15,80008208 <Ifx_Fifo_canReadCount+0x86>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008224:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008228:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000822c:	0d 00 40 03 	disable 
80008230:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008232:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008236:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000823a:	8f 04 40 41 	or %d4,%d4,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000823e:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008242:	76 23       	jz %d2,80008248 <Ifx_Fifo_canReadCount+0xc6>
    {
        __enable();
80008244:	0d 00 00 03 	enable 
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventReader        = FALSE;
            fifo->shared.readerWaitx = waitCount;
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008248:	0b 3f 00 21 	eq %d2,%d15,%d3
8000824c:	0b 54 30 22 	and.lt.u %d2,%d4,%d5
80008250:	0b 3f 90 22 	or.lt %d2,%d15,%d3
80008254:	df 02 da ff 	jne %d2,0,80008208 <Ifx_Fifo_canReadCount+0x86>
80008258:	3c db       	j 8000820e <Ifx_Fifo_canReadCount+0x8c>
            result = fifo->eventReader == TRUE;
        }
    }

    return result;
}
8000825a:	00 90       	ret 

8000825c <Ifx_Fifo_read>:
    return count - blockSize;
}

#include <stdio.h>
Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
8000825c:	20 08       	sub.a %sp,8
8000825e:	40 4f       	mov.aa %a15,%a4
80008260:	02 49       	mov %d9,%d4
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
80008262:	df 04 b6 00 	jeq %d4,0,800083ce <Ifx_Fifo_read+0x172>
    {

        buffer.base   = fifo->buffer;
80008266:	4c 40       	ld.w %d15,[%a4]0

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008268:	82 f2       	mov %d2,-1
8000826a:	78 00       	st.w [%sp]0,%d15
        buffer.length = (uint16)fifo->size;         /* size always fit into 16 bit */
8000826c:	8c 4c       	ld.h %d15,[%a4]24
8000826e:	06 f2       	sh %d2,-1
80008270:	ac a3       	st.h [%sp]6,%d15
        buffer.index  = (uint16)fifo->startIndex;   /* startIndex always fit into size */
80008272:	8c 4a       	ld.h %d15,[%a4]20
    {
        deadLine = TIME_INFINITE;
80008274:	82 fa       	mov %d10,-1
80008276:	ac a2       	st.h [%sp]4,%d15

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008278:	ba f6       	eq %d15,%d6,-1
8000827a:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
8000827e:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008280:	ee 16       	jnz %d15,800082ac <Ifx_Fifo_read+0x50>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008282:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008286:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000828a:	0d 00 40 03 	disable 
8000828e:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008290:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008294:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008298:	02 3a       	mov %d10,%d3
8000829a:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000829e:	76 23       	jz %d2,800082a4 <Ifx_Fifo_read+0x48>
    {
        __enable();
800082a0:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
800082a4:	0b 6a 40 a0 	addx %d10,%d10,%d6
800082a8:	0b 78 50 80 	addc %d8,%d8,%d7

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800082ac:	82 fc       	mov %d12,-1
Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
800082ae:	82 0d       	mov %d13,0
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
    fifo->eventReader        = FALSE;
800082b0:	82 0e       	mov %d14,0
    {
        fifo->shared.writerWaitx -= blockSize;

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
800082b2:	a0 0c       	mov.a %a12,0
800082b4:	06 fc       	sh %d12,-1
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800082b6:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
800082ba:	37 04 e1 47 	extr.u %d4,%d4,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800082be:	0d 00 40 03 	disable 
800082c2:	00 00       	nop 
{
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
800082c4:	88 2b       	ld.h %d11,[%a15]4
/** Return minimum of two integers
 */
IFX_INLINE sint32 Ifx__min(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800082c6:	0b b9 80 b1 	min %d11,%d9,%d11
    blockSize               -= blockSize % fifo->elementSize;
800082ca:	8c fd       	ld.h %d15,[%a15]26
800082cc:	37 0b 50 20 	extr %d2,%d11,0,16
    fifo->eventReader        = FALSE;
800082d0:	e9 fe 1c 00 	st.b [%a15]28,%d14
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
800082d4:	4b f2 01 22 	div %e2,%d2,%d15
    fifo->eventReader        = FALSE;
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
800082d8:	88 c2       	ld.h %d2,[%a15]24
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
800082da:	a2 3b       	sub %d11,%d3
800082dc:	37 0b 70 b0 	extr.u %d11,%d11,0,16
800082e0:	37 0b 50 f0 	extr %d15,%d11,0,16
    fifo->eventReader        = FALSE;
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
800082e4:	0b f9 80 30 	sub %d3,%d9,%d15
800082e8:	0b 23 80 21 	min %d2,%d3,%d2
800082ec:	68 22       	st.w [%a15]8,%d2
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800082ee:	76 43       	jz %d4,800082f4 <Ifx_Fifo_read+0x98>
    {
        __enable();
800082f0:	0d 00 00 03 	enable 

        do
        {
            blockSize = Ifx_Fifo_beginRead(fifo, count);

            if (blockSize != 0)
800082f4:	6e 20       	jz %d15,80008334 <Ifx_Fifo_read+0xd8>
            {
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
800082f6:	40 a4       	mov.aa %a4,%sp
800082f8:	02 f4       	mov %d4,%d15
800082fa:	6d ff 66 fe 	call 80007fc6 <Ifx_CircularBuffer_read8>
800082fe:	40 25       	mov.aa %a5,%a2
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008300:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008304:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008308:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
8000830c:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState      = IfxCpu_disableInterrupts();

    fifo->shared.count -= blockSize;
8000830e:	88 23       	ld.h %d3,[%a15]4
80008310:	a2 b3       	sub %d3,%d11
80008312:	a8 23       	st.h [%a15]4,%d3

    if (fifo->shared.writerWaitx != 0)
80008314:	48 33       	ld.w %d3,[%a15]12
80008316:	76 39       	jz %d3,80008328 <Ifx_Fifo_read+0xcc>
    {
        fifo->shared.writerWaitx -= blockSize;
80008318:	5a f3       	sub %d15,%d3,%d15

        if (fifo->shared.writerWaitx <= 0)
8000831a:	8e f3       	jlez %d15,80008320 <Ifx_Fifo_read+0xc4>

    fifo->shared.count -= blockSize;

    if (fifo->shared.writerWaitx != 0)
    {
        fifo->shared.writerWaitx -= blockSize;
8000831c:	68 3f       	st.w [%a15]12,%d15
8000831e:	3c 05       	j 80008328 <Ifx_Fifo_read+0xcc>

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
            fifo->eventWriter        = TRUE; /* Signal the writer */
80008320:	82 1f       	mov %d15,1
    {
        fifo->shared.writerWaitx -= blockSize;

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
80008322:	e8 3c       	st.a [%a15]12,%a12
            fifo->eventWriter        = TRUE; /* Signal the writer */
80008324:	e9 ff 1d 00 	st.b [%a15]29,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008328:	76 23       	jz %d2,8000832e <Ifx_Fifo_read+0xd2>
    {
        __enable();
8000832a:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
8000832e:	a2 b9       	sub %d9,%d11
80008330:	37 09 50 90 	extr %d9,%d9,0,16
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80008334:	76 d4       	jz %d13,8000833c <Ifx_Fifo_read+0xe0>
            {
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
80008336:	82 0f       	mov %d15,0
80008338:	68 2f       	st.w [%a15]8,%d15
                break;
8000833a:	3c 48       	j 800083ca <Ifx_Fifo_read+0x16e>
8000833c:	ba fa       	eq %d15,%d10,-1
8000833e:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
80008342:	ee 1b       	jnz %d15,80008378 <Ifx_Fifo_read+0x11c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008344:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008348:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000834c:	0d 00 40 03 	disable 
80008350:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008352:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008356:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000835a:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000835e:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008362:	76 23       	jz %d2,80008368 <Ifx_Fifo_read+0x10c>
    {
        __enable();
80008364:	0d 00 00 03 	enable 
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80008368:	0b 8f 00 21 	eq %d2,%d15,%d8
8000836c:	0b a3 50 22 	and.ge.u %d2,%d3,%d10
80008370:	0b f8 90 22 	or.lt %d2,%d8,%d15
80008374:	df 02 e1 ff 	jne %d2,0,80008336 <Ifx_Fifo_read+0xda>
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
                break;
            }

            if (count != 0)
80008378:	df 09 29 00 	jeq %d9,0,800083ca <Ifx_Fifo_read+0x16e>
            {
                while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
8000837c:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80008380:	ee 1f       	jnz %d15,800083be <Ifx_Fifo_read+0x162>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008382:	ba fa       	eq %d15,%d10,-1
80008384:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
80008388:	ee fa       	jnz %d15,8000837c <Ifx_Fifo_read+0x120>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000838a:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000838e:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008392:	0d 00 40 03 	disable 
80008396:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008398:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000839c:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800083a0:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800083a4:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800083a8:	76 23       	jz %d2,800083ae <Ifx_Fifo_read+0x152>
    {
        __enable();
800083aa:	0d 00 00 03 	enable 
800083ae:	0b 8f 00 21 	eq %d2,%d15,%d8
800083b2:	0b a3 30 22 	and.lt.u %d2,%d3,%d10
800083b6:	0b 8f 90 22 	or.lt %d2,%d15,%d8
800083ba:	df 02 e1 ff 	jne %d2,0,8000837c <Ifx_Fifo_read+0x120>
                {}

                Stop = (fifo->eventReader == FALSE);    /* If the function timeout, the maximum number of characters are read before returning */
800083be:	39 fd 1c 00 	ld.bu %d13,[%a15]28
800083c2:	8b 0d 00 d2 	eq %d13,%d13,0
800083c6:	1d ff 78 ff 	j 800082b6 <Ifx_Fifo_read+0x5a>
            }
        } while (count != 0);

        fifo->startIndex = buffer.index;
800083ca:	8c a2       	ld.h %d15,[%sp]4
800083cc:	a8 af       	st.h [%a15]20,%d15
    }

    return count;
}
800083ce:	02 92       	mov %d2,%d9
800083d0:	00 90       	ret 

800083d2 <Ifx_Fifo_clear>:
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800083d2:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800083d6:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800083da:	0d 00 40 03 	disable 
800083de:	00 00       	nop 
{
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();

    if (fifo->shared.writerWaitx != 0)
800083e0:	4c 43       	ld.w %d15,[%a4]12
800083e2:	6e 06       	jz %d15,800083ee <Ifx_Fifo_clear+0x1c>
    {
        fifo->shared.writerWaitx = 0;
800083e4:	82 0f       	mov %d15,0
800083e6:	6c 43       	st.w [%a4]12,%d15
        fifo->eventWriter        = TRUE; /* Signal the writer */
800083e8:	82 1f       	mov %d15,1
800083ea:	e9 4f 1d 00 	st.b [%a4]29,%d15
    }

    fifo->eventReader        = FALSE;
800083ee:	82 0f       	mov %d15,0
800083f0:	e9 4f 1c 00 	st.b [%a4]28,%d15
    fifo->shared.readerWaitx = 0;
800083f4:	82 0f       	mov %d15,0
800083f6:	6c 42       	st.w [%a4]8,%d15
    fifo->shared.count       = 0;
800083f8:	ac 42       	st.h [%a4]4,%d15
    fifo->shared.maxcount    = 0;
800083fa:	ac 48       	st.h [%a4]16,%d15
    fifo->startIndex         = fifo->endIndex;
800083fc:	8c 4b       	ld.h %d15,[%a4]22
800083fe:	ac 4a       	st.h [%a4]20,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008400:	76 23       	jz %d2,80008406 <Ifx_Fifo_clear+0x34>
    {
        __enable();
80008402:	0d 00 00 03 	enable 
80008406:	00 90       	ret 

80008408 <Ifx_Fifo_canWriteCount>:
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);


    if ((count < fifo->elementSize) || (count > fifo->size))
80008408:	8c 4d       	ld.h %d15,[%a4]26
    {                           /* Only complete elements can be written to the buffer */
        result = FALSE;
8000840a:	82 02       	mov %d2,0
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);


    if ((count < fifo->elementSize) || (count > fifo->size))
8000840c:	3f f4 75 00 	jlt %d4,%d15,800084f6 <Ifx_Fifo_canWriteCount+0xee>
80008410:	8c 4c       	ld.h %d15,[%a4]24
80008412:	3f 4f 72 00 	jlt %d15,%d4,800084f6 <Ifx_Fifo_canWriteCount+0xee>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008416:	4d c0 e2 0f 	mfcr %d0,$icr
    return reg.B.IE != 0;
8000841a:	37 00 e1 07 	extr.u %d0,%d0,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000841e:	0d 00 40 03 	disable 
80008422:	00 00       	nop 
    else
    {
        boolean interruptState;
        interruptState = IfxCpu_disableInterrupts();

        if ((fifo->size - Ifx_Fifo_readCount(fifo)) >= count)
80008424:	c9 43 18 00 	ld.h %d3,[%a4]24
80008428:	8c 42       	ld.h %d15,[%a4]4
8000842a:	5a f3       	sub %d15,%d3,%d15
8000842c:	3f 4f 0d 00 	jlt %d15,%d4,80008446 <Ifx_Fifo_canWriteCount+0x3e>
        {
            fifo->shared.writerWaitx = 0;
            fifo->eventWriter        = TRUE;
80008430:	82 1f       	mov %d15,1
        boolean interruptState;
        interruptState = IfxCpu_disableInterrupts();

        if ((fifo->size - Ifx_Fifo_readCount(fifo)) >= count)
        {
            fifo->shared.writerWaitx = 0;
80008432:	59 42 0c 00 	st.w [%a4]12,%d2
            fifo->eventWriter        = TRUE;
80008436:	e9 4f 1d 00 	st.b [%a4]29,%d15
            IfxCpu_restoreInterrupts(interruptState);
            result                   = TRUE;
8000843a:	82 12       	mov %d2,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000843c:	df 00 5d 00 	jeq %d0,0,800084f6 <Ifx_Fifo_canWriteCount+0xee>
    {
        __enable();
80008440:	0d 00 00 03 	enable 
80008444:	00 90       	ret 

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008446:	82 f2       	mov %d2,-1
80008448:	06 f2       	sh %d2,-1
8000844a:	ba f6       	eq %d15,%d6,-1
8000844c:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
80008450:	82 f5       	mov %d5,-1
80008452:	02 23       	mov %d3,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008454:	ee 16       	jnz %d15,80008480 <Ifx_Fifo_canWriteCount+0x78>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008456:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000845a:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000845e:	0d 00 40 03 	disable 
80008462:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008464:	85 f1 10 00 	ld.w %d1,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008468:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000846c:	02 15       	mov %d5,%d1
8000846e:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008472:	76 23       	jz %d2,80008478 <Ifx_Fifo_canWriteCount+0x70>
    {
        __enable();
80008474:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008478:	0b 65 40 50 	addx %d5,%d5,%d6
8000847c:	0b 73 50 30 	addc %d3,%d3,%d7
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
80008480:	82 0f       	mov %d15,0
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
80008482:	c9 42 04 00 	ld.h %d2,[%a4]4
            result                   = TRUE;
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
80008486:	e9 4f 1d 00 	st.b [%a4]29,%d15
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
8000848a:	8c 4c       	ld.h %d15,[%a4]24
8000848c:	5a f2       	sub %d15,%d2,%d15
8000848e:	42 f4       	add %d4,%d15
/** Return maximum of two integers
 */
IFX_INLINE sint32 Ifx__max(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80008490:	82 02       	mov %d2,0
80008492:	0b 42 a0 41 	max %d4,%d2,%d4
80008496:	59 44 0c 00 	st.w [%a4]12,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000849a:	76 03       	jz %d0,800084a0 <Ifx_Fifo_canWriteCount+0x98>
    {
        __enable();
8000849c:	0d 00 00 03 	enable 

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800084a0:	82 f6       	mov %d6,-1
800084a2:	06 f6       	sh %d6,-1
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800084a4:	39 4f 1d 00 	ld.bu %d15,[%a4]29
800084a8:	6e 08       	jz %d15,800084b8 <Ifx_Fifo_canWriteCount+0xb0>
            {}
            /* After the timeout, the writer is not waiting for any space */
            fifo->shared.writerWaitx = 0;
            result = fifo->eventWriter == TRUE;
800084aa:	39 42 1d 00 	ld.bu %d2,[%a4]29
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
            {}
            /* After the timeout, the writer is not waiting for any space */
            fifo->shared.writerWaitx = 0;
800084ae:	82 0f       	mov %d15,0
800084b0:	6c 43       	st.w [%a4]12,%d15
            result = fifo->eventWriter == TRUE;
800084b2:	8b 12 00 22 	eq %d2,%d2,1
800084b6:	00 90       	ret 
800084b8:	ba f5       	eq %d15,%d5,-1
800084ba:	0b 36 00 f2 	and.eq %d15,%d6,%d3
800084be:	ee f3       	jnz %d15,800084a4 <Ifx_Fifo_canWriteCount+0x9c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800084c0:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800084c4:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800084c8:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800084cc:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800084ce:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800084d2:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800084d6:	8f 04 40 41 	or %d4,%d4,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800084da:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800084de:	76 23       	jz %d2,800084e4 <Ifx_Fifo_canWriteCount+0xdc>
    {
        __enable();
800084e0:	0d 00 00 03 	enable 
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800084e4:	0b 3f 00 21 	eq %d2,%d15,%d3
800084e8:	0b 54 30 22 	and.lt.u %d2,%d4,%d5
800084ec:	0b 3f 90 22 	or.lt %d2,%d15,%d3
800084f0:	df 02 da ff 	jne %d2,0,800084a4 <Ifx_Fifo_canWriteCount+0x9c>
800084f4:	3c db       	j 800084aa <Ifx_Fifo_canWriteCount+0xa2>
            result = fifo->eventWriter == TRUE;
        }
    }

    return result;
}
800084f6:	00 90       	ret 

800084f8 <Ifx_Fifo_write>:
}


#include <stdio.h>
Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
800084f8:	20 08       	sub.a %sp,8
800084fa:	40 4f       	mov.aa %a15,%a4
800084fc:	02 49       	mov %d9,%d4
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
800084fe:	df 04 be 00 	jeq %d4,0,8000867a <Ifx_Fifo_write+0x182>
    {
        buffer.base   = fifo->buffer;
80008502:	4c 40       	ld.w %d15,[%a4]0

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008504:	82 f2       	mov %d2,-1
80008506:	78 00       	st.w [%sp]0,%d15
        buffer.length = (uint16)fifo->size;     /* size always fit into 16 bit */
80008508:	8c 4c       	ld.h %d15,[%a4]24
8000850a:	06 f2       	sh %d2,-1
8000850c:	ac a3       	st.h [%sp]6,%d15
        buffer.index  = (uint16)fifo->endIndex; /* startIndex always fit into size */
8000850e:	8c 4b       	ld.h %d15,[%a4]22
    {
        deadLine = TIME_INFINITE;
80008510:	82 fa       	mov %d10,-1
80008512:	ac a2       	st.h [%sp]4,%d15

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008514:	ba f6       	eq %d15,%d6,-1
80008516:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
8000851a:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
8000851c:	ee 16       	jnz %d15,80008548 <Ifx_Fifo_write+0x50>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000851e:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008522:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008526:	0d 00 40 03 	disable 
8000852a:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000852c:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008530:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008534:	02 3a       	mov %d10,%d3
80008536:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000853a:	76 23       	jz %d2,80008540 <Ifx_Fifo_write+0x48>
    {
        __enable();
8000853c:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008540:	0b 6a 40 a0 	addx %d10,%d10,%d6
80008544:	0b 78 50 80 	addc %d8,%d8,%d7

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008548:	82 fc       	mov %d12,-1
Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
8000854a:	82 0d       	mov %d13,0
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
    fifo->eventWriter        = FALSE;
8000854c:	82 0e       	mov %d14,0
    {
        fifo->shared.readerWaitx -= blockSize;

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
8000854e:	a0 0c       	mov.a %a12,0
80008550:	06 fc       	sh %d12,-1
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008552:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80008556:	37 05 e1 57 	extr.u %d5,%d5,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000855a:	0d 00 40 03 	disable 
8000855e:	00 00       	nop 
{
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
80008560:	88 c4       	ld.h %d4,[%a15]24
80008562:	88 2b       	ld.h %d11,[%a15]4
80008564:	0b b4 80 b0 	sub %d11,%d4,%d11
/** Return minimum of two integers
 */
IFX_INLINE sint32 Ifx__min(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80008568:	0b b9 80 b1 	min %d11,%d9,%d11
    blockSize               -= blockSize % fifo->elementSize;
8000856c:	8c fd       	ld.h %d15,[%a15]26
8000856e:	37 0b 50 20 	extr %d2,%d11,0,16
    fifo->eventWriter        = FALSE;
80008572:	e9 fe 1d 00 	st.b [%a15]29,%d14
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
80008576:	4b f2 01 22 	div %e2,%d2,%d15
8000857a:	a2 3b       	sub %d11,%d3
8000857c:	37 0b 70 b0 	extr.u %d11,%d11,0,16
80008580:	37 0b 50 f0 	extr %d15,%d11,0,16
    fifo->eventWriter        = FALSE;
    fifo->shared.writerWaitx = __min(count - blockSize, fifo->size);
80008584:	0b f9 80 20 	sub %d2,%d9,%d15
80008588:	0b 42 80 41 	min %d4,%d2,%d4
8000858c:	68 34       	st.w [%a15]12,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000858e:	76 53       	jz %d5,80008594 <Ifx_Fifo_write+0x9c>
    {
        __enable();
80008590:	0d 00 00 03 	enable 

        do
        {
            blockSize = Ifx_Fifo_beginWrite(fifo, count);

            if (blockSize != 0)
80008594:	6e 26       	jz %d15,800085e0 <Ifx_Fifo_write+0xe8>
            {

                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
80008596:	40 a4       	mov.aa %a4,%sp
80008598:	02 f4       	mov %d4,%d15
8000859a:	6d ff 6d fd 	call 80008074 <Ifx_CircularBuffer_write8>
8000859e:	40 25       	mov.aa %a5,%a2
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800085a0:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
800085a4:	37 03 e1 37 	extr.u %d3,%d3,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800085a8:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800085ac:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
800085ae:	88 22       	ld.h %d2,[%a15]4
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
800085b0:	88 84       	ld.h %d4,[%a15]16
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
800085b2:	42 b2       	add %d2,%d11
800085b4:	37 02 50 20 	extr %d2,%d2,0,16
800085b8:	a8 22       	st.h [%a15]4,%d2
/** Return maximum of two integers
 */
IFX_INLINE sint32 Ifx__max(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800085ba:	0b 24 a0 21 	max %d2,%d4,%d2
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
800085be:	a8 82       	st.h [%a15]16,%d2

    if (fifo->shared.readerWaitx != 0)
800085c0:	48 22       	ld.w %d2,[%a15]8
800085c2:	76 29       	jz %d2,800085d4 <Ifx_Fifo_write+0xdc>
    {
        fifo->shared.readerWaitx -= blockSize;
800085c4:	5a f2       	sub %d15,%d2,%d15

        if (fifo->shared.readerWaitx <= 0)
800085c6:	8e f3       	jlez %d15,800085cc <Ifx_Fifo_write+0xd4>
    fifo->shared.count   += blockSize;
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */

    if (fifo->shared.readerWaitx != 0)
    {
        fifo->shared.readerWaitx -= blockSize;
800085c8:	68 2f       	st.w [%a15]8,%d15
800085ca:	3c 05       	j 800085d4 <Ifx_Fifo_write+0xdc>

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
800085cc:	82 1f       	mov %d15,1
    {
        fifo->shared.readerWaitx -= blockSize;

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
800085ce:	e8 2c       	st.a [%a15]8,%a12
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
800085d0:	e9 ff 1c 00 	st.b [%a15]28,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800085d4:	76 33       	jz %d3,800085da <Ifx_Fifo_write+0xe2>
    {
        __enable();
800085d6:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
800085da:	a2 b9       	sub %d9,%d11
800085dc:	37 09 50 90 	extr %d9,%d9,0,16
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
800085e0:	76 d4       	jz %d13,800085e8 <Ifx_Fifo_write+0xf0>
            {
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
800085e2:	82 0f       	mov %d15,0
800085e4:	68 3f       	st.w [%a15]12,%d15
                break;
800085e6:	3c 48       	j 80008676 <Ifx_Fifo_write+0x17e>
800085e8:	ba fa       	eq %d15,%d10,-1
800085ea:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
800085ee:	ee 1b       	jnz %d15,80008624 <Ifx_Fifo_write+0x12c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800085f0:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800085f4:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800085f8:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800085fc:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800085fe:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008602:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80008606:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000860a:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000860e:	76 23       	jz %d2,80008614 <Ifx_Fifo_write+0x11c>
    {
        __enable();
80008610:	0d 00 00 03 	enable 
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80008614:	0b 8f 00 21 	eq %d2,%d15,%d8
80008618:	0b a3 50 22 	and.ge.u %d2,%d3,%d10
8000861c:	0b f8 90 22 	or.lt %d2,%d8,%d15
80008620:	df 02 e1 ff 	jne %d2,0,800085e2 <Ifx_Fifo_write+0xea>
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
                break;
            }

            if (count != 0)
80008624:	df 09 29 00 	jeq %d9,0,80008676 <Ifx_Fifo_write+0x17e>
            {
                while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008628:	39 ff 1d 00 	ld.bu %d15,[%a15]29
8000862c:	ee 1f       	jnz %d15,8000866a <Ifx_Fifo_write+0x172>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000862e:	ba fa       	eq %d15,%d10,-1
80008630:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
80008634:	ee fa       	jnz %d15,80008628 <Ifx_Fifo_write+0x130>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008636:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000863a:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000863e:	0d 00 40 03 	disable 
80008642:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008644:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008648:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
8000864c:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008650:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008654:	76 23       	jz %d2,8000865a <Ifx_Fifo_write+0x162>
    {
        __enable();
80008656:	0d 00 00 03 	enable 
8000865a:	0b 8f 00 21 	eq %d2,%d15,%d8
8000865e:	0b a3 30 22 	and.lt.u %d2,%d3,%d10
80008662:	0b 8f 90 22 	or.lt %d2,%d15,%d8
80008666:	df 02 e1 ff 	jne %d2,0,80008628 <Ifx_Fifo_write+0x130>
                {}

                Stop = fifo->eventWriter == FALSE;  /* If the function timeout, the maximum number of characters are written before returning */
8000866a:	39 fd 1d 00 	ld.bu %d13,[%a15]29
8000866e:	8b 0d 00 d2 	eq %d13,%d13,0
80008672:	1d ff 70 ff 	j 80008552 <Ifx_Fifo_write+0x5a>
            }
        } while (count != 0);

        fifo->endIndex = buffer.index;
80008676:	8c a2       	ld.h %d15,[%sp]4
80008678:	a8 bf       	st.h [%a15]22,%d15
    }

    return count;
}
8000867a:	02 92       	mov %d2,%d9
8000867c:	00 90       	ret 

8000867e <osEE_tc_core0_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000867e:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008682:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008686:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000868a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000868e:	54 25       	ld.w %d5,[%a2]
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008690:	48 08       	ld.w %d8,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008692:	37 05 6e 51 	extr.u %d5,%d5,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008696:	37 08 6e 81 	extr.u %d8,%d8,2,14
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000869a:	91 20 00 f7 	movh.a %a15,28674
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
8000869e:	8f f5 83 51 	xor %d5,%d5,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
800086a2:	8f f8 83 81 	xor %d8,%d8,63
800086a6:	d9 ff 40 89 	lea %a15,[%a15]-27136 <70019600 <__USTACK0>>
800086aa:	40 fa       	mov.aa %sp,%a15
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
800086ac:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
800086b0:	3b 00 b8 f0 	mov %d15,2944
800086b4:	cd 4f e0 0f 	mtcr $psw,%d15
800086b8:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
800086bc:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
800086c0:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
800086c4:	cd 0f e0 0f 	mtcr $pcxi,%d15
800086c8:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
800086cc:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
800086d0:	82 12       	mov %d2,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
800086d2:	37 0f 48 f0 	extr %d15,%d15,0,8
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
800086d6:	cd 42 20 09 	mtcr $pcon1,%d2
800086da:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800086de:	53 cf 20 f0 	mul %d15,%d15,12
800086e2:	10 22       	addsc.a %a2,%a2,%d15,0
800086e4:	54 22       	ld.w %d2,[%a2]
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
800086e6:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800086e8:	37 02 6e 21 	extr.u %d2,%d2,2,14
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
800086ec:	d9 2f 00 46 	lea %a15,[%a2]24832
800086f0:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800086f4:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
800086f6:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800086fa:	2e 16       	jz.t %d15,1,80008706 <osEE_tc_core0_start+0x88>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800086fc:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008700:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008704:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008706:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000870a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000870e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008710:	4c f0       	ld.w %d15,[%a15]0
80008712:	6f 0f ff ff 	jnz.t %d15,0,80008710 <osEE_tc_core0_start+0x92>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
80008716:	82 0f       	mov %d15,0
80008718:	cd cf 20 09 	mtcr $pcon0,%d15
8000871c:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008720:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008722:	2e 16       	jz.t %d15,1,8000872e <osEE_tc_core0_start+0xb0>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008724:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008728:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000872c:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000872e:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008732:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008736:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008738:	4c f0       	ld.w %d15,[%a15]0
8000873a:	6f 0f ff 7f 	jz.t %d15,0,80008738 <osEE_tc_core0_start+0xba>
8000873e:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80008742:	37 0f 48 f0 	extr %d15,%d15,0,8
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008746:	91 30 00 ff 	movh.a %a15,61443
8000874a:	53 cf 20 f0 	mul %d15,%d15,12
8000874e:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008752:	10 ff       	addsc.a %a15,%a15,%d15,0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008754:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008756:	48 02       	ld.w %d2,[%a15]0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008758:	d9 2f 00 46 	lea %a15,[%a2]24832
8000875c:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008760:	37 02 6e 21 	extr.u %d2,%d2,2,14
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008764:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008766:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000876a:	2e 16       	jz.t %d15,1,80008776 <osEE_tc_core0_start+0xf8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000876c:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008770:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008774:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008776:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
8000877a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000877e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008780:	4c f0       	ld.w %d15,[%a15]0
80008782:	6f 0f ff ff 	jnz.t %d15,0,80008780 <osEE_tc_core0_start+0x102>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
80008786:	82 0f       	mov %d15,0
80008788:	cd 0f 04 09 	mtcr $dcon0,%d15
8000878c:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008790:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008792:	2e 16       	jz.t %d15,1,8000879e <osEE_tc_core0_start+0x120>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008794:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008798:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000879c:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000879e:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
800087a2:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800087a6:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800087a8:	4c f0       	ld.w %d15,[%a15]0
800087aa:	6f 0f ff 7f 	jz.t %d15,0,800087a8 <osEE_tc_core0_start+0x12a>
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800087ae:	91 30 00 ff 	movh.a %a15,61443
800087b2:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800087b6:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800087b8:	2e 16       	jz.t %d15,1,800087c4 <osEE_tc_core0_start+0x146>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800087ba:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800087be:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800087c2:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
800087c4:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
800087c8:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800087cc:	91 30 00 ff 	movh.a %a15,61443
800087d0:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800087d4:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800087d6:	4c f0       	ld.w %d15,[%a15]0
800087d8:	91 30 00 2f 	movh.a %a2,61443
800087dc:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800087e0:	6f 0f fb ff 	jnz.t %d15,0,800087d6 <osEE_tc_core0_start+0x158>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(0U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB0);
800087e4:	7b 00 00 f8 	movh %d15,32768
800087e8:	1b 0f 10 f1 	addi %d15,%d15,4352
800087ec:	cd 4f e2 0f 	mtcr $btv,%d15
800087f0:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB0);
800087f4:	7b 00 00 f8 	movh %d15,32768
800087f8:	1b 0f 00 f2 	addi %d15,%d15,8192
800087fc:	cd 0f e2 0f 	mtcr $biv,%d15
80008800:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK0);
80008804:	7b 20 00 f7 	movh %d15,28674
80008808:	1b 0f b0 f9 	addi %d15,%d15,-25856
8000880c:	cd 8f e2 0f 	mtcr $isp,%d15
80008810:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008814:	4c 20       	ld.w %d15,[%a2]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008816:	2e 16       	jz.t %d15,1,80008822 <osEE_tc_core0_start+0x1a4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008818:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000881c:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008820:	6c 20       	st.w [%a2]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008822:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008826:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000882a:	91 30 00 ff 	movh.a %a15,61443
8000882e:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008832:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008834:	4c f0       	ld.w %d15,[%a15]0
80008836:	6f 0f ff 7f 	jz.t %d15,0,80008834 <osEE_tc_core0_start+0x1b6>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(0U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
8000883a:	91 10 00 f7 	movh.a %a15,28673
8000883e:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
80008842:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
80008844:	91 10 00 f8 	movh.a %a15,32769
80008848:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
8000884c:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
8000884e:	91 10 00 f8 	movh.a %a15,32769
80008852:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80008856:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_SINGLECORE)) || (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
80008858:	91 10 00 fb 	movh.a %a15,45057
8000885c:	d9 ff 00 08 	lea %a15,[%a15]-32768 <b0008000 <_SMALL_DATA4_>>
80008860:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
80008862:	7b 20 00 f7 	movh %d15,28674
80008866:	7b 20 00 47 	movh %d4,28674
8000886a:	1b 0f c0 69 	addi %d6,%d15,-25600
8000886e:	1b 04 c0 4b 	addi %d4,%d4,-17408
80008872:	a2 64       	sub %d4,%d6
80008874:	86 a4       	sha %d4,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
80008876:	82 02       	mov %d2,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
80008878:	df 04 16 00 	jeq %d4,0,800088a4 <osEE_tc_core0_start+0x226>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
8000887c:	9a f4       	add %d15,%d4,-1
8000887e:	06 6f       	sh %d15,6
80008880:	12 63       	add %d3,%d15,%d6

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008882:	60 3f       	mov.a %a15,%d3
80008884:	82 00       	mov %d0,0
80008886:	68 00       	st.w [%a15]0,%d0
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008888:	60 4f       	mov.a %a15,%d4
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
8000888a:	8f 43 1e 20 	sh %d2,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000888e:	37 03 70 73 	extr.u %d7,%d3,6,16
80008892:	1b 0f fc ff 	addi %d15,%d15,-64

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008896:	b0 ff       	add.a %a15,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008898:	37 27 10 28 	insert %d2,%d7,%d2,16,16
8000889c:	42 6f       	add %d15,%d6

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000889e:	82 53       	mov %d3,5
800088a0:	fd f0 11 01 	loop %a15,80008ac2 <osEE_tc_core0_start+0x444>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
800088a4:	cd 82 e3 0f 	mtcr $fcx,%d2
800088a8:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800088ac:	91 30 00 ff 	movh.a %a15,61443
800088b0:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800088b4:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800088b6:	2e 16       	jz.t %d15,1,800088c2 <osEE_tc_core0_start+0x244>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800088b8:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800088bc:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800088c0:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
800088c2:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
800088c6:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800088ca:	91 30 00 ff 	movh.a %a15,61443
800088ce:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800088d2:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800088d4:	40 f2       	mov.aa %a2,%a15
800088d6:	4c 20       	ld.w %d15,[%a2]0
800088d8:	91 30 00 ff 	movh.a %a15,61443
800088dc:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800088e0:	6f 0f fb ff 	jnz.t %d15,0,800088d6 <osEE_tc_core0_start+0x258>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
800088e4:	4c f1       	ld.w %d15,[%a15]4
800088e6:	96 08       	or %d15,8
800088e8:	68 1f       	st.w [%a15]4,%d15
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800088ea:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800088ec:	2e 16       	jz.t %d15,1,800088f8 <osEE_tc_core0_start+0x27a>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800088ee:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800088f2:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800088f6:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
800088f8:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
800088fc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008900:	91 30 00 ff 	movh.a %a15,61443
80008904:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008908:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
8000890a:	4c f0       	ld.w %d15,[%a15]0
8000890c:	6f 0f ff 7f 	jz.t %d15,0,8000890a <osEE_tc_core0_start+0x28c>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008910:	91 30 00 ff 	movh.a %a15,61443
80008914:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008918:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000891a:	2e 16       	jz.t %d15,1,80008926 <osEE_tc_core0_start+0x2a8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000891c:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008920:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008924:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80008926:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
8000892a:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
8000892e:	91 30 00 ff 	movh.a %a15,61443
80008932:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008936:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80008938:	40 f2       	mov.aa %a2,%a15
8000893a:	4c 20       	ld.w %d15,[%a2]0
8000893c:	91 30 00 ff 	movh.a %a15,61443
80008940:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008944:	6f 0f fb ff 	jnz.t %d15,0,8000893a <osEE_tc_core0_start+0x2bc>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
80008948:	4c f1       	ld.w %d15,[%a15]4
8000894a:	96 08       	or %d15,8
8000894c:	68 1f       	st.w [%a15]4,%d15
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000894e:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008950:	2e 16       	jz.t %d15,1,8000895c <osEE_tc_core0_start+0x2de>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008952:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008956:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000895a:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
8000895c:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
80008960:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80008964:	91 30 00 ff 	movh.a %a15,61443
80008968:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000896c:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000896e:	4c f0       	ld.w %d15,[%a15]0
80008970:	6f 0f ff 7f 	jz.t %d15,0,8000896e <osEE_tc_core0_start+0x2f0>
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
80008974:	91 00 00 48 	movh.a %a4,32768
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
        *block_to_clear.p_ull = 0ULL;
80008978:	d2 02       	mov %e2,0
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
8000897a:	d9 44 cc e0 	lea %a4,[%a4]3980 <80000f8c <__clear_table>>
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
        *block_to_clear.p_ui = 0x0U;
8000897e:	82 07       	mov %d7,0
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
        *block_to_clear.p_us = 0x0U;
80008980:	82 06       	mov %d6,0
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
        *block_to_clear.p_uc = 0x0U;
80008982:	82 05       	mov %d5,0

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
80008984:	4c 41       	ld.w %d15,[%a4]4
  while (p_clear_table != NULL) {
    OsEE_tc_init_table_entry_ptr  block_to_clear;
    MemSize                       table_entry_length;

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;
80008986:	d4 43       	ld.a %a3,[%a4]

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
80008988:	9e f6       	jeq %d15,-1,800089b4 <osEE_tc_core0_start+0x336>
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
8000898a:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
8000898e:	76 49       	jz %d4,800089a0 <osEE_tc_core0_start+0x322>
        *block_to_clear.p_ull = 0ULL;
80008990:	60 4f       	mov.a %a15,%d4
80008992:	40 32       	mov.aa %a2,%a3
80008994:	b0 ff       	add.a %a15,-1
80008996:	89 22 48 01 	st.d [%a2+]8,%e2
8000899a:	fc fe       	loop %a15,80008996 <osEE_tc_core0_start+0x318>
8000899c:	01 34 03 36 	addsc.a %a3,%a3,%d4,3
        ++block_to_clear.p_ull;
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
800089a0:	2e 22       	jz.t %d15,2,800089a4 <osEE_tc_core0_start+0x326>
        *block_to_clear.p_ui = 0x0U;
800089a2:	64 37       	st.w [%a3+],%d7
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
800089a4:	2e 12       	jz.t %d15,1,800089a8 <osEE_tc_core0_start+0x32a>
        *block_to_clear.p_us = 0x0U;
800089a6:	a4 36       	st.h [%a3+],%d6
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
800089a8:	2e 02       	jz.t %d15,0,800089ac <osEE_tc_core0_start+0x32e>
        *block_to_clear.p_uc = 0x0U;
800089aa:	34 35       	st.b [%a3],%d5
      }

/* Prepare the table pointer for the next iteration */
      ++p_clear_table;
800089ac:	d9 44 08 00 	lea %a4,[%a4]8 <80000008 <BootModeHeader0+0x8>>
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
  while (p_clear_table != NULL) {
800089b0:	bd 04 ea ff 	jnz.a %a4,80008984 <osEE_tc_core0_start+0x306>
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
800089b4:	91 00 00 68 	movh.a %a6,32768
800089b8:	d9 66 f4 f0 	lea %a6,[%a6]4084 <80000ff4 <__copy_table>>

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
800089bc:	4c 62       	ld.w %d15,[%a6]8
    OsEE_tc_init_table_entry_ptr  block_src;
    OsEE_tc_init_table_entry_ptr  block_dest;
    MemSize                       table_entry_length;

/* Get pointer to the data source block */
    block_src = p_copy_table->block_src;
800089be:	d4 65       	ld.a %a5,[%a6]

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;
800089c0:	99 64 04 00 	ld.a %a4,[%a6]4 <80000004 <BootModeHeader0+0x4>>

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
800089c4:	df ff 21 00 	jeq %d15,-1,80008a06 <osEE_tc_core0_start+0x388>
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
800089c8:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
800089cc:	76 4f       	jz %d4,800089ea <osEE_tc_core0_start+0x36c>
800089ce:	60 4f       	mov.a %a15,%d4
800089d0:	40 43       	mov.aa %a3,%a4
800089d2:	40 52       	mov.aa %a2,%a5
800089d4:	b0 ff       	add.a %a15,-1
        *block_dest.p_ull = *block_src.p_ull;
800089d6:	09 22 48 01 	ld.d %e2,[%a2+]8
800089da:	89 32 48 01 	st.d [%a3+]8,%e2
800089de:	fc fc       	loop %a15,800089d6 <osEE_tc_core0_start+0x358>
800089e0:	06 34       	sh %d4,3
800089e2:	01 54 00 56 	addsc.a %a5,%a5,%d4,0
800089e6:	01 44 00 46 	addsc.a %a4,%a4,%d4,0
        ++block_dest.p_ull;
        --ull_cnt;
      }

/* Copy the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
800089ea:	2e 23       	jz.t %d15,2,800089f0 <osEE_tc_core0_start+0x372>
        *block_dest.p_ui = *block_src.p_ui;
800089ec:	44 52       	ld.w %d2,[%a5+]
800089ee:	64 42       	st.w [%a4+],%d2
        ++block_src.p_ui;
        ++block_dest.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
800089f0:	2e 14       	jz.t %d15,1,800089f8 <osEE_tc_core0_start+0x37a>
        *block_dest.p_us = *block_src.p_us;
800089f2:	09 52 c2 00 	ld.hu %d2,[%a5+]2
800089f6:	a4 42       	st.h [%a4+],%d2
        ++block_src.p_us;
        ++block_dest.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
800089f8:	2e 03       	jz.t %d15,0,800089fe <osEE_tc_core0_start+0x380>
        *block_dest.p_uc = *block_src.p_uc;
800089fa:	0c 50       	ld.bu %d15,[%a5]0
800089fc:	2c 40       	st.b [%a4]0,%d15
      }

/* Prepare the table pointer for the next iteration */
      ++p_copy_table;
800089fe:	d9 66 0c 00 	lea %a6,[%a6]12 <8000000c <BootModeHeader0+0xc>>
(
  const OsEE_tc_copy_table * p_copy_table_param
)
{
  const OsEE_tc_copy_table * p_copy_table = p_copy_table_param;
  while (p_copy_table != NULL) {
80008a02:	bd 06 dd ff 	jnz.a %a6,800089bc <osEE_tc_core0_start+0x33e>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008a06:	91 30 00 ff 	movh.a %a15,61443
80008a0a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008a0e:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008a10:	2e 16       	jz.t %d15,1,80008a1c <osEE_tc_core0_start+0x39e>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008a12:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008a16:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008a1a:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80008a1c:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
80008a20:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80008a24:	91 30 00 ff 	movh.a %a15,61443
80008a28:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008a2c:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80008a2e:	4c f0       	ld.w %d15,[%a15]0
80008a30:	6f 0f ff ff 	jnz.t %d15,0,80008a2e <osEE_tc_core0_start+0x3b0>
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON8_OFF) = OSEE_TC_SCU_CCUCON8_INIT;
#endif /* OSEE_TC_SCU_CCUCON8_INIT */

/* BUS Divisors */
/* Configure CCUCON0 */
  OSEE_TC_SCU_CCUCON0.reg = OSEE_TC_SCU_CCUCON0_INIT;
80008a34:	7b 20 22 f1 	movh %d15,4642
80008a38:	91 30 00 ff 	movh.a %a15,61443
80008a3c:	1b 1f 10 f0 	addi %d15,%d15,257
80008a40:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008a44:	68 0f       	st.w [%a15]0,%d15
#if (defined(OSEE_TC_SCU_CCUCON5_INIT))
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON5_OFF) = OSEE_TC_SCU_CCUCON5_INIT;
#endif /* OSEE_TC_SCU_CCUCON5_INIT */
/* Configure CCUCON1 and Update CCU 0, 1 & 5. Forced INSEL to 1 even for
   external configuration, otherwise PLL initialization won't work. */
  OSEE_TC_SCU_CCUCON1.reg = OSEE_TC_SCU_CCUCON1_INIT |
80008a46:	7b 00 00 f5 	movh %d15,20480
80008a4a:	91 30 00 ff 	movh.a %a15,61443
80008a4e:	1b 0f 10 f1 	addi %d15,%d15,4352
80008a52:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008a56:	68 0f       	st.w [%a15]0,%d15
{
  /*
   * Default System Oscillator Configuration
   * MODE:    0   -> External Crystal
   */
  OSEE_TC_SCU_OSCCON.reg = OSEE_TC_SCU_OSCCON_OSCRES |
80008a58:	7b 70 00 f0 	movh %d15,7
80008a5c:	91 30 00 ff 	movh.a %a15,61443
80008a60:	1b cf 01 f0 	addi %d15,%d15,28
80008a64:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80008a68:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_OSCCON_GAINSEL | OSEE_TC_SCU_OSCCON_MODE(0U) |
    OSEE_TC_SCU_OSCCON_OSCVAL((OSEE_TC_BOARD_FOSC / 2500000U) - 1U);

  while (OSEE_TC_SCU_OSCCON.bits.plllv == 0U) {
80008a6a:	4c f0       	ld.w %d15,[%a15]0
80008a6c:	6f 1f ff 7f 	jz.t %d15,1,80008a6a <osEE_tc_core0_start+0x3ec>
    ; /* Oscillator not too low */
  }

  while (OSEE_TC_SCU_OSCCON.bits.pllhv == 0U) {
80008a70:	91 30 00 ff 	movh.a %a15,61443
80008a74:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80008a78:	4c f0       	ld.w %d15,[%a15]0
80008a7a:	6f 8f ff 7f 	jz.t %d15,8,80008a78 <osEE_tc_core0_start+0x3fa>
/*===================== Configure CCU Clock Control =========================*/
  osEE_tc_conf_clock_ctrl();
/*===================== Configure Oscillator Control ========================*/
  osEE_tc_conf_osc_ctrl();
/*============================ Configure PLL ================================*/
  osEE_tc_set_pll_fsource(OSEE_CPU_CLOCK);
80008a7e:	7b c0 be 40 	movh %d4,3052
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008a82:	91 30 00 ff 	movh.a %a15,61443
80008a86:	1b 04 20 4c 	addi %d4,%d4,-15872
80008a8a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008a8e:	6d 00 58 00 	call 80008b3e <osEE_tc_set_pll_fsource>
80008a92:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008a94:	2e 16       	jz.t %d15,1,80008aa0 <osEE_tc_core0_start+0x422>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008a96:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008a9a:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008a9e:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80008aa0:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
80008aa4:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80008aa8:	91 30 00 ff 	movh.a %a15,61443
80008aac:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008ab0:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80008ab2:	4c f0       	ld.w %d15,[%a15]0
80008ab4:	6f 0f ff 7f 	jz.t %d15,0,80008ab2 <osEE_tc_core0_start+0x434>
  osEE_tc_set_safety_endinit(safety_wdt_pw);
#endif /* OSEE_CPU_CLOCK */
#endif /* !OSEE_BYPASS_CLOCK_CONFIGURATION */
#endif /* !OSEE_TRICORE_ILLD && !OSEE_TC_2G */

  OSEE_EXIT(main());
80008ab8:	6d ff f5 dc 	call 800044a2 <main>
80008abc:	02 24       	mov %d4,%d2
80008abe:	6d 00 3d 28 	call 8000db38 <_exit>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008ac2:	60 f2       	mov.a %a2,%d15
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80008ac4:	8f 4f 1e 40 	sh %d4,%d15,-28
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008ac8:	74 22       	st.w [%a2],%d2
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008aca:	c2 f3       	add %d3,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008acc:	37 0f 70 23 	extr.u %d2,%d15,6,16
80008ad0:	37 42 10 28 	insert %d2,%d2,%d4,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
80008ad4:	76 36       	jz %d3,80008ae0 <osEE_tc_core0_start+0x462>
80008ad6:	1b 0f fc ff 	addi %d15,%d15,-64
80008ada:	fc f4       	loop %a15,80008ac2 <osEE_tc_core0_start+0x444>
80008adc:	1d ff e4 fe 	j 800088a4 <osEE_tc_core0_start+0x226>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
80008ae0:	cd c2 e3 0f 	mtcr $lcx,%d2
80008ae4:	0d 00 c0 04 	isync 
80008ae8:	3c f7       	j 80008ad6 <osEE_tc_core0_start+0x458>

80008aea <osEE_tc_stm_us_ticks>:
#if (defined(__TASKING__))
#define OS_STOP_SEC_GLOBAL_VAR_CLEARED
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
80008aea:	40 ae       	mov.aa %a14,%sp
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
80008aec:	91 00 00 f7 	movh.a %a15,28672
80008af0:	19 ff c0 00 	ld.w %d15,[%a15]3072 <70000c00 <osEE_tc_stm_freq_khz>>
80008af4:	3b 80 3e 20 	mov %d2,1000
80008af8:	3f 2f 0c 80 	jlt.u %d15,%d2,80008b10 <osEE_tc_stm_us_ticks+0x26>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
80008afc:	7b 20 06 21 	movh %d2,4194
80008b00:	1b 32 dd 24 	addi %d2,%d2,19923
80008b04:	73 2f 68 20 	mul.u %e2,%d15,%d2
80008b08:	8f a3 1f 20 	sh %d2,%d3,-6
80008b0c:	e2 42       	mul %d2,%d4
80008b0e:	00 90       	ret 
  } else if (usec >= OSEE_KILO) {
80008b10:	02 25       	mov %d5,%d2
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
80008b12:	73 f4 0a 20 	mul %d2,%d4,%d15
80008b16:	7b 20 06 31 	movh %d3,4194
80008b1a:	1b 33 dd 34 	addi %d3,%d3,19923
80008b1e:	73 32 68 20 	mul.u %e2,%d2,%d3
80008b22:	8f a3 1f 20 	sh %d2,%d3,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
80008b26:	3f 54 0b 80 	jlt.u %d4,%d5,80008b3c <osEE_tc_stm_us_ticks+0x52>
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
80008b2a:	7b 20 06 21 	movh %d2,4194
80008b2e:	1b 32 dd 24 	addi %d2,%d2,19923
80008b32:	73 24 68 40 	mul.u %e4,%d4,%d2
80008b36:	8f a5 1f 20 	sh %d2,%d5,-6
80008b3a:	e2 f2       	mul %d2,%d15
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
  }
  return ticks;
}
80008b3c:	00 90       	ret 

80008b3e <osEE_tc_set_pll_fsource>:
#define OSEE_TC_K2_MIN      (1U)
#define OSEE_TC_N_MAX       (128U)  /* '7 bits */
#define OSEE_TC_N_MIN       (1U)
#define OSEE_TC_DEV_ALLOWED (2U)

void osEE_tc_set_pll_fsource(OsEE_reg fpll) {
80008b3e:	40 ae       	mov.aa %a14,%sp
  fPllLeastError  = OSEE_TC_CLOCK_MAX;
  fPllError       = OSEE_TC_CLOCK_MAX;

  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
80008b40:	7b e0 e4 20 	movh %d2,3662
80008b44:	1b 12 c0 21 	addi %d2,%d2,7169
80008b48:	0b 24 30 f1 	lt.u %d15,%d4,%d2
80008b4c:	82 22       	mov %d2,2
80008b4e:	ab 12 80 ff 	sel %d15,%d15,%d2,1
80008b52:	60 f4       	mov.a %a4,%d15
80008b54:	53 ff 20 f0 	mul %d15,%d15,15
80008b58:	60 f5       	mov.a %a5,%d15
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80008b5a:	3b 00 01 e0 	mov %d14,16
80008b5e:	82 03       	mov %d3,0
80008b60:	7b c0 be 20 	movh %d2,3052
80008b64:	1b 02 20 2c 	addi %d2,%d2,-15872
80008b68:	02 28       	mov %d8,%d2
80008b6a:	82 01       	mov %d1,0
80008b6c:	82 0b       	mov %d11,0
80008b6e:	82 0d       	mov %d13,0
80008b70:	82 0c       	mov %d12,0
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
80008b72:	7b 10 13 a0 	movh %d10,305
80008b76:	1b 0a d0 a2 	addi %d10,%d10,11520

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
80008b7a:	91 40 0f 60 	movh.a %a6,244
80008b7e:	d9 66 41 02 	lea %a6,[%a6]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
    {
      for (
80008b82:	a0 1d       	mov.a %a13,1
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80008b84:	53 14 40 60 	mul.u %e6,%d4,1
80008b88:	60 62       	mov.a %a2,%d6
80008b8a:	60 73       	mov.a %a3,%d7

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
80008b8c:	91 80 7d f1 	movh.a %a15,6104
80008b90:	d9 ff 41 08 	lea %a15,[%a15]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
        {
          for (
80008b94:	a0 1c       	mov.a %a12,1
80008b96:	3c 5e       	j 80008c52 <osEE_tc_set_pll_fsource+0x114>
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
80008b98:	4b ea 11 62 	div.u %e6,%d10,%d14
80008b9c:	82 07       	mov %d7,0

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
80008b9e:	7b 60 f8 ff 	movh %d15,65414
80008ba2:	1b 0f e0 fe 	addi %d15,%d15,-4608
80008ba6:	0b f6 40 60 	addx %d6,%d6,%d15
80008baa:	8b f7 bf 50 	addc %d5,%d7,-1
80008bae:	ba 05       	eq %d15,%d5,0
80008bb0:	80 67       	mov.d %d7,%a6
80008bb2:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
80008bb6:	8b 05 00 f5 	or.ne %d15,%d5,0
80008bba:	ee 4a       	jnz %d15,80008c4e <osEE_tc_set_pll_fsource+0x110>
    {
      for (
80008bbc:	df 00 56 00 	jeq %d0,0,80008c68 <osEE_tc_set_pll_fsource+0x12a>
80008bc0:	02 e9       	mov %d9,%d14
80008bc2:	80 d0       	mov.d %d0,%a13
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
80008bc4:	60 e7       	mov.a %a7,%d14
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80008bc6:	80 2f       	mov.d %d15,%a2
80008bc8:	73 f0 68 60 	mul.u %e6,%d0,%d15
80008bcc:	80 3f       	mov.d %d15,%a3
80008bce:	03 f0 0a 77 	madd %d7,%d7,%d0,%d15

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
80008bd2:	7b 80 82 fe 	movh %d15,59432
80008bd6:	1b 0f c0 f7 	addi %d15,%d15,31744
80008bda:	0b f6 40 60 	addx %d6,%d6,%d15
80008bde:	8b f7 bf 50 	addc %d5,%d7,-1
80008be2:	ba 05       	eq %d15,%d5,0
80008be4:	80 f7       	mov.d %d7,%a15
80008be6:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
80008bea:	8b 05 00 f5 	or.ne %d15,%d5,0
80008bee:	ee 25       	jnz %d15,80008c38 <osEE_tc_set_pll_fsource+0xfa>
        {
          for (
80008bf0:	0f 23 a0 f0 	or %d15,%d3,%d2
80008bf4:	6e 2d       	jz %d15,80008c4e <osEE_tc_set_pll_fsource+0x110>
80008bf6:	80 c6       	mov.d %d6,%a12
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
80008bf8:	4b 96 11 22 	div.u %e2,%d6,%d9
80008bfc:	02 2f       	mov %d15,%d2
80008bfe:	e2 af       	mul %d15,%d10
80008c00:	a2 4f       	sub %d15,%d4
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
80008c02:	53 1f 40 20 	mul.u %e2,%d15,1
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80008c06:	df 0f ac 00 	jeq %d15,0,80008d5e <osEE_tc_set_pll_fsource+0x220>
              bestK2         = k2;
              bestN          = n;
              bestP          = p;
            }

            if (fPllLeastError > fPllError)
80008c0a:	0b 13 00 51 	eq %d5,%d3,%d1
80008c0e:	0b 8f 50 52 	and.ge.u %d5,%d15,%d8
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
80008c12:	2b f8 40 85 	sel %d8,%d5,%d8,%d15
80008c16:	ab 01 80 15 	sel %d1,%d5,%d1,0
80008c1a:	2b eb 40 b5 	sel %d11,%d5,%d11,%d14
80008c1e:	2b 6d 40 d5 	sel %d13,%d5,%d13,%d6
80008c22:	2b 0c 40 c5 	sel %d12,%d5,%d12,%d0
        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
80008c26:	c2 16       	add %d6,1
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
80008c28:	8b 16 68 52 	lt.u %d5,%d6,129
80008c2c:	8b 0f 20 54 	and.ne %d5,%d15,0
80008c30:	df 05 e4 ff 	jne %d5,0,80008bf8 <osEE_tc_set_pll_fsource+0xba>
80008c34:	02 d6       	mov %d6,%d13
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80008c36:	02 6d       	mov %d13,%d6
    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
80008c38:	80 4f       	mov.d %d15,%a4
80008c3a:	42 f0       	add %d0,%d15
80008c3c:	80 56       	mov.d %d6,%a5
80008c3e:	42 69       	add %d9,%d6

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
80008c40:	0f 32 a0 50 	or %d5,%d2,%d3
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
80008c44:	8b d0 61 f2 	lt.u %d15,%d0,29
80008c48:	8b 05 20 f4 	and.ne %d15,%d5,0
80008c4c:	ee bd       	jnz %d15,80008bc6 <osEE_tc_set_pll_fsource+0x88>
80008c4e:	01 45 20 50 	sub.a %a5,%a5,%a4
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
80008c52:	c2 fe       	add %d14,-1
    k2Steps = 1;
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
80008c54:	0f 32 a0 f0 	or %d15,%d2,%d3
80008c58:	8b 0f 20 02 	ne %d0,%d15,0
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
80008c5c:	8b 0e 20 52 	ne %d5,%d14,0
80008c60:	8b 0f 20 54 	and.ne %d5,%d15,0
80008c64:	df 05 9a ff 	jne %d5,0,80008b98 <osEE_tc_set_pll_fsource+0x5a>
      }
    }
  }

  /* Percent ALLOWED_DEVIATION error allowed */
  fpll_maxerrorallowed = (fpll * OSEE_TC_DEV_ALLOWED) / ((OsEE_reg)100U);
80008c68:	06 14       	sh %d4,1
80008c6a:	7b c0 1e f5 	movh %d15,20972
80008c6e:	1b ff 51 f8 	addi %d15,%d15,-31457
80008c72:	73 f4 68 40 	mul.u %e4,%d4,%d15
80008c76:	8f b5 1f 20 	sh %d2,%d5,-5
  if (fPllLeastError < (uint64_t)fpll_maxerrorallowed)
80008c7a:	ba 01       	eq %d15,%d1,0
80008c7c:	0b 28 50 f2 	and.ge.u %d15,%d8,%d2
80008c80:	8b 01 00 f5 	or.ne %d15,%d1,0
80008c84:	ee 73       	jnz %d15,80008d6a <osEE_tc_set_pll_fsource+0x22c>
  {
    /* Divide by K2DIV + 1 */
    OSEE_TC_SCU_PLLCON1.bits.k2div = (uint8_t)(bestK2 - 1U);
80008c86:	c2 fc       	add %d12,-1
80008c88:	91 30 00 ff 	movh.a %a15,61443
80008c8c:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80008c90:	4c f0       	ld.w %d15,[%a15]0
80008c92:	37 cf 07 c0 	insert %d12,%d15,%d12,0,7
80008c96:	68 0c       	st.w [%a15]0,%d12

    while (OSEE_TC_SCU_PLLSTAT.bits.k2rdy == 0U) {
80008c98:	91 30 00 ff 	movh.a %a15,61443
80008c9c:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80008ca0:	4c f0       	ld.w %d15,[%a15]0
80008ca2:	6f 5f ff 7f 	jz.t %d15,5,80008ca0 <osEE_tc_set_pll_fsource+0x162>
    }

    /* K1 divider default value */

    /* Enabled the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 1U;
80008ca6:	91 30 00 ff 	movh.a %a15,61443
80008caa:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80008cae:	4c f0       	ld.w %d15,[%a15]0
80008cb0:	96 01       	or %d15,1
80008cb2:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 0U) {
80008cb4:	91 30 00 ff 	movh.a %a15,61443
80008cb8:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80008cbc:	4c f0       	ld.w %d15,[%a15]0
80008cbe:	6f 0f ff 7f 	jz.t %d15,0,80008cbc <osEE_tc_set_pll_fsource+0x17e>
      ; /* Wait until prescaler mode is entered */
    }

    /* I will use n=80 and p=2. Because I can get al the
       needed values */
    OSEE_TC_SCU_PLLCON0.bits.pdiv = (uint8_t)(bestP - 1U);
80008cc2:	9a fb       	add %d15,%d11,-1
80008cc4:	91 30 00 ff 	movh.a %a15,61443
80008cc8:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80008ccc:	16 0f       	and %d15,15
80008cce:	8f 8f 01 f0 	sh %d15,%d15,24
80008cd2:	48 02       	ld.w %d2,[%a15]0
80008cd4:	b7 02 04 2c 	insert %d2,%d2,0,24,4
80008cd8:	a6 2f       	or %d15,%d2
80008cda:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_PLLCON0.bits.ndiv = (uint8_t)(bestN - 1U);
80008cdc:	9a fd       	add %d15,%d13,-1
80008cde:	16 7f       	and %d15,127
80008ce0:	8f 9f 00 f0 	sh %d15,%d15,9
80008ce4:	48 02       	ld.w %d2,[%a15]0
80008ce6:	b7 02 87 24 	insert %d2,%d2,0,9,7
80008cea:	a6 2f       	or %d15,%d2
80008cec:	68 0f       	st.w [%a15]0,%d15

    /* Power down VCO Normal Behavior */
    OSEE_TC_SCU_PLLCON0.bits.vcopwd = 0U;
80008cee:	4c f0       	ld.w %d15,[%a15]0
80008cf0:	8f 2f c0 f1 	andn %d15,%d15,2
80008cf4:	68 0f       	st.w [%a15]0,%d15

    /***** Configure PLL normal mode. *****/

    /* Automatic oscillator disconnect disabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 1U;
80008cf6:	4c f0       	ld.w %d15,[%a15]0
80008cf8:	96 40       	or %d15,64
80008cfa:	68 0f       	st.w [%a15]0,%d15
    /* Connect VCO to the oscillator */
    OSEE_TC_SCU_PLLCON0.bits.clrfindis = 1U;
80008cfc:	4c f0       	ld.w %d15,[%a15]0
80008cfe:	96 20       	or %d15,32
80008d00:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.findis == 1U) {
80008d02:	91 30 00 ff 	movh.a %a15,61443
80008d06:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80008d0a:	4c f0       	ld.w %d15,[%a15]0
80008d0c:	6f 3f ff ff 	jnz.t %d15,3,80008d0a <osEE_tc_set_pll_fsource+0x1cc>
      ; /* Wait until oscillator is connected to the VCO */
    }

    /* Restart VCO lock detection */
    OSEE_TC_SCU_PLLCON0.bits.resld = 1U;
80008d10:	91 30 00 ff 	movh.a %a15,61443
80008d14:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80008d18:	4c f0       	ld.w %d15,[%a15]0
80008d1a:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80008d1e:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcolock == 0U) {
80008d20:	91 30 00 ff 	movh.a %a15,61443
80008d24:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80008d28:	4c f0       	ld.w %d15,[%a15]0
80008d2a:	6f 2f ff 7f 	jz.t %d15,2,80008d28 <osEE_tc_set_pll_fsource+0x1ea>
      ; /* Wait until the VCO becomes locked */
    }

    /* Disable the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 0U;
80008d2e:	91 30 00 ff 	movh.a %a15,61443
80008d32:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80008d36:	4c f0       	ld.w %d15,[%a15]0
80008d38:	8f 1f c0 f1 	andn %d15,%d15,1
80008d3c:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 1U) {
80008d3e:	91 30 00 ff 	movh.a %a15,61443
80008d42:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80008d46:	4c f0       	ld.w %d15,[%a15]0
80008d48:	6f 0f ff ff 	jnz.t %d15,0,80008d46 <osEE_tc_set_pll_fsource+0x208>
      ; /* Wait until normal mode is entered */
    }

    /* Automatic oscillator disconnect enabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
80008d4c:	91 30 00 ff 	movh.a %a15,61443
80008d50:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80008d54:	4c f0       	ld.w %d15,[%a15]0
80008d56:	8f 0f c4 f1 	andn %d15,%d15,64
80008d5a:	68 0f       	st.w [%a15]0,%d15
80008d5c:	00 90       	ret 
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
            {
              fPllLeastError = fPllError;
80008d5e:	02 28       	mov %d8,%d2
80008d60:	02 31       	mov %d1,%d3
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
80008d62:	80 7b       	mov.d %d11,%a7
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80008d64:	02 0c       	mov %d12,%d0
80008d66:	1d ff 68 ff 	j 80008c36 <osEE_tc_set_pll_fsource+0xf8>
80008d6a:	00 90       	ret 

80008d6c <osEE_tc_get_fsource>:
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
  }

}

OsEE_reg osEE_tc_get_fsource(void) {
80008d6c:	40 ae       	mov.aa %a14,%sp
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
80008d6e:	91 30 00 ff 	movh.a %a15,61443
80008d72:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008d76:	4c f0       	ld.w %d15,[%a15]0
80008d78:	37 0f 62 fe 	extr.u %d15,%d15,28,2
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
      }
    }
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
80008d7c:	7b 60 5f 20 	movh %d2,1526
80008d80:	1b 02 10 2e 	addi %d2,%d2,-7936

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
80008d84:	6e 45       	jz %d15,80008e0e <osEE_tc_get_fsource+0xa2>
    /* PLL */
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
80008d86:	91 30 00 ff 	movh.a %a15,61443
80008d8a:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80008d8e:	4c f0       	ld.w %d15,[%a15]0
80008d90:	6f 0f 11 00 	jz.t %d15,0,80008db2 <osEE_tc_get_fsource+0x46>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
80008d94:	91 30 00 ff 	movh.a %a15,61443
80008d98:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80008d9c:	48 02       	ld.w %d2,[%a15]0
80008d9e:	37 02 67 28 	extr.u %d2,%d2,16,7
80008da2:	c2 12       	add %d2,1
      fsource = OSEE_TC_BOARD_FOSC / k1;
80008da4:	7b 10 13 f0 	movh %d15,305
80008da8:	1b 0f d0 f2 	addi %d15,%d15,11520
80008dac:	4b 2f 11 22 	div.u %e2,%d15,%d2
80008db0:	00 90       	ret 
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
80008db2:	4c f0       	ld.w %d15,[%a15]0
80008db4:	6f 3f 11 00 	jz.t %d15,3,80008dd6 <osEE_tc_get_fsource+0x6a>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80008db8:	91 30 00 ff 	movh.a %a15,61443
80008dbc:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80008dc0:	48 02       	ld.w %d2,[%a15]0
80008dc2:	8f f2 07 21 	and %d2,%d2,127
80008dc6:	9a 12       	add %d15,%d2,1
        fsource = OSEE_TC_BOARD_FOSC / k2;
80008dc8:	7b 10 13 20 	movh %d2,305
80008dcc:	1b 02 d0 22 	addi %d2,%d2,11520
80008dd0:	4b f2 11 22 	div.u %e2,%d2,%d15
80008dd4:	00 90       	ret 
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80008dd6:	91 30 00 ff 	movh.a %a15,61443
80008dda:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80008dde:	4c f0       	ld.w %d15,[%a15]0
80008de0:	8f ff 07 51 	and %d5,%d15,127
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
80008de4:	91 30 00 ff 	movh.a %a15,61443
80008de8:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80008dec:	4c f0       	ld.w %d15,[%a15]0
80008dee:	37 0f 64 3c 	extr.u %d3,%d15,24,4
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
80008df2:	48 02       	ld.w %d2,[%a15]0
80008df4:	37 02 e7 44 	extr.u %d4,%d2,9,7
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80008df8:	9a 15       	add %d15,%d5,1
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
80008dfa:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
80008dfe:	7b 10 13 20 	movh %d2,305
80008e02:	1b 02 d0 22 	addi %d2,%d2,11520
80008e06:	4b f2 11 22 	div.u %e2,%d2,%d15
80008e0a:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
  }
  return fsource;
}
80008e0e:	00 90       	ret 

80008e10 <osEE_tc_stm_set_clockpersec>:
  return ticks;
}

/* Set inside std time reference  */
void osEE_tc_stm_set_clockpersec(void)
{
80008e10:	40 ae       	mov.aa %a14,%sp
#if (defined(__TASKING__))
  /* I don't know where is declared */
  extern unsigned long long setfoschz ( unsigned long long );
#endif /* __TASKING__ */
  /* fSOURCE Frequency */
  OsEE_reg const fsource  = osEE_tc_get_fsource();
80008e12:	6d ff ad ff 	call 80008d6c <osEE_tc_get_fsource>
  /* Standard Timer Module period rounded */
  OsEE_reg const fstm     = (fsource + 1U) / OSEE_SCU_HW_FSTM_DIV;
80008e16:	91 30 00 ff 	movh.a %a15,61443
80008e1a:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008e1e:	4c f0       	ld.w %d15,[%a15]0
80008e20:	37 0f 64 f4 	extr.u %d15,%d15,8,4
80008e24:	c2 12       	add %d2,1
80008e26:	4b f2 11 22 	div.u %e2,%d2,%d15

  /* Set Global variable with freq in Khz value */
  osEE_tc_stm_freq_khz = fstm / OSEE_KILO;
80008e2a:	7b 20 06 f1 	movh %d15,4194
80008e2e:	1b 3f dd f4 	addi %d15,%d15,19923
80008e32:	73 f2 68 20 	mul.u %e2,%d2,%d15
80008e36:	8f a3 1f f0 	sh %d15,%d3,-6
80008e3a:	91 00 00 f7 	movh.a %a15,28672
80008e3e:	59 ff c0 00 	st.w [%a15]3072 <70000c00 <osEE_tc_stm_freq_khz>>,%d15
80008e42:	00 90       	ret 

80008e44 <osEE_tc_stm_set_sr0>:
    that qualifier on pointers.
 */

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0(OsEE_reg usec,
    OsEE_tc_isr_hw_prio intvec)
{
80008e44:	40 ae       	mov.aa %a14,%sp
80008e46:	02 59       	mov %d9,%d5
80008e48:	4d c0 e1 8f 	mfcr %d8,$core_id
    5U;
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
80008e4c:	6d ff 4f fe 	call 80008aea <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
80008e50:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
80008e54:	8f 38 00 f1 	and %d15,%d8,3
80008e58:	9b 0f 0f 40 	addih %d4,%d15,240
80008e5c:	8f 84 00 40 	sh %d4,%d4,8
80008e60:	60 4f       	mov.a %a15,%d4
 *  \return The timer lower word value read.
 */
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_tc_stm_get_time_lower_word(OsEE_reg stm_id)
{
  return OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_TIM0_OFF);
80008e62:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
80008e64:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
80008e66:	68 c2       	st.w [%a15]48,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
80008e68:	df 09 23 00 	jeq %d9,0,80008eae <osEE_tc_stm_set_sr0+0x6a>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
80008e6c:	48 e2       	ld.w %d2,[%a15]56
80008e6e:	b7 02 05 24 	insert %d2,%d2,0,8,5
80008e72:	68 e2       	st.w [%a15]56,%d2
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
80008e74:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize0   = size_of_compare;
80008e78:	48 e2       	ld.w %d2,[%a15]56
80008e7a:	37 32 05 30 	insert %d3,%d2,%d3,0,5
80008e7e:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 0 with Compare Register 0 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0os     = 0U;
80008e80:	48 f2       	ld.w %d2,[%a15]60
80008e82:	8f 42 c0 21 	andn %d2,%d2,4
80008e86:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en     = 1U;
80008e88:	48 f2       	ld.w %d2,[%a15]60
80008e8a:	8f 12 40 21 	or %d2,%d2,1
80008e8e:	68 f2       	st.w [%a15]60,%d2

/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 0U), intvec);
80008e90:	06 3f       	sh %d15,3
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80008e92:	60 f2       	mov.a %a2,%d15
80008e94:	d9 2f 50 28 	lea %a15,[%a2]-31600
80008e98:	11 4f 00 ff 	addih.a %a15,%a15,61444
80008e9c:	b7 89 99 93 	insert %d9,%d9,8,7,25
80008ea0:	8f 38 00 81 	and %d8,%d8,3
80008ea4:	8f b8 00 80 	sh %d8,%d8,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
80008ea8:	a6 89       	or %d9,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80008eaa:	68 09       	st.w [%a15]0,%d9
80008eac:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en                 = 0U;
80008eae:	48 f2       	ld.w %d2,[%a15]60
80008eb0:	8f 12 c0 21 	andn %d2,%d2,1
80008eb4:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 0U)) = 0U;
80008eb6:	1b 2f 09 f7 	addi %d15,%d15,28818
80008eba:	9b 0f e0 f1 	addih %d15,%d15,7680
80008ebe:	06 3f       	sh %d15,3
80008ec0:	82 02       	mov %d2,0
80008ec2:	60 ff       	mov.a %a15,%d15
80008ec4:	68 02       	st.w [%a15]0,%d2
80008ec6:	00 90       	ret 

80008ec8 <osEE_tc_stm_set_sr0_next_match>:
  }
}

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0_next_match(OsEE_reg usec)
{
80008ec8:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80008eca:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP0IRR bit 0 => 0x1 | CMP0IRS bit 1 => 0x2 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x1U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) += osEE_tc_stm_us_ticks(usec);
80008ece:	6d ff 0e fe 	call 80008aea <osEE_tc_stm_us_ticks>
80008ed2:	16 03       	and %d15,3
80008ed4:	9b 0f 0f f0 	addih %d15,%d15,240
80008ed8:	8f 8f 00 f0 	sh %d15,%d15,8
80008edc:	60 ff       	mov.a %a15,%d15
80008ede:	4c fc       	ld.w %d15,[%a15]48
80008ee0:	42 f2       	add %d2,%d15
80008ee2:	68 c2       	st.w [%a15]48,%d2
80008ee4:	00 90       	ret 

80008ee6 <osEE_tc_stm_set_sr1>:
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1(OsEE_reg usec,
  OsEE_tc_isr_hw_prio intvec)
{
80008ee6:	40 ae       	mov.aa %a14,%sp
80008ee8:	02 59       	mov %d9,%d5
80008eea:	4d c0 e1 8f 	mfcr %d8,$core_id
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
80008eee:	6d ff fe fd 	call 80008aea <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
80008ef2:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
80008ef6:	8f 38 00 f1 	and %d15,%d8,3
80008efa:	9b 0f 0f 40 	addih %d4,%d15,240
80008efe:	8f 84 00 40 	sh %d4,%d4,8
80008f02:	60 4f       	mov.a %a15,%d4
80008f04:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
80008f06:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
80008f08:	68 d2       	st.w [%a15]52,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
80008f0a:	df 09 28 00 	jeq %d9,0,80008f5a <osEE_tc_stm_set_sr1+0x74>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
80008f0e:	48 e2       	ld.w %d2,[%a15]56
80008f10:	b7 02 05 2c 	insert %d2,%d2,0,24,5
80008f14:	68 e2       	st.w [%a15]56,%d2
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
80008f16:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize1   = size_of_compare;
80008f1a:	8f f3 01 31 	and %d3,%d3,31
80008f1e:	8f 03 01 30 	sh %d3,%d3,16
80008f22:	48 e2       	ld.w %d2,[%a15]56
80008f24:	b7 02 05 28 	insert %d2,%d2,0,16,5
80008f28:	a6 23       	or %d3,%d2
80008f2a:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 1 with Compare Register 1 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1os     = 1U;
80008f2c:	48 f2       	ld.w %d2,[%a15]60
80008f2e:	8f 02 44 21 	or %d2,%d2,64
80008f32:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en     = 1U;
80008f34:	48 f2       	ld.w %d2,[%a15]60
80008f36:	8f 02 41 21 	or %d2,%d2,16
80008f3a:	68 f2       	st.w [%a15]60,%d2
/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
80008f3c:	06 3f       	sh %d15,3
80008f3e:	60 f2       	mov.a %a2,%d15
80008f40:	d9 2f 54 28 	lea %a15,[%a2]-31596
80008f44:	11 4f 00 ff 	addih.a %a15,%a15,61444
80008f48:	b7 89 99 93 	insert %d9,%d9,8,7,25
80008f4c:	8f 38 00 81 	and %d8,%d8,3
80008f50:	8f b8 00 80 	sh %d8,%d8,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
80008f54:	a6 89       	or %d9,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80008f56:	68 09       	st.w [%a15]0,%d9
80008f58:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en                 = 0U;
80008f5a:	48 f2       	ld.w %d2,[%a15]60
80008f5c:	8f 02 c1 21 	andn %d2,%d2,16
80008f60:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 1U)) = 0U;
80008f62:	06 3f       	sh %d15,3
80008f64:	60 f2       	mov.a %a2,%d15
80008f66:	d9 2f 54 28 	lea %a15,[%a2]-31596
80008f6a:	11 4f 00 ff 	addih.a %a15,%a15,61444
80008f6e:	82 0f       	mov %d15,0
80008f70:	68 0f       	st.w [%a15]0,%d15
80008f72:	00 90       	ret 

80008f74 <osEE_tc_stm_set_sr1_next_match>:
  }
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1_next_match(OsEE_reg usec)
{
80008f74:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80008f76:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP1IRR bit 2 => 0x4 | CMP1IRS bit 3 => 0x8 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x4U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) += osEE_tc_stm_us_ticks(usec);
80008f7a:	6d ff b8 fd 	call 80008aea <osEE_tc_stm_us_ticks>
80008f7e:	16 03       	and %d15,3
80008f80:	9b 0f 0f f0 	addih %d15,%d15,240
80008f84:	8f 8f 00 f0 	sh %d15,%d15,8
80008f88:	60 ff       	mov.a %a15,%d15
80008f8a:	4c fd       	ld.w %d15,[%a15]52
80008f8c:	42 f2       	add %d2,%d15
80008f8e:	68 d2       	st.w [%a15]52,%d2
80008f90:	00 90       	ret 

80008f92 <osEE_tc_delay>:
}

void osEE_tc_delay(OsEE_reg usec)
{
80008f92:	40 ae       	mov.aa %a14,%sp
80008f94:	4d c0 e1 ff 	mfcr %d15,$core_id
80008f98:	16 03       	and %d15,3
80008f9a:	9b 0f 0f f0 	addih %d15,%d15,240
80008f9e:	8f 8f 00 f0 	sh %d15,%d15,8
80008fa2:	60 f2       	mov.a %a2,%d15
80008fa4:	d9 2f 10 00 	lea %a15,[%a2]16
80008fa8:	19 28 10 00 	ld.w %d8,[%a2]16
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
  /* Read Start Point */
  OsEE_reg    const start = osEE_tc_stm_get_time_lower_word(stm_id);
  /* Evaluate End Point */
  OsEE_reg    const ticks = osEE_tc_stm_us_ticks(usec);
80008fac:	6d ff 9f fd 	call 80008aea <osEE_tc_stm_us_ticks>
80008fb0:	4c f0       	ld.w %d15,[%a15]0

  while (ticks > (osEE_tc_stm_get_time_lower_word(stm_id) - start)) {
80008fb2:	a2 8f       	sub %d15,%d8
80008fb4:	3f 2f fe ff 	jlt.u %d15,%d2,80008fb0 <osEE_tc_delay+0x1e>
    ; /* Wait */
  }
}
80008fb8:	00 90       	ret 

80008fba <osEE_tc_isr2_wrapper>:

#if (defined(__GNUC__))
#pragma section
#endif /* __GNUC__ */

static void OSEE_COMPILER_KEEP osEE_tc_isr2_wrapper(TaskType isr2_tid) {
80008fba:	40 ae       	mov.aa %a14,%sp
    }
    /* TODO: handle other internal priorities? System Timer? */
  } else
#endif /* !OSEE_SINGLECORE */
  {
    osEE_activate_isr2(isr2_tid);
80008fbc:	6d 00 86 05 	call 80009ac8 <osEE_activate_isr2>
  __asm__ volatile ("svlcx" : : : "memory");
}

/** The rslcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rslcx(void) {
  __asm__ volatile ("rslcx" : : : "memory");
80008fc0:	0d 00 40 02 	rslcx 
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
80008fc4:	00 80       	rfe 
80008fc6:	00 90       	ret 

80008fc8 <osEE_shutdown_os>:
  osEE_shutdown_os
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
80008fc8:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80008fca:	cc 40       	ld.a %a15,[%a4]0
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
80008fcc:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
80008fd0:	82 32       	mov %d2,3
80008fd2:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
80008fd6:	e9 f4 12 00 	st.b [%a15]18,%d4

  if (os_status == OSEE_KERNEL_STARTED) {
80008fda:	5e 25       	jne %d15,2,80008fe4 <osEE_shutdown_os+0x1c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
80008fdc:	99 44 04 00 	ld.a %a4,[%a4]4
80008fe0:	6d 00 89 06 	call 80009cf2 <osEE_idle_task_terminate>
  } else {
    osEE_call_shutdown_hook(p_ccb, Error);
  }
  for (;;) {
    ; /* Endless Loop (entered only if Kernel Not Started) */
  }
80008fe4:	3c 00       	j 80008fe4 <osEE_shutdown_os+0x1c>

80008fe6 <DisableAllInterrupts>:
FUNC(void, OS_CODE)
  DisableAllInterrupts
(
  void
)
{
80008fe6:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80008fe8:	91 00 00 f8 	movh.a %a15,32768
80008fec:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
80008ff0:	0d 00 40 03 	disable 
  osEE_hal_disableIRQ();

  osEE_stack_monitoring(p_cdb);

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_DisableAllInterrupts);
  p_ccb->d_isr_all_cnt = 1U;
80008ff4:	82 1f       	mov %d15,1
80008ff6:	e9 ff 1e 00 	st.b [%a15]30,%d15
80008ffa:	00 90       	ret 

80008ffc <EnableAllInterrupts>:
FUNC(void, OS_CODE)
  EnableAllInterrupts
(
  void
)
{
80008ffc:	40 ae       	mov.aa %a14,%sp
   * ResumeOSInterrupts() are called and no corresponding DisableAllInterupts()
   * /SuspendAllInterrupts()/SuspendOSInterrupts() was done before, the
   * Operating System module shall not perform this Operating System service.
   * (SRS_Os_11009) */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80008ffe:	91 00 00 f8 	movh.a %a15,32768
80009002:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_EnableAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->d_isr_all_cnt > 0U) {
80009006:	39 ff 1e 00 	ld.bu %d15,[%a15]30 <800000dc <osEE_cdb_var>>
8000900a:	6e 06       	jz %d15,80009016 <EnableAllInterrupts+0x1a>
    p_ccb->d_isr_all_cnt = 0U;
8000900c:	82 0f       	mov %d15,0
8000900e:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009012:	0d 00 00 03 	enable 
80009016:	00 90       	ret 

80009018 <SuspendAllInterrupts>:
FUNC(void, OS_CODE)
  SuspendAllInterrupts
(
  void
)
{
80009018:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000901a:	91 00 00 f8 	movh.a %a15,32768
8000901e:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
(
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb,
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
  if (p_ccb->s_isr_all_cnt == 0U) {
80009022:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000dc <osEE_cdb_var>>
80009026:	ee 0c       	jnz %d15,8000903e <SuspendAllInterrupts+0x26>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009028:	4d c0 e2 ff 	mfcr %d15,$icr
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000902c:	0d 00 40 03 	disable 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
80009030:	68 5f       	st.w [%a15]20,%d15
    ++p_ccb->s_isr_all_cnt;
80009032:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80009036:	c2 1f       	add %d15,1
80009038:	e9 ff 1c 00 	st.b [%a15]28,%d15
8000903c:	00 90       	ret 
  } else if (p_ccb->s_isr_all_cnt < OSEE_MAX_BYTE) {
8000903e:	8b ff 0f 22 	eq %d2,%d15,255
80009042:	f6 25       	jnz %d2,8000904c <SuspendAllInterrupts+0x34>
    ++p_ccb->s_isr_all_cnt;
80009044:	c2 1f       	add %d15,1
80009046:	e9 ff 1c 00 	st.b [%a15]28,%d15
8000904a:	00 90       	ret 
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
8000904c:	91 00 00 48 	movh.a %a4,32768
80009050:	d9 44 1c 30 	lea %a4,[%a4]220 <800000dc <osEE_cdb_var>>
80009054:	3b 90 01 40 	mov %d4,25
80009058:	3c b8       	j 80008fc8 <osEE_shutdown_os>

8000905a <ResumeAllInterrupts>:
FUNC(void, OS_CODE)
  ResumeAllInterrupts
(
  void
)
{
8000905a:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000905c:	91 00 00 f8 	movh.a %a15,32768
80009060:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt > 0U) {
80009064:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000dc <osEE_cdb_var>>
80009068:	6e 0b       	jz %d15,8000907e <ResumeAllInterrupts+0x24>
    --p_ccb->s_isr_all_cnt;
8000906a:	c2 ff       	add %d15,-1
8000906c:	16 ff       	and %d15,255
8000906e:	e9 ff 1c 00 	st.b [%a15]28,%d15

    if (p_ccb->s_isr_all_cnt == 0U) {
80009072:	ee 06       	jnz %d15,8000907e <ResumeAllInterrupts+0x24>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009074:	4c f5       	ld.w %d15,[%a15]20
80009076:	cd cf e2 0f 	mtcr $icr,%d15
8000907a:	0d 00 c0 04 	isync 
8000907e:	00 90       	ret 

80009080 <SuspendOSInterrupts>:
FUNC(void, OS_CODE)
  SuspendOSInterrupts
(
  void
)
{
80009080:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009082:	91 00 00 f8 	movh.a %a15,32768
80009086:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt == 0U) {
8000908a:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000dc <osEE_cdb_var>>
8000908e:	ee 18       	jnz %d15,800090be <SuspendOSInterrupts+0x3e>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009090:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009094:	8f f2 0f f1 	and %d15,%d2,255
80009098:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000909c:	ee 0a       	jnz %d15,800090b0 <SuspendOSInterrupts+0x30>
    OsEE_icr icr_temp = icr;
8000909e:	02 2f       	mov %d15,%d2
800090a0:	3b 30 01 30 	mov %d3,19
800090a4:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800090a8:	cd cf e2 0f 	mtcr $icr,%d15
800090ac:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_begin_nested_primitive();
    p_ccb->prev_s_isr_os_status = flags;
800090b0:	68 62       	st.w [%a15]24,%d2
    ++p_ccb->s_isr_os_cnt;
800090b2:	39 ff 1d 00 	ld.bu %d15,[%a15]29
800090b6:	c2 1f       	add %d15,1
800090b8:	e9 ff 1d 00 	st.b [%a15]29,%d15
800090bc:	00 90       	ret 
  } else if (p_ccb->s_isr_os_cnt < OSEE_MAX_BYTE) {
800090be:	8b ff 0f 22 	eq %d2,%d15,255
800090c2:	f6 25       	jnz %d2,800090cc <SuspendOSInterrupts+0x4c>
    ++p_ccb->s_isr_os_cnt;
800090c4:	c2 1f       	add %d15,1
800090c6:	e9 ff 1d 00 	st.b [%a15]29,%d15
800090ca:	00 90       	ret 
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
800090cc:	91 00 00 48 	movh.a %a4,32768
800090d0:	d9 44 1c 30 	lea %a4,[%a4]220 <800000dc <osEE_cdb_var>>
800090d4:	3b 90 01 40 	mov %d4,25
800090d8:	1d ff 78 ff 	j 80008fc8 <osEE_shutdown_os>

800090dc <ResumeOSInterrupts>:
FUNC(void, OS_CODE)
  ResumeOSInterrupts
(
  void
)
{
800090dc:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800090de:	91 00 00 f8 	movh.a %a15,32768
800090e2:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt > 0U) {
800090e6:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000dc <osEE_cdb_var>>
800090ea:	6e 16       	jz %d15,80009116 <ResumeOSInterrupts+0x3a>
    --p_ccb->s_isr_os_cnt;
800090ec:	c2 ff       	add %d15,-1
800090ee:	16 ff       	and %d15,255
800090f0:	e9 ff 1d 00 	st.b [%a15]29,%d15

    if (p_ccb->s_isr_os_cnt == 0U) {
800090f4:	ee 11       	jnz %d15,80009116 <ResumeOSInterrupts+0x3a>
      osEE_hal_end_nested_primitive(p_ccb->prev_s_isr_os_status);
800090f6:	48 62       	ld.w %d2,[%a15]24
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800090f8:	4d c0 e2 3f 	mfcr %d3,$icr
800090fc:	02 3f       	mov %d15,%d3
800090fe:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009102:	8f f2 0f 21 	and %d2,%d2,255
80009106:	5f 23 08 00 	jeq %d3,%d2,80009116 <ResumeOSInterrupts+0x3a>
8000910a:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000910e:	cd cf e2 0f 	mtcr $icr,%d15
80009112:	0d 00 c0 04 	isync 
80009116:	00 90       	ret 

80009118 <StartOS>:
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
80009118:	40 ae       	mov.aa %a14,%sp
8000911a:	02 49       	mov %d9,%d4
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000911c:	91 00 00 f8 	movh.a %a15,32768
80009120:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009124:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009128:	8f f8 0f f1 	and %d15,%d8,255
8000912c:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009130:	ee 0a       	jnz %d15,80009144 <StartOS+0x2c>
    OsEE_icr icr_temp = icr;
80009132:	02 8f       	mov %d15,%d8
80009134:	3b 30 01 20 	mov %d2,19
80009138:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000913c:	cd cf e2 0f 	mtcr $icr,%d15
80009140:	0d 00 c0 04 	isync 
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
80009144:	39 ff 10 00 	ld.bu %d15,[%a15]16
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
80009148:	82 15       	mov %d5,1
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
8000914a:	ee 21       	jnz %d15,8000918c <StartOS+0x74>
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
8000914c:	6d 00 e6 05 	call 80009d18 <osEE_cpu_startos>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
      osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
      ev = E_OS_SYS_INIT;
80009150:	3b 80 01 50 	mov %d5,24
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
80009154:	df 02 1c 00 	jeq %d2,0,8000918c <StartOS+0x74>
80009158:	3c 24       	j 800091a0 <StartOS+0x88>
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
      p_ccb->os_status = OSEE_KERNEL_STARTED;
8000915a:	82 2f       	mov %d15,2
8000915c:	e9 ff 10 00 	st.b [%a15]16,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */

    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);

#if (!defined(OSEE_STARTOS_RETURN)) && (!defined(OSEE_API_DYNAMIC))
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
80009160:	39 ff 10 00 	ld.bu %d15,[%a15]16
80009164:	5e 2a       	jne %d15,2,80009178 <StartOS+0x60>
  osEE_idle_task_start
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
80009166:	40 c4       	mov.aa %a4,%a12
80009168:	99 c5 04 00 	ld.a %a5,[%a12]4
8000916c:	40 56       	mov.aa %a6,%a5
8000916e:	6d 00 3a 06 	call 80009de2 <osEE_hal_save_ctx_and_ready2stacked>
      osEE_idle_task_start(p_idle_tdb);
      osEE_task_end(p_idle_tdb);
80009172:	40 c4       	mov.aa %a4,%a12
80009174:	6d 00 8a 04 	call 80009a88 <osEE_task_end>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
80009178:	0d 00 40 03 	disable 
    }
#if (!defined(OSEE_SHUTDOWN_DO_NOT_RETURN_ON_MAIN))
    osEE_hal_disableIRQ();
    osEE_shutdown_os_extra();
    osEE_call_shutdown_hook(p_ccb, p_ccb->last_error);
    for(;;) {} /* Endless Loop */
8000917c:	3c 00       	j 8000917c <StartOS+0x64>
8000917e:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009182:	cd cf e2 0f 	mtcr $icr,%d15
80009186:	0d 00 c0 04 	isync 
8000918a:	3c 1b       	j 800091c0 <StartOS+0xa8>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000918c:	4d c0 e2 4f 	mfcr %d4,$icr
80009190:	02 4f       	mov %d15,%d4
80009192:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009196:	8f f8 0f 31 	and %d3,%d8,255
8000919a:	5f 34 f2 ff 	jne %d4,%d3,8000917e <StartOS+0x66>
8000919e:	3c 11       	j 800091c0 <StartOS+0xa8>
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
800091a0:	91 00 00 28 	movh.a %a2,32768
800091a4:	d9 22 1c 30 	lea %a2,[%a2]220 <800000dc <osEE_cdb_var>>
800091a8:	99 2c 04 00 	ld.a %a12,[%a2]4 <80000004 <BootModeHeader0+0x4>>
    /* Fill CCB */
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
800091ac:	82 1f       	mov %d15,1
800091ae:	e9 ff 10 00 	st.b [%a15]16,%d15
    p_ccb->app_mode                 = real_mode;
800091b2:	e9 f9 11 00 	st.b [%a15]17,%d9
    }
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
800091b6:	39 ff 10 00 	ld.bu %d15,[%a15]16
800091ba:	df 1f d3 ff 	jne %d15,1,80009160 <StartOS+0x48>
800091be:	3c ce       	j 8000915a <StartOS+0x42>
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}
800091c0:	02 52       	mov %d2,%d5
800091c2:	00 90       	ret 

800091c4 <GetActiveApplicationMode>:
FUNC(AppModeType, OS_CODE)
  GetActiveApplicationMode
(
  void
)
{
800091c4:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
800091c6:	91 00 00 f8 	movh.a %a15,32768
800091ca:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
800091ce:	39 ff 10 00 	ld.bu %d15,[%a15]16 <800000dc <osEE_cdb_var>>
    app_mode = p_ccb->app_mode;
  } else {
    app_mode = INVALID_APPMODE;
800091d2:	3b f0 0f 20 	mov %d2,255

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
800091d6:	6e 03       	jz %d15,800091dc <GetActiveApplicationMode+0x18>
    app_mode = p_ccb->app_mode;
800091d8:	39 f2 11 00 	ld.bu %d2,[%a15]17
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}
800091dc:	00 90       	ret 

800091de <ActivateTask>:
FUNC(StatusType, OS_CODE)
  ActivateTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
800091de:	40 ae       	mov.aa %a14,%sp
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
800091e0:	91 00 00 f8 	movh.a %a15,32768
800091e4:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
800091e8:	4c f2       	ld.w %d15,[%a15]8
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
800091ea:	82 38       	mov %d8,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
800091ec:	7f f4 39 80 	jge.u %d4,%d15,8000925e <ActivateTask+0x80>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
800091f0:	91 00 00 f8 	movh.a %a15,32768
800091f4:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
800091f8:	c8 1f       	ld.a %a15,[%a15]4
800091fa:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
800091fe:	c8 0f       	ld.a %a15,[%a15]0

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009200:	39 ff 14 00 	ld.bu %d15,[%a15]20
80009204:	ff 2f 2d 80 	jge.u %d15,2,8000925e <ActivateTask+0x80>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009208:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000920c:	8f f9 0f f1 	and %d15,%d9,255
80009210:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009214:	ee 0a       	jnz %d15,80009228 <ActivateTask+0x4a>
    OsEE_icr icr_temp = icr;
80009216:	02 9f       	mov %d15,%d9
80009218:	3b 30 01 20 	mov %d2,19
8000921c:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009220:	cd cf e2 0f 	mtcr $icr,%d15
80009224:	0d 00 c0 04 	isync 
      CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

      ev = osEE_task_activated(p_tdb_act);
80009228:	40 f4       	mov.aa %a4,%a15
8000922a:	6d 00 23 04 	call 80009a70 <osEE_task_activated>
8000922e:	02 28       	mov %d8,%d2

      if (ev == E_OK) {
80009230:	f6 28       	jnz %d2,80009240 <ActivateTask+0x62>
        (void)osEE_scheduler_task_activated(p_kdb, p_tdb_act);
80009232:	91 00 00 48 	movh.a %a4,32768
80009236:	d9 44 08 30 	lea %a4,[%a4]200 <800000c8 <osEE_kdb_var>>
8000923a:	40 f5       	mov.aa %a5,%a15
8000923c:	6d 00 57 04 	call 80009aea <osEE_scheduler_task_activated>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009240:	4d c0 e2 3f 	mfcr %d3,$icr
80009244:	02 3f       	mov %d15,%d3
80009246:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000924a:	8f f9 0f 21 	and %d2,%d9,255
8000924e:	5f 23 08 00 	jeq %d3,%d2,8000925e <ActivateTask+0x80>
80009252:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009256:	cd cf e2 0f 	mtcr $icr,%d15
8000925a:	0d 00 c0 04 	isync 
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ActivateTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000925e:	02 82       	mov %d2,%d8
80009260:	00 90       	ret 

80009262 <ChainTask>:
FUNC(StatusType, OS_CODE)
  ChainTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
80009262:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb = p_cdb->p_ccb;
80009264:	91 00 00 f8 	movh.a %a15,32768
80009268:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
8000926c:	48 03       	ld.w %d3,[%a15]0
8000926e:	91 00 00 28 	movh.a %a2,32768
80009272:	d9 22 08 30 	lea %a2,[%a2]200 <800000c8 <osEE_kdb_var>>
80009276:	4c 22       	ld.w %d15,[%a2]8
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009278:	82 32       	mov %d2,3
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000927a:	7f f4 5e 80 	jge.u %d4,%d15,80009336 <ChainTask+0xd4>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000927e:	91 00 00 28 	movh.a %a2,32768
80009282:	d9 22 08 30 	lea %a2,[%a2]200 <800000c8 <osEE_kdb_var>>
80009286:	99 22 04 00 	ld.a %a2,[%a2]4 <80000004 <BootModeHeader0+0x4>>
8000928a:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000928e:	d4 2c       	ld.a %a12,[%a2]
      ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
    } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009290:	39 cf 14 00 	ld.bu %d15,[%a12]20
80009294:	ff 2f 51 80 	jge.u %d15,2,80009336 <ChainTask+0xd4>
      VAR(OsEE_reg, AUTOMATIC)  flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
80009298:	39 ff 1c 00 	ld.bu %d15,[%a15]28
8000929c:	6e 09       	jz %d15,800092ae <ChainTask+0x4c>
        p_ccb->s_isr_all_cnt = 0U;
8000929e:	82 0f       	mov %d15,0
800092a0:	e9 ff 1c 00 	st.b [%a15]28,%d15
800092a4:	4c f5       	ld.w %d15,[%a15]20
800092a6:	cd cf e2 0f 	mtcr $icr,%d15
800092aa:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
800092ae:	39 ff 1e 00 	ld.bu %d15,[%a15]30
800092b2:	6e 06       	jz %d15,800092be <ChainTask+0x5c>
        p_ccb->d_isr_all_cnt = 0U;
800092b4:	82 0f       	mov %d15,0
800092b6:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
800092ba:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800092be:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800092c2:	8f f8 0f f1 	and %d15,%d8,255
800092c6:	8b 3f a1 f2 	ge.u %d15,%d15,19
800092ca:	ee 0a       	jnz %d15,800092de <ChainTask+0x7c>
    OsEE_icr icr_temp = icr;
800092cc:	02 8f       	mov %d15,%d8
800092ce:	3b 30 01 20 	mov %d2,19
800092d2:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800092d6:	cd cf e2 0f 	mtcr $icr,%d15
800092da:	0d 00 c0 04 	isync 
      }
#endif /* !OSEE_HAS_SERVICE_PROTECTION */

      flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {
800092de:	80 cf       	mov.d %d15,%a12
800092e0:	7e 35       	jne %d15,%d3,800092ea <ChainTask+0x88>
        /* If the Task chain on it self, flag it. */
        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
800092e2:	cc c3       	ld.a %a15,[%a12]12
800092e4:	82 5f       	mov %d15,5
800092e6:	28 2f       	st.b [%a15]2,%d15
800092e8:	3c 15       	j 80009312 <ChainTask+0xb0>
        ev = E_OK;
      } else {
        ev = osEE_task_activated(p_tdb_act);
800092ea:	40 c4       	mov.aa %a4,%a12
800092ec:	6d 00 c2 03 	call 80009a70 <osEE_task_activated>
        if (ev == E_OK) {
800092f0:	df 02 1a 80 	jne %d2,0,80009324 <ChainTask+0xc2>
          (void)osEE_scheduler_task_insert(p_kdb, p_tdb_act);
800092f4:	91 00 00 48 	movh.a %a4,32768
800092f8:	d9 44 08 30 	lea %a4,[%a4]200 <800000c8 <osEE_kdb_var>>
800092fc:	40 c5       	mov.aa %a5,%a12
800092fe:	6d 00 2a 04 	call 80009b52 <osEE_scheduler_task_insert>
80009302:	3c 08       	j 80009312 <ChainTask+0xb0>
80009304:	37 8f 08 f0 	insert %d15,%d15,%d8,0,8
80009308:	cd cf e2 0f 	mtcr $icr,%d15
8000930c:	0d 00 c0 04 	isync 
80009310:	00 90       	ret 
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
80009312:	91 00 00 f8 	movh.a %a15,32768
80009316:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
(
  P2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA)  p_to_term,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
8000931a:	c8 0f       	ld.a %a15,[%a15]0
8000931c:	c8 14       	ld.a %a4,[%a15]4
8000931e:	a0 05       	mov.a %a5,0
80009320:	1d 00 98 05 	j 80009e50 <osEE_hal_terminate_ctx>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009324:	4d c0 e2 3f 	mfcr %d3,$icr
80009328:	02 3f       	mov %d15,%d3
8000932a:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000932e:	8f f8 0f 81 	and %d8,%d8,255
80009332:	5f 83 e9 ff 	jne %d3,%d8,80009304 <ChainTask+0xa2>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ChainTask);

  return ev;
}
80009336:	00 90       	ret 

80009338 <TerminateTask>:
FUNC(StatusType, OS_CODE)
  TerminateTask
(
  void
)
{
80009338:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb       = p_cdb->p_ccb;
8000933a:	91 00 00 f8 	movh.a %a15,32768
8000933e:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
80009342:	c8 02       	ld.a %a2,[%a15]0
#endif /* OSEE_HAS_CHECKS elif (OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING) */
  {
    VAR(OsEE_reg, AUTOMATIC) flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
80009344:	39 ff 1c 00 	ld.bu %d15,[%a15]28 <800000dc <osEE_cdb_var>>
80009348:	6e 09       	jz %d15,8000935a <TerminateTask+0x22>
        p_ccb->s_isr_all_cnt = 0U;
8000934a:	82 0f       	mov %d15,0
8000934c:	e9 ff 1c 00 	st.b [%a15]28,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009350:	4c f5       	ld.w %d15,[%a15]20
80009352:	cd cf e2 0f 	mtcr $icr,%d15
80009356:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
8000935a:	39 ff 1e 00 	ld.bu %d15,[%a15]30
8000935e:	6e 06       	jz %d15,8000936a <TerminateTask+0x32>
        p_ccb->d_isr_all_cnt = 0U;
80009360:	82 0f       	mov %d15,0
80009362:	e9 ff 1e 00 	st.b [%a15]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009366:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000936a:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000936e:	8f ff 0f 21 	and %d2,%d15,255
80009372:	8b 32 a1 22 	ge.u %d2,%d2,19
80009376:	f6 29       	jnz %d2,80009388 <TerminateTask+0x50>
80009378:	3b 30 01 20 	mov %d2,19
8000937c:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009380:	cd cf e2 0f 	mtcr $icr,%d15
80009384:	0d 00 c0 04 	isync 
80009388:	99 24 04 00 	ld.a %a4,[%a2]4
8000938c:	a0 05       	mov.a %a5,0
8000938e:	1d 00 61 05 	j 80009e50 <osEE_hal_terminate_ctx>

80009392 <Schedule>:
FUNC(StatusType, OS_CODE)
  Schedule
(
  void
)
{
80009392:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb  = p_cdb->p_ccb;
80009394:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_curr = p_ccb->p_curr;
80009398:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
8000939c:	c8 0f       	ld.a %a15,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb  = p_curr->p_tcb;
8000939e:	c8 3c       	ld.a %a12,[%a15]12
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
  if (p_tcb->current_prio == p_curr->dispatch_prio)
800093a0:	39 c2 01 00 	ld.bu %d2,[%a12]1 <800000dc <osEE_cdb_var>>
800093a4:	39 ff 1d 00 	ld.bu %d15,[%a15]29 <800000dc <osEE_cdb_var>>
800093a8:	5f f2 2d 80 	jne %d2,%d15,80009402 <Schedule+0x70>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800093ac:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800093b0:	8f f8 0f f1 	and %d15,%d8,255
800093b4:	8b 3f a1 f2 	ge.u %d15,%d15,19
800093b8:	ee 0a       	jnz %d15,800093cc <Schedule+0x3a>
    OsEE_icr icr_temp = icr;
800093ba:	02 8f       	mov %d15,%d8
800093bc:	3b 30 01 20 	mov %d2,19
800093c0:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800093c4:	cd cf e2 0f 	mtcr $icr,%d15
800093c8:	0d 00 c0 04 	isync 
  {
    /* Begin primitive */
    CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

    /* Release internal resources */
    p_tcb->current_prio = p_curr->ready_prio;
800093cc:	39 ff 1c 00 	ld.bu %d15,[%a15]28
800093d0:	2c c1       	st.b [%a12]1,%d15
    /* Try preemption */
    (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
800093d2:	91 00 00 48 	movh.a %a4,32768
800093d6:	d9 44 08 30 	lea %a4,[%a4]200 <800000c8 <osEE_kdb_var>>
800093da:	6d 00 36 04 	call 80009c46 <osEE_scheduler_task_preemption_point>
    /* Restore internal resources */
    p_tcb->current_prio = p_curr->dispatch_prio;
800093de:	39 ff 1d 00 	ld.bu %d15,[%a15]29
800093e2:	2c c1       	st.b [%a12]1,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800093e4:	4d c0 e2 3f 	mfcr %d3,$icr
800093e8:	02 3f       	mov %d15,%d3
800093ea:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800093ee:	8f f8 0f 21 	and %d2,%d8,255
800093f2:	5f 23 08 00 	jeq %d3,%d2,80009402 <Schedule+0x70>
800093f6:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800093fa:	cd cf e2 0f 	mtcr $icr,%d15
800093fe:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}
80009402:	82 02       	mov %d2,0
80009404:	00 90       	ret 

80009406 <GetResource>:
FUNC(StatusType, OS_CODE)
  GetResource
(
  VAR(ResourceType, AUTOMATIC) ResID
)
{
80009406:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009408:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
8000940c:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
80009410:	c8 04       	ld.a %a4,[%a15]0
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (res_id < p_kdb->p_kcb->free_res_index);
#else
  return (res_id < p_kdb->res_array_size);
80009412:	91 00 00 f8 	movh.a %a15,32768
80009416:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
8000941a:	4c f4       	ld.w %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
8000941c:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
8000941e:	7f f4 4c 80 	jge.u %d4,%d15,800094b6 <GetResource+0xb0>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, OS_APPL_CONST)
      p_reso_db     = (*p_kdb->p_res_ptr_array)[ResID];
80009422:	91 00 00 f8 	movh.a %a15,32768
80009426:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
8000942a:	c8 3f       	ld.a %a15,[%a15]12
8000942c:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
80009430:	c8 03       	ld.a %a3,[%a15]0
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, OS_APPL_DATA)
      p_reso_cb     = p_reso_db->p_cb;
80009432:	d4 32       	ld.a %a2,[%a3]
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_curr_tcb    = p_curr->p_tcb;
80009434:	cc 43       	ld.a %a15,[%a4]12
    CONST(TaskPrio, AUTOMATIC)
      reso_prio     = p_reso_db->prio;
80009436:	0c 34       	ld.bu %d15,[%a3]4
    CONST(TaskPrio, AUTOMATIC)
      current_prio  = p_curr_tcb->current_prio;
80009438:	08 14       	ld.bu %d4,[%a15]1
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000943a:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000943e:	8f f2 0f 31 	and %d3,%d2,255
80009442:	8b 33 a1 32 	ge.u %d3,%d3,19
80009446:	f6 3a       	jnz %d3,8000945a <GetResource+0x54>
    OsEE_icr icr_temp = icr;
80009448:	02 23       	mov %d3,%d2
8000944a:	3b 30 01 50 	mov %d5,19
8000944e:	37 53 08 30 	insert %d3,%d3,%d5,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009452:	cd c3 e2 0f 	mtcr $icr,%d3
80009456:	0d 00 c0 04 	isync 
    /* Set new CCPN value */
    icr_temp.bits.ccpn = OSEE_ISR2_MAX_HW_PRIO;
    osEE_tc_set_icr(icr_temp);
  }

  return icr.reg;
8000945a:	02 23       	mov %d3,%d2
      ev = E_OS_CORE;
    } else
#endif /* !OSEE_SINGLECORE */
#endif /* OSEE_HAS_CHECKS */
    {
      if (current_prio < reso_prio) {
8000945c:	7f f4 16 80 	jge.u %d4,%d15,80009488 <GetResource+0x82>
        p_curr_tcb->current_prio = reso_prio;
80009460:	28 1f       	st.b [%a15]1,%d15

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
80009462:	37 0f 48 50 	extr %d5,%d15,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
80009466:	8b ff 2f 72 	ne %d7,%d15,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
8000946a:	16 7f       	and %d15,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
8000946c:	c2 1f       	add %d15,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
8000946e:	8f 02 d0 61 	andn %d6,%d2,256
80009472:	8f f2 cf 31 	andn %d3,%d2,255
80009476:	a6 f3       	or %d3,%d15
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
80009478:	8f f2 cf 21 	andn %d2,%d2,255
8000947c:	2b 63 40 37 	sel %d3,%d7,%d3,%d6
80009480:	8b 05 40 52 	lt %d5,%d5,0
80009484:	2b 23 40 35 	sel %d3,%d5,%d3,%d2
        flags = osEE_hal_prepare_ipl(flags, reso_prio);
      }

      p_reso_cb->p_owner    = p_curr;
80009488:	b5 24 08 00 	st.a [%a2]8,%a4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000948c:	4d c0 e2 5f 	mfcr %d5,$icr
80009490:	02 5f       	mov %d15,%d5
80009492:	8f f5 0f 51 	and %d5,%d5,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009496:	8f f3 0f 21 	and %d2,%d3,255
8000949a:	5f 25 08 00 	jeq %d5,%d2,800094aa <GetResource+0xa4>
8000949e:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800094a2:	cd cf e2 0f 	mtcr $icr,%d15
800094a6:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      p_reso_cb->p_next     = p_curr_tcb->p_last_m;
800094aa:	4c f1       	ld.w %d15,[%a15]4
800094ac:	6c 20       	st.w [%a2]0,%d15
      p_reso_cb->prev_prio  = current_prio;
800094ae:	e9 24 04 00 	st.b [%a2]4,%d4
      p_curr_tcb->p_last_m  = p_reso_db;
800094b2:	e8 13       	st.a [%a15]4,%a3

      ev = E_OK;
800094b4:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetResource);

  return ev;
}
800094b6:	00 90       	ret 

800094b8 <ReleaseResource>:
FUNC(StatusType, OS_CODE)
  ReleaseResource
(
  VAR(ResourceType, AUTOMATIC) ResID
)
{
800094b8:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
800094ba:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_curr = p_ccb->p_curr;
800094be:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
800094c2:	c8 03       	ld.a %a3,[%a15]0
800094c4:	91 00 00 f8 	movh.a %a15,32768
800094c8:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
800094cc:	4c f4       	ld.w %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
    ev = E_OS_ID;
800094ce:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_res_id(p_kdb, ResID)) {
800094d0:	7f f4 69 80 	jge.u %d4,%d15,800095a2 <ReleaseResource+0xea>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, TYPEDEF)
      p_curr_tcb  = p_curr->p_tcb;
800094d4:	cc 33       	ld.a %a15,[%a3]12
    CONSTP2VAR(OsEE_ResourceDB, AUTOMATIC, TYPEDEF)
      p_reso_db   = (*p_kdb->p_res_ptr_array)[ResID];
800094d6:	91 00 00 28 	movh.a %a2,32768
800094da:	d9 22 08 30 	lea %a2,[%a2]200 <800000c8 <osEE_kdb_var>>
800094de:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
800094e2:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
    CONSTP2VAR(OsEE_ResourceCB, AUTOMATIC, TYPEDEF)
      p_reso_cb   = p_reso_db->p_cb;
800094e6:	d4 22       	ld.a %a2,[%a2]
800094e8:	d4 22       	ld.a %a2,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800094ea:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800094ee:	8f ff 0f 21 	and %d2,%d15,255
800094f2:	8b 32 a1 22 	ge.u %d2,%d2,19
800094f6:	f6 2a       	jnz %d2,8000950a <ReleaseResource+0x52>
    OsEE_icr icr_temp = icr;
800094f8:	02 f2       	mov %d2,%d15
800094fa:	3b 30 01 30 	mov %d3,19
800094fe:	37 32 08 20 	insert %d2,%d2,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009502:	cd c2 e2 0f 	mtcr $icr,%d2
80009506:	0d 00 c0 04 	isync 
    {
      VAR(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      /* Pop the Resources head */
      p_curr_tcb->p_last_m = p_curr_tcb->p_last_m->p_cb->p_next;
8000950a:	c8 14       	ld.a %a4,[%a15]4
8000950c:	d4 44       	ld.a %a4,[%a4]
8000950e:	54 42       	ld.w %d2,[%a4]
80009510:	68 12       	st.w [%a15]4,%d2

      if (p_curr_tcb->p_last_m != NULL) {
80009512:	df 02 1a 00 	jeq %d2,0,80009546 <ReleaseResource+0x8e>
        CONST(TaskPrio, AUTOMATIC)
          prev_prio = p_reso_cb->prev_prio;
80009516:	39 23 04 00 	ld.bu %d3,[%a2]4

        p_curr_tcb->current_prio = prev_prio;
8000951a:	28 13       	st.b [%a15]1,%d3

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
8000951c:	37 03 48 40 	extr %d4,%d3,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
80009520:	8b f3 2f 62 	ne %d6,%d3,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
80009524:	8f f3 07 31 	and %d3,%d3,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
80009528:	c2 13       	add %d3,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
8000952a:	8f 0f d0 51 	andn %d5,%d15,256
8000952e:	8f ff cf 21 	andn %d2,%d15,255
80009532:	a6 32       	or %d2,%d3
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
80009534:	8f ff cf f1 	andn %d15,%d15,255
80009538:	2b 52 40 26 	sel %d2,%d6,%d2,%d5
8000953c:	8b 04 40 42 	lt %d4,%d4,0
80009540:	2b f2 40 f4 	sel %d15,%d4,%d2,%d15
80009544:	3c 17       	j 80009572 <ReleaseResource+0xba>
        flags = osEE_hal_prepare_ipl(flags, prev_prio);
      } else {
        CONST(TaskPrio, AUTOMATIC)
          dispatch_prio = p_curr->dispatch_prio;
80009546:	39 35 1d 00 	ld.bu %d5,[%a3]29

        p_curr_tcb->current_prio = dispatch_prio;
8000954a:	28 15       	st.b [%a15]1,%d5

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
8000954c:	37 05 48 60 	extr %d6,%d5,0,8
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
80009550:	8b f5 2f 42 	ne %d4,%d5,255
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
      OSEE_B_SET(flags, 8U, 0U, OSEE_ISR2_VIRT_TO_HW_PRIO(virt_prio));
80009554:	8f f5 07 51 	and %d5,%d5,127
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
  } else {
    ret_flags =
80009558:	c2 15       	add %d5,1
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
  } else if (virt_prio == OSEE_ISR_ALL_PRIO) {
    /* Remove the ICR.IE bit from flags */
    ret_flags = OSEE_B_CLEAR(flags, 1U, OSEE_TC_ICR_IE_POS);
8000955a:	8f 0f d0 21 	andn %d2,%d15,256
8000955e:	8f ff cf 31 	andn %d3,%d15,255
80009562:	a6 53       	or %d3,%d5
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_prepare_ipl(OsEE_reg flags, TaskPrio virt_prio)
{
  OsEE_reg ret_flags;
  if (virt_prio < OSEE_ISR2_PRIO_BIT) {
    ret_flags = OSEE_B_SET(flags, 8U, 0U, OSEE_ISR_UNMASKED);
80009564:	8f ff cf 51 	andn %d5,%d15,255
80009568:	2b 23 40 34 	sel %d3,%d4,%d3,%d2
8000956c:	fa 06       	lt %d15,%d6,0
8000956e:	2b 53 40 ff 	sel %d15,%d15,%d3,%d5
        flags = osEE_hal_prepare_ipl(flags, dispatch_prio);
      }

      p_reso_cb->p_owner = NULL;
80009572:	82 02       	mov %d2,0
80009574:	59 22 08 00 	st.w [%a2]8,%d2

      /* Preemption point */
      (void)osEE_scheduler_task_preemption_point(p_kdb);
80009578:	91 00 00 48 	movh.a %a4,32768
8000957c:	d9 44 08 30 	lea %a4,[%a4]200 <800000c8 <osEE_kdb_var>>
80009580:	6d 00 63 03 	call 80009c46 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009584:	4d c0 e2 5f 	mfcr %d5,$icr
80009588:	02 53       	mov %d3,%d5
8000958a:	8f f5 0f 51 	and %d5,%d5,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000958e:	16 ff       	and %d15,255
80009590:	5f f5 08 00 	jeq %d5,%d15,800095a0 <ReleaseResource+0xe8>
80009594:	37 f3 08 30 	insert %d3,%d3,%d15,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009598:	cd c3 e2 0f 	mtcr $icr,%d3
8000959c:	0d 00 c0 04 	isync 

      osEE_end_primitive(flags);

      ev = E_OK;
800095a0:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ReleaseResource);

  return ev;
}
800095a2:	00 90       	ret 

800095a4 <ShutdownOS>:
FUNC(StatusType, OS_CODE)
  ShutdownOS
(
  VAR(StatusType, AUTOMATIC) Error
)
{
800095a4:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
800095a6:	91 00 00 f8 	movh.a %a15,32768
800095aa:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800095ae:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800095b2:	8f f2 0f f1 	and %d15,%d2,255
800095b6:	8b 3f a1 f2 	ge.u %d15,%d15,19
800095ba:	ee 0a       	jnz %d15,800095ce <ShutdownOS+0x2a>
    OsEE_icr icr_temp = icr;
800095bc:	02 2f       	mov %d15,%d2
800095be:	3b 30 01 30 	mov %d3,19
800095c2:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800095c6:	cd cf e2 0f 	mtcr $icr,%d15
800095ca:	0d 00 c0 04 	isync 
  CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
800095ce:	39 ff 10 00 	ld.bu %d15,[%a15]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  {
    if ((os_status == OSEE_KERNEL_STARTED) ||
800095d2:	c2 ff       	add %d15,-1
800095d4:	16 ff       	and %d15,255
800095d6:	ff 2f 08 80 	jge.u %d15,2,800095e6 <ShutdownOS+0x42>
        (os_status == OSEE_KERNEL_STARTING))
    {
      osEE_shutdown_os(p_cdb, Error);
800095da:	91 00 00 48 	movh.a %a4,32768
800095de:	d9 44 1c 30 	lea %a4,[%a4]220 <800000dc <osEE_cdb_var>>
800095e2:	1d ff f3 fc 	j 80008fc8 <osEE_shutdown_os>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800095e6:	4d c0 e2 3f 	mfcr %d3,$icr
800095ea:	02 3f       	mov %d15,%d3
800095ec:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800095f0:	8f f2 0f 21 	and %d2,%d2,255
800095f4:	5f 23 08 00 	jeq %d3,%d2,80009604 <ShutdownOS+0x60>
800095f8:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800095fc:	cd cf e2 0f 	mtcr $icr,%d15
80009600:	0d 00 c0 04 	isync 

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ShutdownOS);
  osEE_end_primitive(flags);

  return ev;
}
80009604:	82 72       	mov %d2,7
80009606:	00 90       	ret 

80009608 <GetTaskID>:
FUNC(StatusType, OS_CODE)
  GetTaskID
(
  VAR(TaskRefType, AUTOMATIC) TaskID
)
{
80009608:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000960a:	91 00 00 f8 	movh.a %a15,32768
8000960e:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
80009612:	3b e0 00 20 	mov %d2,14
  /* [OS566]: The Operating System API shall check in extended mode all pointer
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
80009616:	bd 04 24 00 	jz.a %a4,8000965e <GetTaskID+0x56>
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_tdb = p_ccb->p_curr;
8000961a:	c8 02       	ld.a %a2,[%a15]0
       value to return. If it its ISR2 we have to follow the chain and
       find the first task in the list (which is the running task
       which was preempted by the ISR, which could be the idle task),
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000961c:	39 2f 14 00 	ld.bu %d15,[%a2]20
80009620:	ff 2f 05 80 	jge.u %d15,2,8000962a <GetTaskID+0x22>
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
80009624:	19 22 10 00 	ld.w %d2,[%a2]16
80009628:	3c 19       	j 8000965a <GetTaskID+0x52>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
8000962a:	82 f2       	mov %d2,-1
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000962c:	de 27       	jne %d15,2,8000965a <GetTaskID+0x52>
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;
8000962e:	c8 3f       	ld.a %a15,[%a15]12
80009630:	c8 0f       	ld.a %a15,[%a15]0

      while (p_sn != NULL) {
80009632:	bd 0f 14 00 	jz.a %a15,8000965a <GetTaskID+0x52>
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
80009636:	c8 12       	ld.a %a2,[%a15]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009638:	39 2f 14 00 	ld.bu %d15,[%a2]20
8000963c:	ff 2f 0b 80 	jge.u %d15,2,80009652 <GetTaskID+0x4a>
80009640:	3c 06       	j 8000964c <GetTaskID+0x44>
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
80009642:	c8 12       	ld.a %a2,[%a15]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009644:	39 2f 14 00 	ld.bu %d15,[%a2]20
80009648:	ff 2f 05 80 	jge.u %d15,2,80009652 <GetTaskID+0x4a>
          tid = p_searched_tdb->tid;
8000964c:	19 22 10 00 	ld.w %d2,[%a2]16
          break;
80009650:	3c 05       	j 8000965a <GetTaskID+0x52>
        } else {
          p_sn = p_sn->p_next;
80009652:	c8 0f       	ld.a %a15,[%a15]0
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
80009654:	bd 0f f7 ff 	jnz.a %a15,80009642 <GetTaskID+0x3a>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
80009658:	82 f2       	mov %d2,-1
    } else {
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
8000965a:	74 42       	st.w [%a4],%d2
    ev = E_OK;
8000965c:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskID);

  return ev;
}
8000965e:	00 90       	ret 

80009660 <GetTaskState>:
  GetTaskState
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(TaskStateRefType, AUTOMATIC)  State
)
{
80009660:	40 ae       	mov.aa %a14,%sp
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
80009662:	3b e0 00 20 	mov %d2,14
  /* [SWS_Os_00566]: The Operating System API shall check in extended mode all
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
80009666:	bd 04 38 00 	jz.a %a4,800096d6 <GetTaskState+0x76>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
8000966a:	91 00 00 f8 	movh.a %a15,32768
8000966e:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
80009672:	4c f2       	ld.w %d15,[%a15]8
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009674:	82 32       	mov %d2,3
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009676:	7f f4 30 80 	jge.u %d4,%d15,800096d6 <GetTaskState+0x76>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000967a:	91 00 00 f8 	movh.a %a15,32768
8000967e:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
80009682:	c8 1f       	ld.a %a15,[%a15]4
80009684:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
80009688:	c8 0f       	ld.a %a15,[%a15]0
8000968a:	c8 3f       	ld.a %a15,[%a15]12
    switch (local_state) {
8000968c:	0c f2       	ld.bu %d15,[%a15]2
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
8000968e:	82 02       	mov %d2,0
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
80009690:	ff 6f 23 80 	jge.u %d15,6,800096d6 <GetTaskState+0x76>
80009694:	91 10 00 f8 	movh.a %a15,32769
80009698:	d9 ff 60 a9 	lea %a15,[%a15]-26976 <800096a0 <GetTaskState+0x40>>
8000969c:	90 ff       	addsc.a %a15,%a15,%d15,2
8000969e:	dc 0f       	ji %a15
800096a0:	1d 00 0c 00 	j 800096b8 <GetTaskState+0x58>
800096a4:	1d 00 0e 00 	j 800096c0 <GetTaskState+0x60>
800096a8:	1d 00 0c 00 	j 800096c0 <GetTaskState+0x60>
800096ac:	1d 00 0e 00 	j 800096c8 <GetTaskState+0x68>
800096b0:	1d 00 10 00 	j 800096d0 <GetTaskState+0x70>
800096b4:	1d 00 0e 00 	j 800096d0 <GetTaskState+0x70>
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
800096b8:	82 0f       	mov %d15,0
800096ba:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
800096bc:	82 02       	mov %d2,0
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
    switch (local_state) {
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
        break;
800096be:	00 90       	ret 
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
800096c0:	82 1f       	mov %d15,1
800096c2:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
800096c4:	82 02       	mov %d2,0
        (*State) = SUSPENDED;
        break;
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
800096c6:	00 90       	ret 
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
800096c8:	82 3f       	mov %d15,3
800096ca:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
800096cc:	82 02       	mov %d2,0
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
        break;
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
        break;
800096ce:	00 90       	ret 
      case OSEE_TASK_RUNNING:
      case OSEE_TASK_CHAINED:
        (*State) = RUNNING;
800096d0:	82 4f       	mov %d15,4
800096d2:	2c 40       	st.b [%a4]0,%d15
      default:
	/* this should never happen */
        OSEE_RUN_ASSERT(OSEE_FALSE,"Invalid Task State");
        break;
    }
    ev = E_OK;
800096d4:	82 02       	mov %d2,0
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskState);

  return ev;
}
800096d6:	00 90       	ret 

800096d8 <WaitEvent>:
FUNC(StatusType, OS_CODE)
  WaitEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
800096d8:	40 ae       	mov.aa %a14,%sp
  VAR(StatusType, AUTOMATIC)  ev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb       = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb       = p_cdb->p_ccb;
800096da:	91 00 00 f8 	movh.a %a15,32768
800096de:	99 fc 1c 30 	ld.a %a12,[%a15]220 <800000dc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
800096e2:	d4 cd       	ld.a %a13,[%a12]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
800096e4:	cc d3       	ld.a %a15,[%a13]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800096e6:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800096ea:	8f f8 0f f1 	and %d15,%d8,255
800096ee:	8b 3f a1 f2 	ge.u %d15,%d15,19
800096f2:	ee 0a       	jnz %d15,80009706 <WaitEvent+0x2e>
    OsEE_icr icr_temp = icr;
800096f4:	02 8f       	mov %d15,%d8
800096f6:	3b 30 01 20 	mov %d2,19
800096fa:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800096fe:	cd cf e2 0f 	mtcr $icr,%d15
80009702:	0d 00 c0 04 	isync 
    /* Start Critical Section */
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);

    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
80009706:	4c f3       	ld.w %d15,[%a15]12
80009708:	26 4f       	and %d15,%d4
8000970a:	ee 13       	jnz %d15,80009730 <WaitEvent+0x58>
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;
8000970c:	68 24       	st.w [%a15]8,%d4

      p_curr_tcb->p_own_sn =
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000970e:	91 00 00 48 	movh.a %a4,32768
80009712:	d9 44 1c 30 	lea %a4,[%a4]220 <800000dc <osEE_cdb_var>>
80009716:	d9 c5 04 00 	lea %a5,[%a12]4 <800000dc <osEE_cdb_var>>
8000971a:	6d 00 98 01 	call 80009a4a <osEE_scheduler_core_pop_running>
    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;

      p_curr_tcb->p_own_sn =
8000971e:	e8 42       	st.a [%a15]16,%a2
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);

      p_curr_tcb->status = OSEE_TASK_WAITING;
80009720:	82 3f       	mov %d15,3
80009722:	28 2f       	st.b [%a15]2,%d15

      osEE_unlock_core(p_cdb);

      osEE_change_context_from_running(p_curr, p_ccb->p_curr);
80009724:	40 d4       	mov.aa %a4,%a13
80009726:	d4 c5       	ld.a %a5,[%a12]
80009728:	6d 00 c1 02 	call 80009caa <osEE_change_context_from_running>

      /* Reset the waiting mask when we exit from the wait condition. */
      p_curr_tcb->wait_mask = 0U;
8000972c:	82 0f       	mov %d15,0
8000972e:	68 2f       	st.w [%a15]8,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009730:	4d c0 e2 3f 	mfcr %d3,$icr
80009734:	02 3f       	mov %d15,%d3
80009736:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000973a:	8f f8 0f 21 	and %d2,%d8,255
8000973e:	5f 23 08 00 	jeq %d3,%d2,8000974e <WaitEvent+0x76>
80009742:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009746:	cd cf e2 0f 	mtcr $icr,%d15
8000974a:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_WaitEvent);

  return ev;
}
8000974e:	82 02       	mov %d2,0
80009750:	00 90       	ret 

80009752 <SetEvent>:
  SetEvent
(
  VAR(TaskType,      AUTOMATIC) TaskID,
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
80009752:	40 ae       	mov.aa %a14,%sp
80009754:	20 08       	sub.a %sp,8
80009756:	91 00 00 f8 	movh.a %a15,32768
8000975a:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
8000975e:	4c f2       	ld.w %d15,[%a15]8
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009760:	3f f4 06 80 	jlt.u %d4,%d15,8000976c <SetEvent+0x1a>
    ev = E_OS_ID;
80009764:	82 3f       	mov %d15,3
80009766:	e9 ef ff ff 	st.b [%a14]-1,%d15
8000976a:	3c 3c       	j 800097e2 <SetEvent+0x90>
  } else {
    P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_sn;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_waking_up = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000976c:	91 00 00 f8 	movh.a %a15,32768
80009770:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
80009774:	c8 1f       	ld.a %a15,[%a15]4
80009776:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000977a:	c8 04       	ld.a %a4,[%a15]0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000977c:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009780:	8f f8 0f f1 	and %d15,%d8,255
80009784:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009788:	ee 0a       	jnz %d15,8000979c <SetEvent+0x4a>
    OsEE_icr icr_temp = icr;
8000978a:	02 8f       	mov %d15,%d8
8000978c:	3b 30 01 20 	mov %d2,19
80009790:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009794:	cd cf e2 0f 	mtcr $icr,%d15
80009798:	0d 00 c0 04 	isync 
8000979c:	02 54       	mov %d4,%d5
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    p_sn = osEE_task_event_set_mask(p_tdb_waking_up, Mask, &ev);
8000979e:	d9 e5 ff ff 	lea %a5,[%a14]-1
800097a2:	6d 00 82 01 	call 80009aa6 <osEE_task_event_set_mask>

    if (p_sn != NULL) {
800097a6:	bc 2f       	jz.a %a2,800097c4 <SetEvent+0x72>
      /* Release the TASK (and the SN) */
      if (osEE_scheduler_task_unblocked(p_kdb, p_sn))
800097a8:	91 00 00 48 	movh.a %a4,32768
800097ac:	d9 44 08 30 	lea %a4,[%a4]200 <800000c8 <osEE_kdb_var>>
800097b0:	40 25       	mov.aa %a5,%a2
800097b2:	6d 00 e7 01 	call 80009b80 <osEE_scheduler_task_unblocked>
800097b6:	76 27       	jz %d2,800097c4 <SetEvent+0x72>
      {
        (void)osEE_scheduler_task_preemption_point(p_kdb);
800097b8:	91 00 00 48 	movh.a %a4,32768
800097bc:	d9 44 08 30 	lea %a4,[%a4]200 <800000c8 <osEE_kdb_var>>
800097c0:	6d 00 43 02 	call 80009c46 <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800097c4:	4d c0 e2 3f 	mfcr %d3,$icr
800097c8:	02 3f       	mov %d15,%d3
800097ca:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800097ce:	8f f8 0f 21 	and %d2,%d8,255
800097d2:	5f 23 08 00 	jeq %d3,%d2,800097e2 <SetEvent+0x90>
800097d6:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800097da:	cd cf e2 0f 	mtcr $icr,%d15
800097de:	0d 00 c0 04 	isync 
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
800097e2:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
800097e6:	00 90       	ret 

800097e8 <GetEvent>:
  GetEvent
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(EventMaskRefType, AUTOMATIC)  Event
)
{
800097e8:	40 ae       	mov.aa %a14,%sp
800097ea:	91 00 00 f8 	movh.a %a15,32768
800097ee:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
800097f2:	4c f2       	ld.w %d15,[%a15]8
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
800097f4:	82 32       	mov %d2,3
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
800097f6:	7f f4 11 80 	jge.u %d4,%d15,80009818 <GetEvent+0x30>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
800097fa:	91 00 00 f8 	movh.a %a15,32768
800097fe:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
80009802:	c8 1f       	ld.a %a15,[%a15]4
80009804:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_event = p_tdb_event->p_tcb;
80009808:	c8 0f       	ld.a %a15,[%a15]0
8000980a:	c8 3f       	ld.a %a15,[%a15]12
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
      ev = E_OS_PARAM_POINTER;
8000980c:	3b e0 00 20 	mov %d2,14
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
80009810:	bc 44       	jz.a %a4,80009818 <GetEvent+0x30>
      ev = E_OS_PARAM_POINTER;
    } else
    {
      /* N.B. XXX This MUST Be ATOMIC! */
      (*Event) = p_tcb_event->event_mask;
80009812:	4c f3       	ld.w %d15,[%a15]12
80009814:	6c 40       	st.w [%a4]0,%d15

      ev = E_OK;
80009816:	82 02       	mov %d2,0
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
80009818:	00 90       	ret 

8000981a <ClearEvent>:
FUNC(StatusType, OS_CODE)
  ClearEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000981a:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb       = p_cdb->p_ccb;
8000981c:	91 00 00 f8 	movh.a %a15,32768
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
80009820:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
80009824:	c8 0f       	ld.a %a15,[%a15]0
80009826:	c8 3f       	ld.a %a15,[%a15]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009828:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000982c:	8f f2 0f f1 	and %d15,%d2,255
80009830:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009834:	ee 0a       	jnz %d15,80009848 <ClearEvent+0x2e>
    OsEE_icr icr_temp = icr;
80009836:	02 2f       	mov %d15,%d2
80009838:	3b 30 01 30 	mov %d3,19
8000983c:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009840:	cd cf e2 0f 	mtcr $icr,%d15
80009844:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);
    /* XXX: Maybe we need to introduce an HAL for atomic Load-Modify-Store
            Operations */
    p_curr_tcb->event_mask &= ~Mask;
80009848:	4c f3       	ld.w %d15,[%a15]12
8000984a:	0f 4f e0 40 	andn %d4,%d15,%d4
8000984e:	68 34       	st.w [%a15]12,%d4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009850:	4d c0 e2 3f 	mfcr %d3,$icr
80009854:	02 3f       	mov %d15,%d3
80009856:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000985a:	8f f2 0f 21 	and %d2,%d2,255
8000985e:	5f 23 08 00 	jeq %d3,%d2,8000986e <ClearEvent+0x54>
80009862:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009866:	cd cf e2 0f 	mtcr $icr,%d15
8000986a:	0d 00 c0 04 	isync 
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ClearEvent);

  return ev;
}
8000986e:	82 02       	mov %d2,0
80009870:	00 90       	ret 

80009872 <GetISRID>:
FUNC(ISRType, OS_CODE)
  GetISRID
(
  void
)
{
80009872:	40 ae       	mov.aa %a14,%sp
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
80009874:	91 00 00 f8 	movh.a %a15,32768
80009878:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
8000987c:	c8 0f       	ld.a %a15,[%a15]0
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000987e:	39 ff 14 00 	ld.bu %d15,[%a15]20 <800000dc <osEE_cdb_var>>
    isr_id = p_tdb->tid;
  } else {
    isr_id = INVALID_ISR;
80009882:	82 f2       	mov %d2,-1
{
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
80009884:	5e 22       	jne %d15,2,80009888 <GetISRID+0x16>
    isr_id = p_tdb->tid;
80009886:	48 42       	ld.w %d2,[%a15]16
  } else {
    isr_id = INVALID_ISR;
  }

  return isr_id;
}
80009888:	00 90       	ret 
	...

8000988c <osEE_release_all_m>:
static FUNC_P2VAR(OsEE_MDB, OS_APPL_CONST, OS_CODE)
  osEE_release_all_m
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb
)
{
8000988c:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000988e:	99 43 0c 00 	ld.a %a3,[%a4]12

  while ((p_tcb->p_last_m != NULL)
80009892:	cc 31       	ld.a %a15,[%a3]4
  osEE_release_all_m
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
80009894:	a0 02       	mov.a %a2,0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
80009896:	bc fb       	jz.a %a15,800098ac <osEE_release_all_m+0x20>
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
80009898:	82 0f       	mov %d15,0
    && (p_tcb->p_last_m->p_cb->p_owner == p_tdb)
#endif /* OSEE_HAS_SPINLOCKS */
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
8000989a:	c8 0f       	ld.a %a15,[%a15]0
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000989c:	68 2f       	st.w [%a15]8,%d15
    /* Save the first M not realesed */
    if (p_mdb == NULL) {
8000989e:	7c 23       	jnz.a %a2,800098a4 <osEE_release_all_m+0x18>
      p_mdb = p_tcb->p_last_m;
800098a0:	99 32 04 00 	ld.a %a2,[%a3]4
      osEE_hal_spin_unlock(p_tcb->p_last_m->p_spinlock_arch);
    }
#endif /* OSEE_HAS_SPINLOCKS */

    /* Pop the M head */
    p_tcb->p_last_m = p_last_m_cb->p_next;
800098a4:	c8 0f       	ld.a %a15,[%a15]0
800098a6:	ec 31       	st.a [%a3]4,%a15
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
800098a8:	bd 0f f9 ff 	jnz.a %a15,8000989a <osEE_release_all_m+0xe>
    p_tcb->p_last_m = NULL;
  }
#endif /* OSEE_HAS_SPINLOCKS */

  return p_mdb;
}
800098ac:	00 90       	ret 

800098ae <osEE_scheduler_task_wrapper_restore>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_restore
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
800098ae:	40 ae       	mov.aa %a14,%sp
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
800098b0:	cc 43       	ld.a %a15,[%a4]12
800098b2:	82 4f       	mov %d15,4
800098b4:	28 2f       	st.b [%a15]2,%d15
800098b6:	00 90       	ret 

800098b8 <osEE_scheduler_task_wrapper_run>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
800098b8:	40 ae       	mov.aa %a14,%sp
800098ba:	40 4f       	mov.aa %a15,%a4
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
800098bc:	99 42 0c 00 	ld.a %a2,[%a4]12
800098c0:	39 22 01 00 	ld.bu %d2,[%a2]1
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
800098c4:	82 4f       	mov %d15,4
800098c6:	2c 22       	st.b [%a2]2,%d15
)
{
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
  osEE_scheduler_task_wrapper_restore(p_tdb_to);

  if (task_priority < OSEE_ISR_ALL_PRIO) {
800098c8:	8b f2 0f f2 	eq %d15,%d2,255
800098cc:	ee 13       	jnz %d15,800098f2 <osEE_scheduler_task_wrapper_run+0x3a>
800098ce:	4d c0 e2 ff 	mfcr %d15,$icr

/* We always use virtual priorities */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_set_ipl(TaskPrio virt_prio)
{
  OsEE_icr icr  = osEE_tc_get_icr();
  icr.bits.ccpn = (virt_prio < OSEE_ISR2_PRIO_BIT)?
800098d2:	37 02 48 40 	extr %d4,%d2,0,8
800098d6:	82 03       	mov %d3,0
800098d8:	ce 45       	jgez %d4,800098e2 <osEE_scheduler_task_wrapper_run+0x2a>
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
800098da:	8f f2 07 21 	and %d2,%d2,127
800098de:	1b 12 00 30 	addi %d3,%d2,1
800098e2:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800098e6:	cd cf e2 0f 	mtcr $icr,%d15
800098ea:	0d 00 c0 04 	isync 
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
800098ee:	0d 00 00 03 	enable 
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
800098f2:	c8 62       	ld.a %a2,[%a15]24
800098f4:	2d 02 00 00 	calli %a2
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
800098f8:	91 00 00 28 	movh.a %a2,32768
800098fc:	99 22 1c 30 	ld.a %a2,[%a2]220 <800000dc <osEE_cdb_var>>

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
80009900:	82 0f       	mov %d15,0
80009902:	e9 2f 1d 00 	st.b [%a2]29,%d15
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
80009906:	39 2f 1c 00 	ld.bu %d15,[%a2]28
8000990a:	6e 09       	jz %d15,8000991c <osEE_scheduler_task_wrapper_run+0x64>
    p_ccb->s_isr_all_cnt = 0U;
8000990c:	82 0f       	mov %d15,0
8000990e:	e9 2f 1c 00 	st.b [%a2]28,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009912:	4c 25       	ld.w %d15,[%a2]20
80009914:	cd cf e2 0f 	mtcr $icr,%d15
80009918:	0d 00 c0 04 	isync 
    osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
  }
  if (p_ccb->d_isr_all_cnt > 0U) {
8000991c:	39 2f 1e 00 	ld.bu %d15,[%a2]30
80009920:	6e 06       	jz %d15,8000992c <osEE_scheduler_task_wrapper_run+0x74>
    p_ccb->d_isr_all_cnt = 0U;
80009922:	82 0f       	mov %d15,0
80009924:	e9 2f 1e 00 	st.b [%a2]30,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009928:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000992c:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009930:	8f ff 0f 21 	and %d2,%d15,255
80009934:	8b 32 a1 22 	ge.u %d2,%d2,19
80009938:	f6 29       	jnz %d2,8000994a <osEE_scheduler_task_wrapper_run+0x92>
8000993a:	3b 30 01 20 	mov %d2,19
8000993e:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009942:	cd cf e2 0f 	mtcr $icr,%d15
80009946:	0d 00 c0 04 	isync 

  (void)osEE_begin_primitive();

  osEE_stack_monitoring(p_cdb);

  if (p_to_term->task_type == OSEE_TASK_TYPE_ISR2) {
8000994a:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000994e:	5e 24       	jne %d15,2,80009956 <osEE_scheduler_task_wrapper_run+0x9e>
  /* [SWS_Os_00369]: If a Category 2 ISR calls GetResource() and ends (returns)
      without calling the corresponding ReleaseResource(), the Operating System
      module shall perform the ReleaseResource() call and shall call the
      ErrorHook() E_OS_RESOURCE */
    CONSTP2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)
      p_mdb = osEE_release_all_m(p_to_term);
80009950:	40 f4       	mov.aa %a4,%a15
80009952:	5c 9d       	call 8000988c <osEE_release_all_m>
80009954:	3c 03       	j 8000995a <osEE_scheduler_task_wrapper_run+0xa2>
    osEE_call_error_hook(p_ccb, E_OS_MISSINGEND);
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
/* [SWS_Os_0070]: If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and still holds OSEK Resources,
    the Operating System shall release them. */
    (void)osEE_release_all_m(p_to_term);
80009956:	40 f4       	mov.aa %a4,%a15
80009958:	5c 9a       	call 8000988c <osEE_release_all_m>
8000995a:	c8 14       	ld.a %a4,[%a15]4
8000995c:	a0 05       	mov.a %a5,0
8000995e:	1d 00 79 02 	j 80009e50 <osEE_hal_terminate_ctx>

80009962 <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
80009962:	40 ae       	mov.aa %a14,%sp
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
80009964:	91 00 00 f8 	movh.a %a15,32768
80009968:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
8000996c:	39 ff 10 00 	ld.bu %d15,[%a15]16 <800000dc <osEE_cdb_var>>
80009970:	df 2f fe 7f 	jeq %d15,2,8000996c <osEE_idle_hook_wrapper+0xa>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
80009974:	91 00 00 f8 	movh.a %a15,32768
80009978:	d9 ff 1c 30 	lea %a15,[%a15]220 <800000dc <osEE_cdb_var>>
8000997c:	c8 14       	ld.a %a4,[%a15]4
8000997e:	6d 00 ba 01 	call 80009cf2 <osEE_idle_task_terminate>
80009982:	00 90       	ret 

80009984 <osEE_scheduler_core_rq_preempt_stk>:
  osEE_scheduler_core_rq_preempt_stk
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
80009984:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009986:	d4 43       	ld.a %a3,[%a4]
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
80009988:	cc 50       	ld.a %a15,[%a5]0
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;
8000998a:	99 32 0c 00 	ld.a %a2,[%a3]12

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
8000998e:	bd 02 13 00 	jz.a %a2,800099b4 <osEE_scheduler_core_rq_preempt_stk+0x30>
    p_ret_tdb = p_ret_sn->p_tdb;
80009992:	99 22 04 00 	ld.a %a2,[%a2]4
    if (p_rq_sn != NULL) {
80009996:	bd 0f 1b 00 	jz.a %a15,800099cc <osEE_scheduler_core_rq_preempt_stk+0x48>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
8000999a:	99 24 0c 00 	ld.a %a4,[%a2]12
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000999e:	c8 16       	ld.a %a6,[%a15]4
800099a0:	99 66 0c 00 	ld.a %a6,[%a6]12
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
800099a4:	39 42 01 00 	ld.bu %d2,[%a4]1
800099a8:	0c 61       	ld.bu %d15,[%a6]1
800099aa:	7f f2 13 80 	jge.u %d2,%d15,800099d0 <osEE_scheduler_core_rq_preempt_stk+0x4c>
      {
        /* RQ preempt STK */
        /* Call PostTaskHook before switching active TASK */
        osEE_call_post_task_hook(p_ccb);

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
800099ae:	82 2f       	mov %d15,2
800099b0:	2c 42       	st.b [%a4]2,%d15
800099b2:	3c 11       	j 800099d4 <osEE_scheduler_core_rq_preempt_stk+0x50>
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
800099b4:	a0 02       	mov.a %a2,0

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
800099b6:	bd 0f 1e 00 	jz.a %a15,800099f2 <osEE_scheduler_core_rq_preempt_stk+0x6e>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
800099ba:	99 42 04 00 	ld.a %a2,[%a4]4
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
800099be:	99 24 0c 00 	ld.a %a4,[%a2]12
800099c2:	82 2f       	mov %d15,2
800099c4:	2c 42       	st.b [%a4]2,%d15
800099c6:	3c 07       	j 800099d4 <osEE_scheduler_core_rq_preempt_stk+0x50>
  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
    if (p_tcb->current_prio < dispatch_prio) {
      p_tcb->current_prio = dispatch_prio;
800099c8:	2c 51       	st.b [%a5]1,%d15
800099ca:	00 90       	ret 
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
800099cc:	a0 02       	mov.a %a2,0
800099ce:	00 90       	ret 
800099d0:	a0 02       	mov.a %a2,0
800099d2:	00 90       	ret 
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
800099d4:	4c f0       	ld.w %d15,[%a15]0
800099d6:	6c 50       	st.w [%a5]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
800099d8:	c8 14       	ld.a %a4,[%a15]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
800099da:	99 45 0c 00 	ld.a %a5,[%a4]12
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
800099de:	4c 33       	ld.w %d15,[%a3]12
800099e0:	68 0f       	st.w [%a15]0,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
800099e2:	ec 33       	st.a [%a3]12,%a15
  p_ccb->p_curr                 = p_tdb;
800099e4:	f4 34       	st.a [%a3],%a4

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
800099e6:	39 4f 1d 00 	ld.bu %d15,[%a4]29
    if (p_tcb->current_prio < dispatch_prio) {
800099ea:	39 52 01 00 	ld.bu %d2,[%a5]1
800099ee:	3f f2 ed ff 	jlt.u %d2,%d15,800099c8 <osEE_scheduler_core_rq_preempt_stk+0x44>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
800099f2:	00 90       	ret 

800099f4 <osEE_sn_priority_insert>:
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
800099f4:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
800099f6:	cc 51       	ld.a %a15,[%a5]4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
800099f8:	c8 32       	ld.a %a2,[%a15]12
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
800099fa:	76 44       	jz %d4,80009a02 <osEE_sn_priority_insert+0xe>
800099fc:	39 f2 1c 00 	ld.bu %d2,[%a15]28
80009a00:	3c 03       	j 80009a06 <osEE_sn_priority_insert+0x12>
80009a02:	39 22 01 00 	ld.bu %d2,[%a2]1
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
80009a06:	cc 40       	ld.a %a15,[%a4]0
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
80009a08:	a0 06       	mov.a %a6,0
80009a0a:	7c f3       	jnz.a %a15,80009a10 <osEE_sn_priority_insert+0x1c>
80009a0c:	3c 14       	j 80009a34 <osEE_sn_priority_insert+0x40>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
80009a0e:	60 ff       	mov.a %a15,%d15
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
80009a10:	c8 12       	ld.a %a2,[%a15]4
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
80009a12:	99 23 0c 00 	ld.a %a3,[%a2]12

    if (as_ready) {
80009a16:	76 44       	jz %d4,80009a1e <osEE_sn_priority_insert+0x2a>
      prio_to_check = p_cur_tdb->ready_prio;
80009a18:	39 2f 1c 00 	ld.bu %d15,[%a2]28
80009a1c:	3c 02       	j 80009a20 <osEE_sn_priority_insert+0x2c>
    } else {
      prio_to_check = p_cur_tcb->current_prio;
80009a1e:	0c 31       	ld.bu %d15,[%a3]1
    }

    if (new_task_prio <= prio_to_check)
80009a20:	3f 2f 06 80 	jlt.u %d15,%d2,80009a2c <osEE_sn_priority_insert+0x38>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
80009a24:	4c f0       	ld.w %d15,[%a15]0
80009a26:	40 f6       	mov.aa %a6,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
80009a28:	ee f3       	jnz %d15,80009a0e <osEE_sn_priority_insert+0x1a>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
80009a2a:	60 ff       	mov.a %a15,%d15
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
80009a2c:	bc 64       	jz.a %a6,80009a34 <osEE_sn_priority_insert+0x40>
    p_prev->p_next = p_sn_new;
80009a2e:	f4 65       	st.a [%a6],%a5
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
80009a30:	82 02       	mov %d2,0
80009a32:	3c 03       	j 80009a38 <osEE_sn_priority_insert+0x44>
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
80009a34:	f4 45       	st.a [%a4],%a5
    head_changed  = OSEE_TRUE;
80009a36:	82 12       	mov %d2,1
  }

  p_sn_new->p_next = p_curr;
80009a38:	ec 50       	st.a [%a5]0,%a15

  return head_changed;
}
80009a3a:	00 90       	ret 

80009a3c <osEE_scheduler_rq_insert>:
(
  P2VAR(OsEE_RQ, AUTOMATIC, OS_APPL_DATA)       p_rq,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_sn_new,
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new
)
{
80009a3c:	40 ae       	mov.aa %a14,%sp
  p_sn_new->p_tdb = p_tdb_new;
80009a3e:	b5 56 04 00 	st.a [%a5]4,%a6

#if (!defined(OSEE_SCHEDULER_GLOBAL))
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_TRUE);
80009a42:	82 14       	mov %d4,1
80009a44:	6d ff d8 ff 	call 800099f4 <osEE_sn_priority_insert>
#else
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_FALSE);
#endif /* !OSEE_SCHEDULER_GLOBAL */
}
80009a48:	00 90       	ret 

80009a4a <osEE_scheduler_core_pop_running>:
  osEE_scheduler_core_pop_running
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
80009a4a:	40 ae       	mov.aa %a14,%sp
80009a4c:	40 4d       	mov.aa %a13,%a4
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
80009a4e:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
80009a50:	c8 3c       	ld.a %a12,[%a15]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
80009a52:	4c c0       	ld.w %d15,[%a12]0
80009a54:	68 3f       	st.w [%a15]12,%d15
   * */

  {
    /* Handle if RQ preempt STK (It manipulate the core data structures) */
    CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
      p_preempt = osEE_scheduler_core_rq_preempt_stk(p_cdb, p_rq);
80009a56:	6d ff 97 ff 	call 80009984 <osEE_scheduler_core_rq_preempt_stk>
    CONSTP2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_curr_stk_sn = p_ccb->p_stk_sn;
80009a5a:	4c f3       	ld.w %d15,[%a15]12

    /* If not, resume current STK first */
    if (p_preempt == NULL) {
80009a5c:	7c 28       	jnz.a %a2,80009a6c <osEE_scheduler_core_pop_running+0x22>
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

      if (p_curr_stk_sn != NULL) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
80009a5e:	80 d3       	mov.d %d3,%a13
80009a60:	c2 43       	add %d3,4
80009a62:	92 42       	add %d2,%d15,4
80009a64:	6a 32       	cmovn %d2,%d15,%d3
80009a66:	60 2d       	mov.a %a13,%d2
80009a68:	4c d0       	ld.w %d15,[%a13]0
80009a6a:	68 0f       	st.w [%a15]0,%d15
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
80009a6c:	40 c2       	mov.aa %a2,%a12
80009a6e:	00 90       	ret 

80009a70 <osEE_task_activated>:

FUNC(StatusType, OS_CODE) osEE_task_activated
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
80009a70:	40 ae       	mov.aa %a14,%sp
  VAR(StatusType, AUTOMATIC)                    ev;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act = p_tdb_act->p_tcb;
80009a72:	cc 43       	ld.a %a15,[%a4]12
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
80009a74:	0c f0       	ld.bu %d15,[%a15]0
80009a76:	39 43 1e 00 	ld.bu %d3,[%a4]30
    ++p_tcb_act->current_num_of_act;
    ev = E_OK;
  } else {
    ev = E_OS_LIMIT;
80009a7a:	82 42       	mov %d2,4
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
80009a7c:	7f 3f 05 80 	jge.u %d15,%d3,80009a86 <osEE_task_activated+0x16>
    ++p_tcb_act->current_num_of_act;
80009a80:	c2 1f       	add %d15,1
80009a82:	28 0f       	st.b [%a15]0,%d15
    ev = E_OK;
80009a84:	82 02       	mov %d2,0
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
80009a86:	00 90       	ret 

80009a88 <osEE_task_end>:
FUNC(void, OS_CODE)
  osEE_task_end
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
80009a88:	40 ae       	mov.aa %a14,%sp
  /* It has to be called already in Multi-Core critical section */
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
80009a8a:	cc 43       	ld.a %a15,[%a4]12

  p_tcb->current_prio = p_tdb->ready_prio;
80009a8c:	39 4f 1c 00 	ld.bu %d15,[%a4]28
80009a90:	28 1f       	st.b [%a15]1,%d15

  --p_tcb->current_num_of_act;
80009a92:	0c f0       	ld.bu %d15,[%a15]0
80009a94:	c2 ff       	add %d15,-1
80009a96:	16 ff       	and %d15,255
80009a98:	28 0f       	st.b [%a15]0,%d15

  if (p_tcb->current_num_of_act == 0U) {
80009a9a:	ee 03       	jnz %d15,80009aa0 <osEE_task_end+0x18>
    p_tcb->status = OSEE_TASK_SUSPENDED;
80009a9c:	28 2f       	st.b [%a15]2,%d15
80009a9e:	00 90       	ret 
  } else {
    p_tcb->status = OSEE_TASK_READY;
80009aa0:	82 1f       	mov %d15,1
80009aa2:	28 2f       	st.b [%a15]2,%d15
80009aa4:	00 90       	ret 

80009aa6 <osEE_task_event_set_mask>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)    p_tdb_waking_up,
  VAR(EventMaskType, AUTOMATIC)               Mask,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
80009aa6:	40 ae       	mov.aa %a14,%sp
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_waking_up = p_tdb_waking_up->p_tcb;
80009aa8:	cc 43       	ld.a %a15,[%a4]12
    *p_ev = E_OS_STATE;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;
80009aaa:	02 42       	mov %d2,%d4
80009aac:	02 43       	mov %d3,%d4
80009aae:	49 f2 4c 08 	ldmst [%a15]12,%e2

    *p_ev = E_OK;
80009ab2:	82 0f       	mov %d15,0
80009ab4:	2c 50       	st.b [%a5]0,%d15

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
80009ab6:	4c f2       	ld.w %d15,[%a15]8
80009ab8:	26 f4       	and %d4,%d15
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
80009aba:	a0 02       	mov.a %a2,0
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;

    *p_ev = E_OK;

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
80009abc:	76 45       	jz %d4,80009ac6 <osEE_task_event_set_mask+0x20>
      p_own_sn = p_tcb_waking_up->p_own_sn;
80009abe:	c8 42       	ld.a %a2,[%a15]16

      /* Set p_own_sn of waking up task to NULL so it won't be inserted in
         RQ more than once. */
      if (p_own_sn != NULL) {
80009ac0:	bc 23       	jz.a %a2,80009ac6 <osEE_task_event_set_mask+0x20>
        p_tcb_waking_up->p_own_sn = NULL;
80009ac2:	82 0f       	mov %d15,0
80009ac4:	68 4f       	st.w [%a15]16,%d15
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return p_own_sn;
}
80009ac6:	00 90       	ret 

80009ac8 <osEE_activate_isr2>:
FUNC(void, OS_CODE)
  osEE_activate_isr2
(
  VAR(TaskType, AUTOMATIC) isr2_id
)
{
80009ac8:	40 ae       	mov.aa %a14,%sp
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
80009aca:	91 00 00 48 	movh.a %a4,32768
80009ace:	d9 44 08 30 	lea %a4,[%a4]200 <800000c8 <osEE_kdb_var>>
80009ad2:	cc 41       	ld.a %a15,[%a4]4
80009ad4:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
80009ad8:	c8 05       	ld.a %a5,[%a15]0

    /* Mark the TASK as Activated (I don't need to protect this increment
       since ISRs cannot be activated by another core (exception done for
       IPI, that have to be handled in a special way in any case). */
    ++p_act_tdb->p_tcb->current_num_of_act;
80009ada:	cc 53       	ld.a %a15,[%a5]12
80009adc:	0c f0       	ld.bu %d15,[%a15]0
80009ade:	c2 1f       	add %d15,1
80009ae0:	28 0f       	st.b [%a15]0,%d15

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
80009ae2:	a0 06       	mov.a %a6,0
80009ae4:	6d 00 c4 00 	call 80009c6c <osEE_scheduler_task_set_running>
80009ae8:	00 90       	ret 

80009aea <osEE_scheduler_task_activated>:
  osEE_scheduler_task_activated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
80009aea:	40 ae       	mov.aa %a14,%sp
80009aec:	40 56       	mov.aa %a6,%a5
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
80009aee:	99 52 0c 00 	ld.a %a2,[%a5]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
80009af2:	91 00 00 f8 	movh.a %a15,32768
80009af6:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
80009afa:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_curr_tcb  = p_curr->p_tcb;
80009afc:	99 43 0c 00 	ld.a %a3,[%a4]12 <800000dc <osEE_cdb_var>>
    }
    is_preemption = OSEE_FALSE;
  } else
#endif /* !OSEE_SINGLECORE */
  /* Preemption Check */
  if (p_curr_tcb->current_prio < p_tcb_act->current_prio) {
80009b00:	39 32 01 00 	ld.bu %d2,[%a3]1 <800000dc <osEE_cdb_var>>
80009b04:	0c 21       	ld.bu %d15,[%a2]1
80009b06:	7f f2 15 80 	jge.u %d2,%d15,80009b30 <osEE_scheduler_task_activated+0x46>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80009b0a:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
80009b0c:	4c 20       	ld.w %d15,[%a2]0
80009b0e:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
80009b10:	82 02       	mov %d2,0
80009b12:	74 22       	st.w [%a2],%d2
        osEE_call_post_task_hook(p_ccb);
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;
80009b14:	82 2f       	mov %d15,2
80009b16:	2c 32       	st.b [%a3]2,%d15

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
80009b18:	b5 25 04 00 	st.a [%a2]4,%a5
    p_new_stk->p_next           = p_ccb->p_stk_sn;
80009b1c:	4c f3       	ld.w %d15,[%a15]12
80009b1e:	6c 20       	st.w [%a2]0,%d15
    p_ccb->p_stk_sn             = p_new_stk;
80009b20:	e8 32       	st.a [%a15]12,%a2
    p_ccb->p_curr               = p_tdb_act;
80009b22:	e8 05       	st.a [%a15]0,%a5
    osEE_task_event_reset_mask(p_tdb_act->p_tcb);
80009b24:	cc 53       	ld.a %a15,[%a5]12
  osEE_task_event_reset_mask
(
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb
)
{
  p_tcb->event_mask = 0U;
80009b26:	68 32       	st.w [%a15]12,%d2

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_curr, p_tdb_act);
80009b28:	6d 00 c1 00 	call 80009caa <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
80009b2c:	82 12       	mov %d2,1
80009b2e:	00 90       	ret 
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
80009b30:	0c 22       	ld.bu %d15,[%a2]2
80009b32:	ee 05       	jnz %d15,80009b3c <osEE_scheduler_task_activated+0x52>
    p_tcb_act->status = OSEE_TASK_READY;
80009b34:	82 1f       	mov %d15,1
80009b36:	2c 22       	st.b [%a2]2,%d15
80009b38:	82 0f       	mov %d15,0
80009b3a:	6c 23       	st.w [%a2]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80009b3c:	c8 25       	ld.a %a5,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
80009b3e:	4c 50       	ld.w %d15,[%a5]0
80009b40:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
80009b42:	82 0f       	mov %d15,0
80009b44:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
80009b46:	d9 f4 04 00 	lea %a4,[%a15]4
80009b4a:	6d ff 79 ff 	call 80009a3c <osEE_scheduler_rq_insert>
    /* Actually Insert the activated in READY Queue */
    (void)osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);

    osEE_unlock_core(p_cdb);

    is_preemption = OSEE_FALSE;
80009b4e:	82 02       	mov %d2,0
  }

  return is_preemption;
}
80009b50:	00 90       	ret 

80009b52 <osEE_scheduler_task_insert>:
  osEE_scheduler_task_insert
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
80009b52:	40 ae       	mov.aa %a14,%sp
80009b54:	40 56       	mov.aa %a6,%a5
  VAR(OsEE_bool, AUTOMATIC)   head_changed;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_act     = p_tdb_act->p_tcb;
80009b56:	cc 53       	ld.a %a15,[%a5]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb         = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb         = p_cdb->p_ccb;
80009b58:	91 00 00 28 	movh.a %a2,32768
80009b5c:	99 24 1c 30 	ld.a %a4,[%a2]220 <800000dc <osEE_cdb_var>>
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
80009b60:	0c f2       	ld.bu %d15,[%a15]2
80009b62:	ee 05       	jnz %d15,80009b6c <osEE_scheduler_task_insert+0x1a>
    p_tcb_act->status = OSEE_TASK_READY;
80009b64:	82 1f       	mov %d15,1
80009b66:	28 2f       	st.b [%a15]2,%d15
80009b68:	82 0f       	mov %d15,0
80009b6a:	68 3f       	st.w [%a15]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80009b6c:	99 45 08 00 	ld.a %a5,[%a4]8
  (*pp_first)              = p_sn_allocated->p_next;
80009b70:	4c 50       	ld.w %d15,[%a5]0
80009b72:	6c 42       	st.w [%a4]8,%d15
  p_sn_allocated->p_next  = NULL;
80009b74:	82 0f       	mov %d15,0
80009b76:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
80009b78:	b0 44       	add.a %a4,4
80009b7a:	6d ff 61 ff 	call 80009a3c <osEE_scheduler_rq_insert>

    osEE_unlock_core(p_cdb);
  }

  return head_changed;
}
80009b7e:	00 90       	ret 

80009b80 <osEE_scheduler_task_unblocked>:
  osEE_scheduler_task_unblocked
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
80009b80:	40 ae       	mov.aa %a14,%sp
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
80009b82:	99 56 04 00 	ld.a %a6,[%a5]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
80009b86:	cc 63       	ld.a %a15,[%a6]12
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
80009b88:	91 00 00 28 	movh.a %a2,32768
80009b8c:	99 2c 1c 30 	ld.a %a12,[%a2]220 <800000dc <osEE_cdb_var>>

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
80009b90:	82 2f       	mov %d15,2
80009b92:	28 2f       	st.b [%a15]2,%d15
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
80009b94:	39 6f 1c 00 	ld.bu %d15,[%a6]28
80009b98:	28 1f       	st.b [%a15]1,%d15
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
80009b9a:	d9 c4 04 00 	lea %a4,[%a12]4
80009b9e:	6d ff 4f ff 	call 80009a3c <osEE_scheduler_rq_insert>
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
80009ba2:	82 0f       	mov %d15,0
  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
80009ba4:	df 12 0a 80 	jne %d2,1,80009bb8 <osEE_scheduler_task_unblocked+0x38>
    is_preemption = (p_tcb_released->current_prio >
      p_ccb->p_curr->p_tcb->current_prio);
80009ba8:	d4 c2       	ld.a %a2,[%a12]
80009baa:	99 22 0c 00 	ld.a %a2,[%a2]12

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
    is_preemption = (p_tcb_released->current_prio >
80009bae:	0c f1       	ld.bu %d15,[%a15]1
80009bb0:	39 22 01 00 	ld.bu %d2,[%a2]1
80009bb4:	0b f2 30 f1 	lt.u %d15,%d2,%d15
    }
  }
#endif /* !OSEE_SINGLECORE */

  return is_preemption;
}
80009bb8:	02 f2       	mov %d2,%d15
80009bba:	00 90       	ret 

80009bbc <osEE_scheduler_task_terminated>:
  osEE_scheduler_task_terminated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
80009bbc:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009bbe:	91 00 00 f8 	movh.a %a15,32768
80009bc2:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
80009bc6:	c8 0d       	ld.a %a13,[%a15]0
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
80009bc8:	99 dc 0c 00 	ld.a %a12,[%a13]12 <800000dc <osEE_cdb_var>>

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
80009bcc:	f4 5d       	st.a [%a5],%a13

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
80009bce:	0c c2       	ld.bu %d15,[%a12]2
80009bd0:	de 4a       	jne %d15,4,80009c04 <osEE_scheduler_task_terminated+0x48>
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
80009bd2:	91 00 00 48 	movh.a %a4,32768
80009bd6:	d9 44 1c 30 	lea %a4,[%a4]220 <800000dc <osEE_cdb_var>>
80009bda:	d9 f5 04 00 	lea %a5,[%a15]4 <800000dc <osEE_cdb_var>>
80009bde:	6d ff 36 ff 	call 80009a4a <osEE_scheduler_core_pop_running>
80009be2:	80 28       	mov.d %d8,%a2

      p_tdb_to = p_ccb->p_curr;
80009be4:	4c f0       	ld.w %d15,[%a15]0

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
80009be6:	80 d2       	mov.d %d2,%a13
80009be8:	5f f2 06 00 	jeq %d2,%d15,80009bf4 <osEE_scheduler_task_terminated+0x38>
        osEE_task_end(p_tdb_term);
80009bec:	40 d4       	mov.aa %a4,%a13
80009bee:	6d ff 4d ff 	call 80009a88 <osEE_task_end>
80009bf2:	3c 04       	j 80009bfa <osEE_scheduler_task_terminated+0x3e>
#if (defined(OSEE_HAS_PRETASKHOOK))
        /* If TDB_TERM is equal to TDB_TO, the following assure that
         * PreTaskHook will be called */
        p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */
        --p_tcb_term->current_num_of_act;
80009bf4:	14 c2       	ld.bu %d2,[%a12]
80009bf6:	c2 f2       	add %d2,-1
80009bf8:	34 c2       	st.b [%a12],%d2
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
80009bfa:	48 22       	ld.w %d2,[%a15]8
80009bfc:	60 82       	mov.a %a2,%d8
80009bfe:	74 22       	st.w [%a2],%d2
  (*pp_first)       = p_to_free;
80009c00:	68 28       	st.w [%a15]8,%d8
80009c02:	3c 20       	j 80009c42 <osEE_scheduler_task_terminated+0x86>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
80009c04:	c8 35       	ld.a %a5,[%a15]12

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
80009c06:	54 52       	ld.w %d2,[%a5]
80009c08:	68 32       	st.w [%a15]12,%d2
      /* Wait to see p_ccb->p_curr until you are completely sure to what set */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
80009c0a:	39 df 1c 00 	ld.bu %d15,[%a13]28
80009c0e:	2c c1       	st.b [%a12]1,%d15
      p_tcb_term->status = OSEE_TASK_READY;
80009c10:	82 1f       	mov %d15,1
80009c12:	2c c2       	st.b [%a12]2,%d15
#if (defined(OSEE_HAS_EVENTS))
      /* If this activation is the last of a TASK, a chaining is
       * a transition from SUSPENDED to READY so I need to reset Events. */
      if (p_tcb_term->current_num_of_act == 1U) {
80009c14:	0c c0       	ld.bu %d15,[%a12]0
80009c16:	5e 13       	jne %d15,1,80009c1c <osEE_scheduler_task_terminated+0x60>
80009c18:	82 0f       	mov %d15,0
80009c1a:	6c c3       	st.w [%a12]12,%d15
        osEE_task_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
80009c1c:	d9 fc 04 00 	lea %a12,[%a15]4
80009c20:	40 c4       	mov.aa %a4,%a12
80009c22:	40 d6       	mov.aa %a6,%a13
80009c24:	6d ff 0c ff 	call 80009a3c <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
80009c28:	91 00 00 48 	movh.a %a4,32768
80009c2c:	d9 44 1c 30 	lea %a4,[%a4]220 <800000dc <osEE_cdb_var>>
80009c30:	40 c5       	mov.aa %a5,%a12
80009c32:	6d ff a9 fe 	call 80009984 <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
80009c36:	7c 25       	jnz.a %a2,80009c40 <osEE_scheduler_task_terminated+0x84>
          /* Restore Stacked.
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
80009c38:	c8 32       	ld.a %a2,[%a15]12
80009c3a:	4c 21       	ld.w %d15,[%a2]4
          p_ccb->p_curr           = p_tdb_to;
80009c3c:	68 0f       	st.w [%a15]0,%d15
80009c3e:	3c 02       	j 80009c42 <osEE_scheduler_task_terminated+0x86>
        } else {
          p_tdb_to = p_ccb->p_curr;
80009c40:	4c f0       	ld.w %d15,[%a15]0
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
80009c42:	60 f2       	mov.a %a2,%d15
80009c44:	00 90       	ret 

80009c46 <osEE_scheduler_task_preemption_point>:
FUNC(OsEE_bool, OS_CODE)
  osEE_scheduler_task_preemption_point
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb
)
{
80009c46:	40 ae       	mov.aa %a14,%sp
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009c48:	91 00 00 48 	movh.a %a4,32768
80009c4c:	99 4f 1c 30 	ld.a %a15,[%a4]220 <800000dc <osEE_cdb_var>>
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
80009c50:	d9 44 1c 30 	lea %a4,[%a4]220 <800000dc <osEE_cdb_var>>
80009c54:	d9 f5 04 00 	lea %a5,[%a15]4 <800000dc <osEE_cdb_var>>
80009c58:	6d ff 96 fe 	call 80009984 <osEE_scheduler_core_rq_preempt_stk>

    osEE_change_context_from_running(p_prev, p_curr);

    is_preemption = OSEE_TRUE;
  } else {
    is_preemption = OSEE_FALSE;
80009c5c:	82 02       	mov %d2,0
  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);

  /* Unlock the Scheduler (critical section terminated) */
  osEE_unlock_core(p_cdb);

  if (p_prev != NULL) {
80009c5e:	bc 26       	jz.a %a2,80009c6a <osEE_scheduler_task_preemption_point+0x24>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_change_context_from_running(p_prev, p_curr);
80009c60:	40 24       	mov.aa %a4,%a2
80009c62:	c8 05       	ld.a %a5,[%a15]0
80009c64:	6d 00 23 00 	call 80009caa <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
80009c68:	82 12       	mov %d2,1
  } else {
    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
80009c6a:	00 90       	ret 

80009c6c <osEE_scheduler_task_set_running>:
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn
)
{
80009c6c:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
80009c6e:	91 00 00 f8 	movh.a %a15,32768
80009c72:	99 ff 1c 30 	ld.a %a15,[%a15]220 <800000dc <osEE_cdb_var>>
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_preempted = p_ccb->p_curr;
80009c76:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;
80009c78:	48 32       	ld.w %d2,[%a15]12

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
80009c7a:	99 42 0c 00 	ld.a %a2,[%a4]12 <800000dc <osEE_cdb_var>>
80009c7e:	0c 22       	ld.bu %d15,[%a2]2
80009c80:	5e 43       	jne %d15,4,80009c86 <osEE_scheduler_task_set_running+0x1a>
    p_preempted->p_tcb->status  = OSEE_TASK_READY_STACKED;
80009c82:	82 2f       	mov %d15,2
80009c84:	2c 22       	st.b [%a2]2,%d15
  }
  p_ccb->p_curr                 = p_tdb;
80009c86:	e8 05       	st.a [%a15]0,%a5

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
80009c88:	7c 68       	jnz.a %a6,80009c98 <osEE_scheduler_task_set_running+0x2c>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
80009c8a:	c8 22       	ld.a %a2,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
80009c8c:	4c 20       	ld.w %d15,[%a2]0
80009c8e:	68 2f       	st.w [%a15]8,%d15
  p_sn_allocated->p_next  = NULL;
80009c90:	82 0f       	mov %d15,0
80009c92:	6c 20       	st.w [%a2]0,%d15
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
80009c94:	e8 32       	st.a [%a15]12,%a2
80009c96:	3c 02       	j 80009c9a <osEE_scheduler_task_set_running+0x2e>
    osEE_unlock_core(p_cdb);
  } else {
    p_ccb->p_stk_sn             = p_sn;
80009c98:	e8 36       	st.a [%a15]12,%a6
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
80009c9a:	c8 32       	ld.a %a2,[%a15]12
80009c9c:	b5 25 04 00 	st.a [%a2]4,%a5
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
80009ca0:	c8 3f       	ld.a %a15,[%a15]12
80009ca2:	68 02       	st.w [%a15]0,%d2

  osEE_change_context_from_running(p_preempted, p_tdb);
80009ca4:	6d 00 03 00 	call 80009caa <osEE_change_context_from_running>
80009ca8:	00 90       	ret 

80009caa <osEE_change_context_from_running>:
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
80009caa:	40 ae       	mov.aa %a14,%sp
80009cac:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
80009cae:	99 52 0c 00 	ld.a %a2,[%a5]12
80009cb2:	0c 22       	ld.bu %d15,[%a2]2
80009cb4:	5e 28       	jne %d15,2,80009cc4 <osEE_change_context_from_running+0x1a>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
80009cb6:	40 54       	mov.aa %a4,%a5
80009cb8:	99 55 04 00 	ld.a %a5,[%a5]4
80009cbc:	c8 16       	ld.a %a6,[%a15]4
80009cbe:	6d 00 73 00 	call 80009da4 <osEE_hal_save_ctx_and_restore_ctx>
80009cc2:	00 90       	ret 
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
80009cc4:	40 54       	mov.aa %a4,%a5
80009cc6:	99 55 04 00 	ld.a %a5,[%a5]4
80009cca:	c8 16       	ld.a %a6,[%a15]4
80009ccc:	6d 00 8b 00 	call 80009de2 <osEE_hal_save_ctx_and_ready2stacked>
80009cd0:	00 90       	ret 

80009cd2 <osEE_change_context_from_task_end>:
  osEE_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
80009cd2:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
80009cd4:	cc 53       	ld.a %a15,[%a5]12
80009cd6:	0c f2       	ld.bu %d15,[%a15]2
80009cd8:	5e 27       	jne %d15,2,80009ce6 <osEE_change_context_from_task_end+0x14>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
80009cda:	40 54       	mov.aa %a4,%a5
80009cdc:	99 55 04 00 	ld.a %a5,[%a5]4
80009ce0:	6d 00 74 00 	call 80009dc8 <osEE_hal_restore_ctx>
80009ce4:	00 90       	ret 
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
80009ce6:	40 54       	mov.aa %a4,%a5
80009ce8:	99 55 04 00 	ld.a %a5,[%a5]4
80009cec:	6d 00 8d 00 	call 80009e06 <osEE_hal_ready2stacked>
80009cf0:	00 90       	ret 

80009cf2 <osEE_idle_task_terminate>:
FUNC(void, OS_CODE)
  osEE_idle_task_terminate
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_idle_tdb
)
{
80009cf2:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
80009cf4:	99 45 04 00 	ld.a %a5,[%a4]4
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
80009cf8:	cc 40       	ld.a %a15,[%a4]0
80009cfa:	48 03       	ld.w %d3,[%a15]0
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
80009cfc:	cc 50       	ld.a %a15,[%a5]0
80009cfe:	3c 02       	j 80009d02 <osEE_idle_task_terminate+0x10>

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
80009d00:	60 ff       	mov.a %a15,%d15
80009d02:	4c f0       	ld.w %d15,[%a15]0
  } while ((p_tos != NULL) && (p_tos != p_bos));
80009d04:	8b 0f 20 22 	ne %d2,%d15,0
80009d08:	0b 3f 10 22 	and.ne %d2,%d15,%d3
80009d0c:	df 02 fa ff 	jne %d2,0,80009d00 <osEE_idle_task_terminate+0xe>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
80009d10:	ec 50       	st.a [%a5]0,%a15

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
80009d12:	6d 00 5b 00 	call 80009dc8 <osEE_hal_restore_ctx>
80009d16:	00 90       	ret 

80009d18 <osEE_cpu_startos>:
}
#endif /* OSEE_SINGLECORE */
#endif /* OSEE_TC_HAS_ISR1_TO_CONF */

OsEE_bool osEE_cpu_startos(void)
{
80009d18:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80009d1a:	4d c0 e1 5f 	mfcr %d5,$core_id
#if (!defined(OSEE_SINGLECORE))
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
80009d1e:	91 00 00 f8 	movh.a %a15,32768
80009d22:	d9 ff 08 30 	lea %a15,[%a15]200 <800000c8 <osEE_kdb_var>>
80009d26:	c8 2f       	ld.a %a15,[%a15]8
80009d28:	b0 ff       	add.a %a15,-1
  for (i = 0U; i < tdb_size; ++i) {
80009d2a:	bd 0f 2a 00 	jz.a %a15,80009d7e <osEE_cpu_startos+0x66>
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
80009d2e:	91 00 00 28 	movh.a %a2,32768
80009d32:	d9 22 08 30 	lea %a2,[%a2]200 <800000c8 <osEE_kdb_var>>
80009d36:	19 23 04 00 	ld.w %d3,[%a2]4 <80000004 <BootModeHeader0+0x4>>
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80009d3a:	8f 35 00 51 	and %d5,%d5,3
80009d3e:	8f b5 00 50 	sh %d5,%d5,11
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
80009d42:	bb f0 ff 4f 	mov.u %d4,65535
80009d46:	82 0f       	mov %d15,0
80009d48:	b0 ff       	add.a %a15,-1
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
80009d4a:	60 33       	mov.a %a3,%d3
80009d4c:	90 32       	addsc.a %a2,%a3,%d15,2
80009d4e:	d4 22       	ld.a %a2,[%a2]
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
80009d50:	39 22 14 00 	ld.bu %d2,[%a2]20
80009d54:	df 22 12 80 	jne %d2,2,80009d78 <osEE_cpu_startos+0x60>
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
80009d58:	b9 22 08 00 	ld.hu %d2,[%a2]8
80009d5c:	5f 42 0e 00 	jeq %d2,%d4,80009d78 <osEE_cpu_startos+0x60>
80009d60:	60 24       	mov.a %a4,%d2
80009d62:	d9 43 00 08 	lea %a3,[%a4]-32768
80009d66:	11 43 00 3f 	addih.a %a3,%a3,61444
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
80009d6a:	39 22 1c 00 	ld.bu %d2,[%a2]28
80009d6e:	c2 12       	add %d2,1
80009d70:	b7 82 99 23 	insert %d2,%d2,8,7,25
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
80009d74:	a6 52       	or %d2,%d5
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80009d76:	74 32       	st.w [%a3],%d2
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
80009d78:	c2 1f       	add %d15,1
80009d7a:	fd f0 e8 7f 	loop %a15,80009d4a <osEE_cpu_startos+0x32>
    }
  }
#endif /* OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */

  return osEE_std_cpu_startos();
}
80009d7e:	82 12       	mov %d2,1
80009d80:	00 90       	ret 

80009d82 <osEE_tc_change_context_from_task_end>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
80009d82:	99 42 0c 00 	ld.a %a2,[%a4]12
static FUNC(void, OS_CODE) OSEE_NEVER_INLINE
  osEE_tc_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
80009d86:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
80009d88:	0c 22       	ld.bu %d15,[%a2]2
80009d8a:	1e 27       	jeq %d15,2,80009d98 <osEE_tc_change_context_from_task_end+0x16>
    osEE_tc_setareg(a4, p_to);
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
    osEE_tc_jump(osEE_hal_restore_ctx);
  } else {
    osEE_tc_setareg(a4, p_to);
80009d8c:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
80009d8e:	c8 1f       	ld.a %a15,[%a15]4
80009d90:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_ready2stacked);
80009d92:	1d 00 3a 00 	j 80009e06 <osEE_hal_ready2stacked>
80009d96:	00 90       	ret 
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_tc_setareg(a4, p_to);
80009d98:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
80009d9a:	c8 1f       	ld.a %a15,[%a15]4
80009d9c:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_restore_ctx);
80009d9e:	1d 00 15 00 	j 80009dc8 <osEE_hal_restore_ctx>
80009da2:	00 90       	ret 

80009da4 <osEE_hal_save_ctx_and_restore_ctx>:
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
80009da4:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
80009da6:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
80009daa:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
80009dac:	4c 60       	ld.w %d15,[%a6]0
80009dae:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80009db2:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
80009db6:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
80009dba:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
80009dbc:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
80009dc0:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the restore CTX */
  osEE_tc_jump(osEE_hal_restore_ctx);
80009dc2:	1d 00 03 00 	j 80009dc8 <osEE_hal_restore_ctx>
80009dc6:	00 90       	ret 

80009dc8 <osEE_hal_restore_ctx>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to_tdb,
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_to_scb
)
{
  OsEE_CTX  const * const p_ctx = p_to_scb->p_tos;
80009dc8:	cc 50       	ld.a %a15,[%a5]0
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
80009dca:	c8 32       	ld.a %a2,[%a15]12
  OsEE_pcxi const         pcxi  = p_ctx->pcxi;
80009dcc:	4c f2       	ld.w %d15,[%a15]8
80009dce:	40 2b       	mov.aa %a11,%a2

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
80009dd0:	cd 0f e0 0f 	mtcr $pcxi,%d15
80009dd4:	0d 00 c0 04 	isync 
/* Set the return address back */
  osEE_tc_set_RA(p_ctx->ra);
/* Set the PCXI back */
  osEE_tc_csa_set_pcxi(pcxi);
/* Restore the previous Top of Stack */
  p_to_scb->p_tos = p_ctx->p_ctx;
80009dd8:	4c f0       	ld.w %d15,[%a15]0
80009dda:	6c 50       	st.w [%a5]0,%d15
/* Jump to Kernel Wrapper: it will be the "ret" inside
   osEE_scheduler_task_wrapper_restore at:
   1) Restore the CSA so the SP,
   2) Return at RA address, that is the address after change context calling
      site */
  osEE_tc_jump(osEE_scheduler_task_wrapper_restore);
80009ddc:	1d ff 69 fd 	j 800098ae <osEE_scheduler_task_wrapper_restore>
80009de0:	00 90       	ret 

80009de2 <osEE_hal_save_ctx_and_ready2stacked>:
80009de2:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
80009de4:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
80009de8:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
80009dea:	4c 60       	ld.w %d15,[%a6]0
80009dec:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80009df0:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
80009df4:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
80009df8:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
80009dfa:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
80009dfe:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the ready to stacked */
  osEE_tc_jump(osEE_hal_ready2stacked);
80009e00:	1d 00 03 00 	j 80009e06 <osEE_hal_ready2stacked>
80009e04:	00 90       	ret 

80009e06 <osEE_hal_ready2stacked>:
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
80009e06:	cc 50       	ld.a %a15,[%a5]0
80009e08:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("isync" : : : "memory");
}

/** The svlcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_svlcx(void) {
  __asm__ volatile ("svlcx" : : : "memory");
80009e0a:	0d 00 00 02 	svlcx 
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
80009e0e:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
80009e10:	d9 f2 f0 ff 	lea %a2,[%a15]-16
80009e14:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
80009e16:	4c 50       	ld.w %d15,[%a5]0
80009e18:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80009e1c:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
80009e20:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
80009e24:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
80009e26:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
80009e2a:	f4 52       	st.a [%a5],%a2
   N.B. The RA saved in this context is not useful, but I prefer to use one
        save ctx code for all the cases for code readability, instead using an
        optimized one for this case */
  osEE_tc_save_ctx(p_to_scb);
/* Jump to Kernel Wrapper */
  osEE_tc_jump(osEE_scheduler_task_wrapper_run);
80009e2c:	1d ff 46 fd 	j 800098b8 <osEE_scheduler_task_wrapper_run>
80009e30:	00 90       	ret 

80009e32 <osEE_tc_change_context_from_isr2_end>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
/* Reset PSW Call Depth Counter, so I can force a RFE */
  osEE_tc_set_csfr(OSEE_CSFR_PSW,
80009e32:	4d 40 e0 ff 	mfcr %d15,$psw
80009e36:	8f ff c7 f1 	andn %d15,%d15,127
80009e3a:	cd 4f e0 0f 	mtcr $psw,%d15
80009e3e:	0d 00 c0 04 	isync 
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
80009e42:	91 10 00 f8 	movh.a %a15,32769
80009e46:	d9 ff c2 69 	lea %a15,[%a15]-25214 <80009d82 <osEE_tc_change_context_from_task_end>>
80009e4a:	40 fb       	mov.aa %a11,%a15
  __asm__ volatile ("rslcx" : : : "memory");
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
80009e4c:	00 80       	rfe 
80009e4e:	00 90       	ret 

80009e50 <osEE_hal_terminate_ctx>:
  osEE_hal_terminate_ctx
(
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_term_scb,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
80009e50:	20 08       	sub.a %sp,8

/* Returns the first CSA in the Free Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_fcx(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_FCX);
80009e52:	4d 80 e3 2f 	mfcr %d2,$fcx

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80009e56:	4d 00 e0 ff 	mfcr %d15,$pcxi
    OsEE_csa_link fcx                 = osEE_tc_csa_get_fcx();
/* Obtain Previous CSA list head, That is the head of the to_free_queue
   (will be new FCX) */
    OsEE_csa_link to_free_queue_head  = osEE_tc_csa_get_pcxi();
/* Get the the of the CSA list to be freed */
    OsEE_csa_link to_free_queue_tail  = p_term_scb->p_tos->pcxi;
80009e5a:	cc 40       	ld.a %a15,[%a4]0
80009e5c:	48 23       	ld.w %d3,[%a15]8
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
80009e5e:	b9 f4 08 00 	ld.hu %d4,[%a15]8
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
80009e62:	37 03 64 38 	extr.u %d3,%d3,16,4
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
80009e66:	06 64       	sh %d4,6
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
80009e68:	8f c3 01 30 	sh %d3,%d3,28
80009e6c:	a6 43       	or %d3,%d4
80009e6e:	60 3f       	mov.a %a15,%d3
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    l_next = p_csa->l_next;
  } else {
    l_next.reg = 0U;
80009e70:	82 03       	mov %d3,0
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE
  osEE_tc_csa_get_next(OsEE_csa_link l_csa_at)
{
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
80009e72:	bc f3       	jz.a %a15,80009e78 <osEE_hal_terminate_ctx+0x28>
    l_next = p_csa->l_next;
80009e74:	48 03       	ld.w %d3,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_next(OsEE_csa_link l_csa_at, OsEE_csa_link l_next)
{
  OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    p_csa->l_next = l_next;
80009e76:	68 02       	st.w [%a15]0,%d2

/* Set the first CSA in the Free Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_fcx(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_FCX, l_csa.reg);
80009e78:	cd 8f e3 0f 	mtcr $fcx,%d15
80009e7c:	0d 00 c0 04 	isync 

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
80009e80:	cd 03 e0 0f 	mtcr $pcxi,%d3
80009e84:	0d 00 c0 04 	isync 
   since a TASK, not yet started with higher priority of the stacked ones,
   could have been activated. */
   osEE_tc_set_RA(p_term_scb->p_tos->ra);
#endif /* 0 */
/* Pop ERIKA's context */
   p_term_scb->p_tos = p_term_scb->p_tos->p_ctx;
80009e88:	cc 40       	ld.a %a15,[%a4]0
80009e8a:	4c f0       	ld.w %d15,[%a15]0
80009e8c:	6c 40       	st.w [%a4]0,%d15
   "osEE_hal_ready2stacked" PCXI. */
  {
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_from;

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);
80009e8e:	91 00 00 48 	movh.a %a4,32768
80009e92:	d9 44 08 30 	lea %a4,[%a4]200 <800000c8 <osEE_kdb_var>>
80009e96:	d9 a5 04 00 	lea %a5,[%sp]4 <800000c8 <osEE_kdb_var>>
80009e9a:	6d ff 91 fe 	call 80009bbc <osEE_scheduler_task_terminated>

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
80009e9e:	d8 01       	ld.a %a15,[%sp]4
80009ea0:	39 ff 14 00 	ld.bu %d15,[%a15]20
80009ea4:	1e 25       	jeq %d15,2,80009eae <osEE_hal_terminate_ctx+0x5e>
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
    } else {
/* Prepare to jump to osEE_tc_change_context_from_task_end */
      osEE_tc_setareg(a4, p_to);
80009ea6:	40 24       	mov.aa %a4,%a2
      osEE_tc_jump(osEE_tc_change_context_from_task_end);
80009ea8:	1d ff 6d ff 	j 80009d82 <osEE_tc_change_context_from_task_end>
    }
  }
/* Fake infinite loop: to turn off 'noreturn' function does return warning */
  for(;;) {
    ;
  }
80009eac:	3c 00       	j 80009eac <osEE_hal_terminate_ctx+0x5c>

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
80009eae:	40 24       	mov.aa %a4,%a2
80009eb0:	6d ff c1 ff 	call 80009e32 <osEE_tc_change_context_from_isr2_end>
80009eb4:	3c fc       	j 80009eac <osEE_hal_terminate_ctx+0x5c>

80009eb6 <__lshrdi3>:
80009eb6:	6f 56 0c 80 	jnz.t %d6,5,80009ece <__lshrdi3+0x18>
80009eba:	8b 06 02 71 	rsub %d7,%d6,32
80009ebe:	32 56       	rsub %d6
80009ec0:	17 45 80 27 	dextr %d2,%d5,%d4,%d7
80009ec4:	0f 65 00 30 	sh %d3,%d5,%d6
80009ec8:	2b 42 40 26 	sel %d2,%d6,%d2,%d4
80009ecc:	00 90       	ret 
80009ece:	8b 06 02 60 	add %d6,%d6,32
80009ed2:	32 56       	rsub %d6
80009ed4:	0f 65 00 20 	sh %d2,%d5,%d6
80009ed8:	82 03       	mov %d3,0
80009eda:	00 90       	ret 

80009edc <__floatundisf>:
80009edc:	7b 00 02 20 	movh %d2,32
80009ee0:	0b 25 30 f1 	lt.u %d15,%d5,%d2
80009ee4:	02 4a       	mov %d10,%d4
80009ee6:	02 54       	mov %d4,%d5
80009ee8:	ee 08       	jnz %d15,80009ef8 <__floatundisf+0x1c>
80009eea:	b7 0a 95 f5 	insert %d15,%d10,0,11,21
80009eee:	6e 05       	jz %d15,80009ef8 <__floatundisf+0x1c>
80009ef0:	b7 0a 0b a0 	insert %d10,%d10,0,0,11
80009ef4:	b7 fa 81 a5 	insert %d10,%d10,15,11,1
80009ef8:	6d 00 ea 02 	call 8000a4cc <__floatunsidf>
80009efc:	0b 23 10 48 	mov %e4,%d3,%d2
80009f00:	82 06       	mov %d6,0
80009f02:	7b 00 1f 74 	movh %d7,16880
80009f06:	6d 00 34 01 	call 8000a16e <__muldf3>
80009f0a:	02 a4       	mov %d4,%d10
80009f0c:	0b 23 10 88 	mov %e8,%d3,%d2
80009f10:	6d 00 de 02 	call 8000a4cc <__floatunsidf>
80009f14:	0b 89 10 48 	mov %e4,%d9,%d8
80009f18:	0b 23 10 68 	mov %e6,%d3,%d2
80009f1c:	6d 00 ed 00 	call 8000a0f6 <__adddf3>
80009f20:	0b 23 10 48 	mov %e4,%d3,%d2
80009f24:	1d 00 b6 02 	j 8000a490 <__truncdfsf2>

80009f28 <__extendsfdf2>:
80009f28:	20 20       	sub.a %sp,32
80009f2a:	d9 a4 20 00 	lea %a4,[%sp]32
80009f2e:	89 44 2c f5 	st.w [+%a4]-20,%d4
80009f32:	d9 a5 10 00 	lea %a5,[%sp]16
80009f36:	6d 00 f1 02 	call 8000a518 <__unpack_f>
80009f3a:	19 a2 1c 00 	ld.w %d2,[%sp]28
80009f3e:	39 a4 10 00 	ld.bu %d4,[%sp]16
80009f42:	8f e2 1f f0 	sh %d15,%d2,-2
80009f46:	8f e2 01 20 	sh %d2,%d2,30
80009f4a:	74 a2       	st.w [%sp],%d2
80009f4c:	78 01       	st.w [%sp]4,%d15
80009f4e:	19 a5 14 00 	ld.w %d5,[%sp]20
80009f52:	19 a6 18 00 	ld.w %d6,[%sp]24
80009f56:	1d 00 8e 02 	j 8000a472 <__make_dp>

80009f5a <_fpadd_parts>:
80009f5a:	0c 40       	ld.bu %d15,[%a4]0
80009f5c:	40 42       	mov.aa %a2,%a4
80009f5e:	bf 2f cb 80 	jlt.u %d15,2,8000a0f4 <_fpadd_parts+0x19a>
80009f62:	14 52       	ld.bu %d2,[%a5]
80009f64:	40 52       	mov.aa %a2,%a5
80009f66:	bf 22 c7 80 	jlt.u %d2,2,8000a0f4 <_fpadd_parts+0x19a>
80009f6a:	5e 4e       	jne %d15,4,80009f86 <_fpadd_parts+0x2c>
80009f6c:	40 42       	mov.aa %a2,%a4
80009f6e:	df 42 c3 80 	jne %d2,4,8000a0f4 <_fpadd_parts+0x19a>
80009f72:	19 42 04 00 	ld.w %d2,[%a4]4
80009f76:	4c 51       	ld.w %d15,[%a5]4
80009f78:	5f f2 be 00 	jeq %d2,%d15,8000a0f4 <_fpadd_parts+0x19a>
80009f7c:	91 00 00 f8 	movh.a %a15,32768
80009f80:	d9 f2 e4 60 	lea %a2,[%a15]3492 <80000da4 <__thenan_df>>
80009f84:	00 90       	ret 
80009f86:	40 52       	mov.aa %a2,%a5
80009f88:	df 42 b6 00 	jeq %d2,4,8000a0f4 <_fpadd_parts+0x19a>
80009f8c:	df 22 11 80 	jne %d2,2,80009fae <_fpadd_parts+0x54>
80009f90:	40 42       	mov.aa %a2,%a4
80009f92:	df 2f b1 80 	jne %d15,2,8000a0f4 <_fpadd_parts+0x19a>
80009f96:	40 63       	mov.aa %a3,%a6
80009f98:	a0 4f       	mov.a %a15,4
80009f9a:	44 4f       	ld.w %d15,[%a4+]
80009f9c:	64 3f       	st.w [%a3+],%d15
80009f9e:	fc fe       	loop %a15,80009f9a <_fpadd_parts+0x40>
80009fa0:	4c 21       	ld.w %d15,[%a2]4
80009fa2:	19 52 04 00 	ld.w %d2,[%a5]4
80009fa6:	40 62       	mov.aa %a2,%a6
80009fa8:	26 2f       	and %d15,%d2
80009faa:	6c 61       	st.w [%a6]4,%d15
80009fac:	00 90       	ret 
80009fae:	40 52       	mov.aa %a2,%a5
80009fb0:	df 2f a2 00 	jeq %d15,2,8000a0f4 <_fpadd_parts+0x19a>
80009fb4:	4c 42       	ld.w %d15,[%a4]8
80009fb6:	19 52 08 00 	ld.w %d2,[%a5]8
80009fba:	40 6f       	mov.aa %a15,%a6
80009fbc:	52 23       	sub %d3,%d15,%d2
80009fbe:	0b 30 c0 c1 	abs %d12,%d3
80009fc2:	8b 0c 84 42 	ge %d4,%d12,64
80009fc6:	40 5c       	mov.aa %a12,%a5
80009fc8:	40 4d       	mov.aa %a13,%a4
80009fca:	09 4a 4c 09 	ld.d %e10,[%a4]12
80009fce:	09 58 4c 09 	ld.d %e8,[%a5]12
80009fd2:	df 04 35 80 	jne %d4,0,8000a03c <_fpadd_parts+0xe2>
80009fd6:	bf 13 19 00 	jlt %d3,1,8000a008 <_fpadd_parts+0xae>
80009fda:	0b 89 10 48 	mov %e4,%d9,%d8
80009fde:	02 c6       	mov %d6,%d12
80009fe0:	6d ff 6b ff 	call 80009eb6 <__lshrdi3>
80009fe4:	d2 14       	mov %e4,1
80009fe6:	02 c6       	mov %d6,%d12
80009fe8:	02 2e       	mov %d14,%d2
80009fea:	02 3d       	mov %d13,%d3
80009fec:	6d 00 89 02 	call 8000a4fe <__ashldi3>
80009ff0:	8b f2 9f 20 	addx %d2,%d2,-1
80009ff4:	8b f3 bf 30 	addc %d3,%d3,-1
80009ff8:	26 82       	and %d2,%d8
80009ffa:	26 93       	and %d3,%d9
80009ffc:	a6 23       	or %d3,%d2
80009ffe:	02 e8       	mov %d8,%d14
8000a000:	8b 03 00 85 	or.ne %d8,%d3,0
8000a004:	02 d9       	mov %d9,%d13
8000a006:	3c 21       	j 8000a048 <_fpadd_parts+0xee>
8000a008:	df 03 20 00 	jeq %d3,0,8000a048 <_fpadd_parts+0xee>
8000a00c:	0b ab 10 48 	mov %e4,%d11,%d10
8000a010:	02 c6       	mov %d6,%d12
8000a012:	6d ff 52 ff 	call 80009eb6 <__lshrdi3>
8000a016:	d2 14       	mov %e4,1
8000a018:	02 c6       	mov %d6,%d12
8000a01a:	02 2e       	mov %d14,%d2
8000a01c:	02 3d       	mov %d13,%d3
8000a01e:	6d 00 70 02 	call 8000a4fe <__ashldi3>
8000a022:	8b f2 9f 20 	addx %d2,%d2,-1
8000a026:	8b f3 bf 30 	addc %d3,%d3,-1
8000a02a:	26 a2       	and %d2,%d10
8000a02c:	26 b3       	and %d3,%d11
8000a02e:	a6 23       	or %d3,%d2
8000a030:	02 ea       	mov %d10,%d14
8000a032:	42 cf       	add %d15,%d12
8000a034:	8b 03 00 a5 	or.ne %d10,%d3,0
8000a038:	02 db       	mov %d11,%d13
8000a03a:	3c 07       	j 8000a048 <_fpadd_parts+0xee>
8000a03c:	3f f2 05 00 	jlt %d2,%d15,8000a046 <_fpadd_parts+0xec>
8000a040:	02 2f       	mov %d15,%d2
8000a042:	d2 0a       	mov %e10,0
8000a044:	3c 02       	j 8000a048 <_fpadd_parts+0xee>
8000a046:	d2 08       	mov %e8,0
8000a048:	19 d4 04 00 	ld.w %d4,[%a13]4
8000a04c:	19 c2 04 00 	ld.w %d2,[%a12]4
8000a050:	5f 24 34 00 	jeq %d4,%d2,8000a0b8 <_fpadd_parts+0x15e>
8000a054:	0b 8a c0 20 	subx %d2,%d10,%d8
8000a058:	0b 9b d0 30 	subc %d3,%d11,%d9
8000a05c:	76 45       	jz %d4,8000a066 <_fpadd_parts+0x10c>
8000a05e:	0b a8 c0 20 	subx %d2,%d8,%d10
8000a062:	0b b9 d0 30 	subc %d3,%d9,%d11
8000a066:	0e 37       	jltz %d3,8000a074 <_fpadd_parts+0x11a>
8000a068:	82 04       	mov %d4,0
8000a06a:	68 14       	st.w [%a15]4,%d4
8000a06c:	68 2f       	st.w [%a15]8,%d15
8000a06e:	89 f2 4c 09 	st.d [%a15]12,%e2
8000a072:	3c 0c       	j 8000a08a <_fpadd_parts+0x130>
8000a074:	68 2f       	st.w [%a15]8,%d15
8000a076:	8b 03 00 f1 	rsub %d15,%d3,0
8000a07a:	82 14       	mov %d4,1
8000a07c:	8b 02 00 31 	rsub %d3,%d2,0
8000a080:	ab ff 1f f2 	cadd %d15,%d2,%d15,-1
8000a084:	68 14       	st.w [%a15]4,%d4
8000a086:	68 33       	st.w [%a15]12,%d3
8000a088:	68 4f       	st.w [%a15]16,%d15
8000a08a:	82 f5       	mov %d5,-1
8000a08c:	06 c5       	sh %d5,-4
8000a08e:	48 32       	ld.w %d2,[%a15]12
8000a090:	48 43       	ld.w %d3,[%a15]16
8000a092:	8b f2 9f 60 	addx %d6,%d2,-1
8000a096:	8b f3 bf 40 	addc %d4,%d3,-1
8000a09a:	3a 54       	eq %d15,%d4,%d5
8000a09c:	8b f6 3f f4 	and.ne %d15,%d6,-1
8000a0a0:	0b 54 a0 f2 	or.lt.u %d15,%d4,%d5
8000a0a4:	6e 12       	jz %d15,8000a0c8 <_fpadd_parts+0x16e>
8000a0a6:	4c f2       	ld.w %d15,[%a15]8
8000a0a8:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000a0ac:	c2 ff       	add %d15,-1
8000a0ae:	06 12       	sh %d2,1
8000a0b0:	68 32       	st.w [%a15]12,%d2
8000a0b2:	68 43       	st.w [%a15]16,%d3
8000a0b4:	68 2f       	st.w [%a15]8,%d15
8000a0b6:	3c ec       	j 8000a08e <_fpadd_parts+0x134>
8000a0b8:	0b a8 40 20 	addx %d2,%d8,%d10
8000a0bc:	68 2f       	st.w [%a15]8,%d15
8000a0be:	0b b9 50 f0 	addc %d15,%d9,%d11
8000a0c2:	68 14       	st.w [%a15]4,%d4
8000a0c4:	68 32       	st.w [%a15]12,%d2
8000a0c6:	68 4f       	st.w [%a15]16,%d15
8000a0c8:	82 3f       	mov %d15,3
8000a0ca:	28 0f       	st.b [%a15]0,%d15
8000a0cc:	4c f4       	ld.w %d15,[%a15]16
8000a0ce:	7b 00 00 42 	movh %d4,8192
8000a0d2:	0b 4f 30 31 	lt.u %d3,%d15,%d4
8000a0d6:	48 32       	ld.w %d2,[%a15]12
8000a0d8:	40 f2       	mov.aa %a2,%a15
8000a0da:	f6 3d       	jnz %d3,8000a0f4 <_fpadd_parts+0x19a>
8000a0dc:	8f 12 00 31 	and %d3,%d2,1
8000a0e0:	77 2f 80 2f 	dextr %d2,%d15,%d2,31
8000a0e4:	06 ff       	sh %d15,-1
8000a0e6:	96 00       	or %d15,0
8000a0e8:	68 4f       	st.w [%a15]16,%d15
8000a0ea:	4c f2       	ld.w %d15,[%a15]8
8000a0ec:	a6 32       	or %d2,%d3
8000a0ee:	c2 1f       	add %d15,1
8000a0f0:	68 32       	st.w [%a15]12,%d2
8000a0f2:	68 2f       	st.w [%a15]8,%d15
8000a0f4:	00 90       	ret 

8000a0f6 <__adddf3>:
8000a0f6:	20 50       	sub.a %sp,80
8000a0f8:	d9 a4 04 00 	lea %a4,[%sp]4
8000a0fc:	d9 a5 14 00 	lea %a5,[%sp]20
8000a100:	89 a4 44 09 	st.d [%sp]4,%e4
8000a104:	89 a6 4c 09 	st.d [%sp]12,%e6
8000a108:	6d 00 d9 02 	call 8000a6ba <__unpack_d>
8000a10c:	d9 a4 0c 00 	lea %a4,[%sp]12
8000a110:	d9 a5 28 00 	lea %a5,[%sp]40
8000a114:	6d 00 d3 02 	call 8000a6ba <__unpack_d>
8000a118:	d9 a4 14 00 	lea %a4,[%sp]20
8000a11c:	d9 a5 28 00 	lea %a5,[%sp]40
8000a120:	d9 a6 3c 00 	lea %a6,[%sp]60
8000a124:	6d ff 1b ff 	call 80009f5a <_fpadd_parts>
8000a128:	40 24       	mov.aa %a4,%a2
8000a12a:	1d 00 3f 02 	j 8000a5a8 <__pack_d>

8000a12e <__subdf3>:
8000a12e:	20 50       	sub.a %sp,80
8000a130:	d9 a4 04 00 	lea %a4,[%sp]4
8000a134:	d9 a5 14 00 	lea %a5,[%sp]20
8000a138:	89 a4 44 09 	st.d [%sp]4,%e4
8000a13c:	89 a6 4c 09 	st.d [%sp]12,%e6
8000a140:	6d 00 bd 02 	call 8000a6ba <__unpack_d>
8000a144:	d9 a4 0c 00 	lea %a4,[%sp]12
8000a148:	d9 a5 28 00 	lea %a5,[%sp]40
8000a14c:	6d 00 b7 02 	call 8000a6ba <__unpack_d>
8000a150:	58 0b       	ld.w %d15,[%sp]44
8000a152:	d9 a4 14 00 	lea %a4,[%sp]20
8000a156:	8f 1f 80 f1 	xor %d15,%d15,1
8000a15a:	d9 a5 28 00 	lea %a5,[%sp]40
8000a15e:	d9 a6 3c 00 	lea %a6,[%sp]60
8000a162:	78 0b       	st.w [%sp]44,%d15
8000a164:	6d ff fb fe 	call 80009f5a <_fpadd_parts>
8000a168:	40 24       	mov.aa %a4,%a2
8000a16a:	1d 00 1f 02 	j 8000a5a8 <__pack_d>

8000a16e <__muldf3>:
8000a16e:	20 50       	sub.a %sp,80
8000a170:	d9 a4 04 00 	lea %a4,[%sp]4
8000a174:	d9 a5 14 00 	lea %a5,[%sp]20
8000a178:	89 a4 44 09 	st.d [%sp]4,%e4
8000a17c:	89 a6 4c 09 	st.d [%sp]12,%e6
8000a180:	6d 00 9d 02 	call 8000a6ba <__unpack_d>
8000a184:	d9 a4 0c 00 	lea %a4,[%sp]12
8000a188:	d9 a5 28 00 	lea %a5,[%sp]40
8000a18c:	6d 00 97 02 	call 8000a6ba <__unpack_d>
8000a190:	39 a3 14 00 	ld.bu %d3,[%sp]20
8000a194:	ff 23 0c 80 	jge.u %d3,2,8000a1ac <__muldf3+0x3e>
8000a198:	19 a2 18 00 	ld.w %d2,[%sp]24
8000a19c:	58 0b       	ld.w %d15,[%sp]44
8000a19e:	d9 a4 14 00 	lea %a4,[%sp]20
8000a1a2:	0b f2 10 f1 	ne %d15,%d2,%d15
8000a1a6:	78 06       	st.w [%sp]24,%d15
8000a1a8:	1d 00 b3 00 	j 8000a30e <__muldf3+0x1a0>
8000a1ac:	39 af 28 00 	ld.bu %d15,[%sp]40
8000a1b0:	ff 2f 0c 80 	jge.u %d15,2,8000a1c8 <__muldf3+0x5a>
8000a1b4:	58 0b       	ld.w %d15,[%sp]44
8000a1b6:	19 a2 18 00 	ld.w %d2,[%sp]24
8000a1ba:	d9 a4 28 00 	lea %a4,[%sp]40
8000a1be:	0b f2 10 f1 	ne %d15,%d2,%d15
8000a1c2:	78 0b       	st.w [%sp]44,%d15
8000a1c4:	1d 00 a5 00 	j 8000a30e <__muldf3+0x1a0>
8000a1c8:	df 43 09 80 	jne %d3,4,8000a1da <__muldf3+0x6c>
8000a1cc:	91 00 00 48 	movh.a %a4,32768
8000a1d0:	d9 44 e4 60 	lea %a4,[%a4]3492 <80000da4 <__thenan_df>>
8000a1d4:	df 2f 9d 00 	jeq %d15,2,8000a30e <__muldf3+0x1a0>
8000a1d8:	3c e0       	j 8000a198 <__muldf3+0x2a>
8000a1da:	5e 48       	jne %d15,4,8000a1ea <__muldf3+0x7c>
8000a1dc:	91 00 00 48 	movh.a %a4,32768
8000a1e0:	d9 44 e4 60 	lea %a4,[%a4]3492 <80000da4 <__thenan_df>>
8000a1e4:	df 23 95 00 	jeq %d3,2,8000a30e <__muldf3+0x1a0>
8000a1e8:	3c e6       	j 8000a1b4 <__muldf3+0x46>
8000a1ea:	df 23 d7 7f 	jeq %d3,2,8000a198 <__muldf3+0x2a>
8000a1ee:	df 2f e3 7f 	jeq %d15,2,8000a1b4 <__muldf3+0x46>
8000a1f2:	58 08       	ld.w %d15,[%sp]32
8000a1f4:	19 ab 38 00 	ld.w %d11,[%sp]56 <80000008 <BootModeHeader0+0x8>>
8000a1f8:	d2 00       	mov %e0,0
8000a1fa:	19 a0 34 00 	ld.w %d0,[%sp]52
8000a1fe:	73 bf 68 60 	mul.u %e6,%d15,%d11
8000a202:	82 0c       	mov %d12,0
8000a204:	73 0f 68 40 	mul.u %e4,%d15,%d0
8000a208:	19 aa 24 00 	ld.w %d10,[%sp]36
8000a20c:	82 02       	mov %d2,0
8000a20e:	03 cf 0a 77 	madd %d7,%d7,%d15,%d12
8000a212:	03 b2 0a 77 	madd %d7,%d7,%d2,%d11
8000a216:	03 1f 0a 55 	madd %d5,%d5,%d15,%d1
8000a21a:	03 02 0a 55 	madd %d5,%d5,%d2,%d0
8000a21e:	82 0d       	mov %d13,0
8000a220:	03 a0 68 26 	madd.u %e2,%e6,%d0,%d10
8000a224:	03 d0 0a 33 	madd %d3,%d3,%d0,%d13
8000a228:	03 a1 0a 33 	madd %d3,%d3,%d1,%d10
8000a22c:	0b 54 10 08 	mov %e0,%d4,%d5
8000a230:	42 20       	add %d0,%d2
8000a232:	3a 73       	eq %d15,%d3,%d7
8000a234:	0b 62 50 f2 	and.ge.u %d15,%d2,%d6
8000a238:	0b 37 a0 f2 	or.lt.u %d15,%d7,%d3
8000a23c:	8b 0f 00 62 	eq %d6,%d15,0
8000a240:	3a 50       	eq %d15,%d0,%d5
8000a242:	0b 41 50 f2 	and.ge.u %d15,%d1,%d4
8000a246:	0b 05 a0 f2 	or.lt.u %d15,%d5,%d0
8000a24a:	ba 0f       	eq %d15,%d15,0
8000a24c:	53 1f 40 40 	mul.u %e4,%d15,1
8000a250:	02 38       	mov %d8,%d3
8000a252:	82 09       	mov %d9,0
8000a254:	03 ab 68 28 	madd.u %e2,%e8,%d11,%d10
8000a258:	02 5f       	mov %d15,%d5
8000a25a:	03 db 0a 33 	madd %d3,%d3,%d11,%d13
8000a25e:	42 6f       	add %d15,%d6
8000a260:	03 ac 0a 33 	madd %d3,%d3,%d12,%d10
8000a264:	0b 4f 10 68 	mov %e6,%d15,%d4
8000a268:	0b 62 40 40 	addx %d4,%d2,%d6
8000a26c:	0b 73 50 20 	addc %d2,%d3,%d7
8000a270:	58 07       	ld.w %d15,[%sp]28
8000a272:	19 a3 30 00 	ld.w %d3,[%sp]48
8000a276:	19 a5 18 00 	ld.w %d5,[%sp]24
8000a27a:	42 3f       	add %d15,%d3
8000a27c:	19 a3 2c 00 	ld.w %d3,[%sp]44
8000a280:	c2 4f       	add %d15,4
8000a282:	0b 35 10 31 	ne %d3,%d5,%d3
8000a286:	59 a3 00 10 	st.w [%sp]64,%d3
8000a28a:	7b 00 00 52 	movh %d5,8192
8000a28e:	0b 52 50 31 	ge.u %d3,%d2,%d5
8000a292:	df 03 1b 00 	jeq %d3,0,8000a2c8 <__muldf3+0x15a>
8000a296:	8f 14 00 31 	and %d3,%d4,1
8000a29a:	76 37       	jz %d3,8000a2a8 <__muldf3+0x13a>
8000a29c:	8f f0 1f 30 	sh %d3,%d0,-1
8000a2a0:	77 10 80 1f 	dextr %d1,%d0,%d1,31
8000a2a4:	b7 f3 81 0f 	insert %d0,%d3,15,31,1
8000a2a8:	77 42 80 4f 	dextr %d4,%d2,%d4,31
8000a2ac:	c2 1f       	add %d15,1
8000a2ae:	06 f2       	sh %d2,-1
8000a2b0:	3c ed       	j 8000a28a <__muldf3+0x11c>
8000a2b2:	77 42 80 20 	dextr %d2,%d2,%d4,1
8000a2b6:	06 14       	sh %d4,1
8000a2b8:	ce 04       	jgez %d0,8000a2c0 <__muldf3+0x152>
8000a2ba:	8f 14 40 51 	or %d5,%d4,1
8000a2be:	02 54       	mov %d4,%d5
8000a2c0:	77 10 80 00 	dextr %d0,%d0,%d1,1
8000a2c4:	c2 ff       	add %d15,-1
8000a2c6:	06 11       	sh %d1,1
8000a2c8:	7b 00 00 51 	movh %d5,4096
8000a2cc:	0b 52 30 31 	lt.u %d3,%d2,%d5
8000a2d0:	df 03 f1 ff 	jne %d3,0,8000a2b2 <__muldf3+0x144>
8000a2d4:	78 11       	st.w [%sp]68,%d15
8000a2d6:	02 4f       	mov %d15,%d4
8000a2d8:	16 ff       	and %d15,255
8000a2da:	8b 0f 28 f2 	ne %d15,%d15,128
8000a2de:	ee 0f       	jnz %d15,8000a2fc <__muldf3+0x18e>
8000a2e0:	a6 10       	or %d0,%d1
8000a2e2:	77 42 00 fc 	dextr %d15,%d2,%d4,24
8000a2e6:	8b 00 20 02 	ne %d0,%d0,0
8000a2ea:	0f f0 e0 00 	andn %d0,%d0,%d15
8000a2ee:	76 07       	jz %d0,8000a2fc <__muldf3+0x18e>
8000a2f0:	8b 04 88 40 	addx %d4,%d4,128
8000a2f4:	8b 02 a0 20 	addc %d2,%d2,0
8000a2f8:	8f f4 cf 41 	andn %d4,%d4,255
8000a2fc:	d9 a4 10 10 	lea %a4,[%sp]80
8000a300:	82 3f       	mov %d15,3
8000a302:	59 a4 08 10 	st.w [%sp]72,%d4
8000a306:	59 a2 0c 10 	st.w [%sp]76,%d2
8000a30a:	89 4f 2c f4 	st.b [+%a4]-20 <800003ec <IfxAsclin1_TX_P33_13_OUT>>,%d15
8000a30e:	1d 00 4d 01 	j 8000a5a8 <__pack_d>

8000a312 <__divdf3>:
8000a312:	20 38       	sub.a %sp,56
8000a314:	40 a4       	mov.aa %a4,%sp
8000a316:	d9 a5 10 00 	lea %a5,[%sp]16
8000a31a:	89 a4 40 09 	st.d [%sp],%e4
8000a31e:	89 a6 48 09 	st.d [%sp]8,%e6
8000a322:	6d 00 cc 01 	call 8000a6ba <__unpack_d>
8000a326:	d9 a4 08 00 	lea %a4,[%sp]8
8000a32a:	d9 a5 24 00 	lea %a5,[%sp]36
8000a32e:	6d 00 c6 01 	call 8000a6ba <__unpack_d>
8000a332:	39 a2 10 00 	ld.bu %d2,[%sp]16
8000a336:	bf 22 76 80 	jlt.u %d2,2,8000a422 <__divdf3+0x110>
8000a33a:	39 af 24 00 	ld.bu %d15,[%sp]36
8000a33e:	d9 a4 24 00 	lea %a4,[%sp]36
8000a342:	bf 2f 72 80 	jlt.u %d15,2,8000a426 <__divdf3+0x114>
8000a346:	19 a4 14 00 	ld.w %d4,[%sp]20
8000a34a:	19 a3 28 00 	ld.w %d3,[%sp]40
8000a34e:	c6 43       	xor %d3,%d4
8000a350:	59 a3 14 00 	st.w [%sp]20,%d3
8000a354:	1b e2 ff 3f 	addi %d3,%d2,-2
8000a358:	8f d3 0f 31 	and %d3,%d3,253
8000a35c:	f6 38       	jnz %d3,8000a36c <__divdf3+0x5a>
8000a35e:	91 00 00 48 	movh.a %a4,32768
8000a362:	d9 44 e4 60 	lea %a4,[%a4]3492 <80000da4 <__thenan_df>>
8000a366:	5f f2 5e 80 	jne %d2,%d15,8000a422 <__divdf3+0x110>
8000a36a:	3c 5e       	j 8000a426 <__divdf3+0x114>
8000a36c:	5e 47       	jne %d15,4,8000a37a <__divdf3+0x68>
8000a36e:	d2 02       	mov %e2,0
8000a370:	82 0f       	mov %d15,0
8000a372:	89 a2 5c 09 	st.d [%sp]28,%e2
8000a376:	78 06       	st.w [%sp]24,%d15
8000a378:	3c 55       	j 8000a422 <__divdf3+0x110>
8000a37a:	5e 25       	jne %d15,2,8000a384 <__divdf3+0x72>
8000a37c:	82 4f       	mov %d15,4
8000a37e:	e9 af 10 00 	st.b [%sp]16,%d15
8000a382:	3c 50       	j 8000a422 <__divdf3+0x110>
8000a384:	58 06       	ld.w %d15,[%sp]24
8000a386:	09 a2 5c 09 	ld.d %e2,[%sp]28
8000a38a:	09 a4 70 09 	ld.d %e4,[%sp]48
8000a38e:	19 a6 2c 00 	ld.w %d6,[%sp]44
8000a392:	52 66       	sub %d6,%d15,%d6
8000a394:	3a 53       	eq %d15,%d3,%d5
8000a396:	0b 42 50 f2 	and.ge.u %d15,%d2,%d4
8000a39a:	59 a6 18 00 	st.w [%sp]24,%d6
8000a39e:	0b 35 a0 f2 	or.lt.u %d15,%d5,%d3
8000a3a2:	ee 07       	jnz %d15,8000a3b0 <__divdf3+0x9e>
8000a3a4:	c2 f6       	add %d6,-1
8000a3a6:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000a3aa:	59 a6 18 00 	st.w [%sp]24,%d6
8000a3ae:	06 12       	sh %d2,1
8000a3b0:	82 01       	mov %d1,0
8000a3b2:	7b 00 00 f1 	movh %d15,4096
8000a3b6:	82 00       	mov %d0,0
8000a3b8:	82 07       	mov %d7,0
8000a3ba:	c5 0f 3c 00 	lea %a15,3c <_.+0x3b>
8000a3be:	0b 53 00 61 	eq %d6,%d3,%d5
8000a3c2:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
8000a3c6:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
8000a3ca:	f6 6b       	jnz %d6,8000a3e0 <__divdf3+0xce>
8000a3cc:	0f 10 a0 80 	or %d8,%d0,%d1
8000a3d0:	0f f7 a0 60 	or %d6,%d7,%d15
8000a3d4:	0b 42 c0 20 	subx %d2,%d2,%d4
8000a3d8:	02 80       	mov %d0,%d8
8000a3da:	02 67       	mov %d7,%d6
8000a3dc:	0b 53 d0 30 	subc %d3,%d3,%d5
8000a3e0:	77 1f 80 1f 	dextr %d1,%d15,%d1,31
8000a3e4:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000a3e8:	06 ff       	sh %d15,-1
8000a3ea:	06 12       	sh %d2,1
8000a3ec:	fd f0 e9 7f 	loop %a15,8000a3be <__divdf3+0xac>
8000a3f0:	02 0f       	mov %d15,%d0
8000a3f2:	16 ff       	and %d15,255
8000a3f4:	8b 0f 28 f2 	ne %d15,%d15,128
8000a3f8:	0b 70 10 48 	mov %e4,%d0,%d7
8000a3fc:	ee 0f       	jnz %d15,8000a41a <__divdf3+0x108>
8000a3fe:	a6 32       	or %d2,%d3
8000a400:	77 07 00 fc 	dextr %d15,%d7,%d0,24
8000a404:	8b 02 20 22 	ne %d2,%d2,0
8000a408:	0f f2 e0 20 	andn %d2,%d2,%d15
8000a40c:	76 27       	jz %d2,8000a41a <__divdf3+0x108>
8000a40e:	8b 00 88 00 	addx %d0,%d0,128
8000a412:	8b 07 a0 40 	addc %d4,%d7,0
8000a416:	8f f0 cf 51 	andn %d5,%d0,255
8000a41a:	59 a5 1c 00 	st.w [%sp]28,%d5
8000a41e:	59 a4 20 00 	st.w [%sp]32,%d4
8000a422:	d9 a4 10 00 	lea %a4,[%sp]16
8000a426:	1d 00 c1 00 	j 8000a5a8 <__pack_d>

8000a42a <__floatsidf>:
8000a42a:	20 18       	sub.a %sp,24
8000a42c:	82 3f       	mov %d15,3
8000a42e:	2c a4       	st.b [%sp]4,%d15
8000a430:	8f 14 1e f0 	sh %d15,%d4,-31
8000a434:	78 02       	st.w [%sp]8,%d15
8000a436:	f6 44       	jnz %d4,8000a43e <__floatsidf+0x14>
8000a438:	82 2f       	mov %d15,2
8000a43a:	2c a4       	st.b [%sp]4,%d15
8000a43c:	3c 16       	j 8000a468 <__floatsidf+0x3e>
8000a43e:	6e 09       	jz %d15,8000a450 <__floatsidf+0x26>
8000a440:	7b 00 00 f8 	movh %d15,32768
8000a444:	82 02       	mov %d2,0
8000a446:	7b 00 1e 3c 	movh %d3,49632
8000a44a:	5f f4 13 00 	jeq %d4,%d15,8000a470 <__floatsidf+0x46>
8000a44e:	32 54       	rsub %d4
8000a450:	0f 04 b0 f1 	clz %d15,%d4
8000a454:	1b df 01 60 	addi %d6,%d15,29
8000a458:	82 05       	mov %d5,0
8000a45a:	6d 00 52 00 	call 8000a4fe <__ashldi3>
8000a45e:	8b ff 01 f1 	rsub %d15,%d15,31
8000a462:	89 a2 50 09 	st.d [%sp]16,%e2
8000a466:	78 03       	st.w [%sp]12,%d15
8000a468:	d9 a4 04 00 	lea %a4,[%sp]4
8000a46c:	6d 00 9e 00 	call 8000a5a8 <__pack_d>
8000a470:	00 90       	ret 

8000a472 <__make_dp>:
8000a472:	20 18       	sub.a %sp,24
8000a474:	09 a2 58 09 	ld.d %e2,[%sp]24
8000a478:	d9 a4 04 00 	lea %a4,[%sp]4
8000a47c:	e9 a4 04 00 	st.b [%sp]4,%d4
8000a480:	59 a5 08 00 	st.w [%sp]8,%d5
8000a484:	59 a6 0c 00 	st.w [%sp]12,%d6
8000a488:	89 a2 50 09 	st.d [%sp]16,%e2
8000a48c:	1d 00 8e 00 	j 8000a5a8 <__pack_d>

8000a490 <__truncdfsf2>:
8000a490:	20 20       	sub.a %sp,32
8000a492:	d9 a4 20 00 	lea %a4,[%sp]32
8000a496:	89 44 64 f5 	st.d [+%a4]-28,%e4
8000a49a:	d9 a5 0c 00 	lea %a5,[%sp]12
8000a49e:	6d 00 0e 01 	call 8000a6ba <__unpack_d>
8000a4a2:	19 a7 18 00 	ld.w %d7,[%sp]24
8000a4a6:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000a4aa:	39 a4 0c 00 	ld.bu %d4,[%sp]12
8000a4ae:	77 72 00 21 	dextr %d2,%d2,%d7,2
8000a4b2:	b7 07 02 7f 	insert %d7,%d7,0,30,2
8000a4b6:	02 23       	mov %d3,%d2
8000a4b8:	8f 12 40 21 	or %d2,%d2,1
8000a4bc:	19 a5 10 00 	ld.w %d5,[%sp]16
8000a4c0:	19 a6 14 00 	ld.w %d6,[%sp]20
8000a4c4:	2b 32 40 77 	sel %d7,%d7,%d2,%d3
8000a4c8:	1d 00 65 00 	j 8000a592 <__make_fp>

8000a4cc <__floatunsidf>:
8000a4cc:	20 18       	sub.a %sp,24
8000a4ce:	82 0f       	mov %d15,0
8000a4d0:	78 02       	st.w [%sp]8,%d15
8000a4d2:	f6 44       	jnz %d4,8000a4da <__floatunsidf+0xe>
8000a4d4:	82 2f       	mov %d15,2
8000a4d6:	2c a4       	st.b [%sp]4,%d15
8000a4d8:	3c 0f       	j 8000a4f6 <__floatunsidf+0x2a>
8000a4da:	82 3f       	mov %d15,3
8000a4dc:	2c a4       	st.b [%sp]4,%d15
8000a4de:	0f 04 b0 f1 	clz %d15,%d4
8000a4e2:	1b df 01 60 	addi %d6,%d15,29
8000a4e6:	82 05       	mov %d5,0
8000a4e8:	6d 00 0b 00 	call 8000a4fe <__ashldi3>
8000a4ec:	8b ff 01 f1 	rsub %d15,%d15,31
8000a4f0:	89 a2 50 09 	st.d [%sp]16,%e2
8000a4f4:	78 03       	st.w [%sp]12,%d15
8000a4f6:	d9 a4 04 00 	lea %a4,[%sp]4
8000a4fa:	1d 00 57 00 	j 8000a5a8 <__pack_d>

8000a4fe <__ashldi3>:
8000a4fe:	6f 56 07 80 	jnz.t %d6,5,8000a50c <__ashldi3+0xe>
8000a502:	0f 64 00 20 	sh %d2,%d4,%d6
8000a506:	17 45 80 36 	dextr %d3,%d5,%d4,%d6
8000a50a:	00 90       	ret 
8000a50c:	8b 06 1e 60 	add %d6,%d6,-32
8000a510:	82 02       	mov %d2,0
8000a512:	0f 64 00 30 	sh %d3,%d4,%d6
8000a516:	00 90       	ret 

8000a518 <__unpack_f>:
8000a518:	54 43       	ld.w %d3,[%a4]
8000a51a:	37 03 77 f0 	extr.u %d15,%d3,0,23
8000a51e:	37 03 e8 2b 	extr.u %d2,%d3,23,8
8000a522:	8f 13 1e 30 	sh %d3,%d3,-31
8000a526:	59 53 04 00 	st.w [%a5]4,%d3
8000a52a:	df 02 18 80 	jne %d2,0,8000a55a <__unpack_f+0x42>
8000a52e:	ee 03       	jnz %d15,8000a534 <__unpack_f+0x1c>
8000a530:	82 2f       	mov %d15,2
8000a532:	3c 19       	j 8000a564 <__unpack_f+0x4c>
8000a534:	3b 20 f8 2f 	mov %d2,-126
8000a538:	59 52 08 00 	st.w [%a5]8,%d2
8000a53c:	82 32       	mov %d2,3
8000a53e:	34 52       	st.b [%a5],%d2
8000a540:	06 7f       	sh %d15,7
8000a542:	3b 10 f8 2f 	mov %d2,-127
8000a546:	7b 00 00 44 	movh %d4,16384
8000a54a:	06 1f       	sh %d15,1
8000a54c:	02 23       	mov %d3,%d2
8000a54e:	c2 f2       	add %d2,-1
8000a550:	3f 4f fd ff 	jlt.u %d15,%d4,8000a54a <__unpack_f+0x32>
8000a554:	59 53 08 00 	st.w [%a5]8,%d3
8000a558:	3c 1b       	j 8000a58e <__unpack_f+0x76>
8000a55a:	8b f2 2f 32 	ne %d3,%d2,255
8000a55e:	f6 3f       	jnz %d3,8000a57c <__unpack_f+0x64>
8000a560:	ee 04       	jnz %d15,8000a568 <__unpack_f+0x50>
8000a562:	82 4f       	mov %d15,4
8000a564:	2c 50       	st.b [%a5]0,%d15
8000a566:	00 90       	ret 
8000a568:	7b 00 04 20 	movh %d2,64
8000a56c:	26 f2       	and %d2,%d15
8000a56e:	76 22       	jz %d2,8000a572 <__unpack_f+0x5a>
8000a570:	82 12       	mov %d2,1
8000a572:	b7 0f 01 fb 	insert %d15,%d15,0,22,1
8000a576:	34 52       	st.b [%a5],%d2
8000a578:	06 7f       	sh %d15,7
8000a57a:	3c 0a       	j 8000a58e <__unpack_f+0x76>
8000a57c:	1b 12 f8 2f 	addi %d2,%d2,-127
8000a580:	06 7f       	sh %d15,7
8000a582:	59 52 08 00 	st.w [%a5]8,%d2
8000a586:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000a58a:	82 32       	mov %d2,3
8000a58c:	34 52       	st.b [%a5],%d2
8000a58e:	6c 53       	st.w [%a5]12,%d15
8000a590:	00 90       	ret 

8000a592 <__make_fp>:
8000a592:	20 10       	sub.a %sp,16
8000a594:	40 a4       	mov.aa %a4,%sp
8000a596:	34 a4       	st.b [%sp],%d4
8000a598:	59 a5 04 00 	st.w [%sp]4,%d5
8000a59c:	59 a6 08 00 	st.w [%sp]8,%d6
8000a5a0:	59 a7 0c 00 	st.w [%sp]12,%d7
8000a5a4:	1d 00 e1 00 	j 8000a766 <__pack_f>

8000a5a8 <__pack_d>:
8000a5a8:	14 42       	ld.bu %d2,[%a4]
8000a5aa:	19 49 0c 00 	ld.w %d9,[%a4]12
8000a5ae:	19 48 10 00 	ld.w %d8,[%a4]16
8000a5b2:	19 4c 04 00 	ld.w %d12,[%a4]4
8000a5b6:	ff 22 0b 80 	jge.u %d2,2,8000a5cc <__pack_d+0x24>
8000a5ba:	77 98 00 9c 	dextr %d9,%d8,%d9,24
8000a5be:	06 88       	sh %d8,-8
8000a5c0:	02 95       	mov %d5,%d9
8000a5c2:	b7 18 8d 49 	insert %d4,%d8,1,19,13
8000a5c6:	3b f0 7f f0 	mov %d15,2047
8000a5ca:	3c 6f       	j 8000a6a8 <__pack_d+0x100>
8000a5cc:	3b f0 7f f0 	mov %d15,2047
8000a5d0:	d2 04       	mov %e4,0
8000a5d2:	df 42 6b 00 	jeq %d2,4,8000a6a8 <__pack_d+0x100>
8000a5d6:	0f 89 a0 f0 	or %d15,%d9,%d8
8000a5da:	8b 22 00 32 	eq %d3,%d2,2
8000a5de:	8b 0f e0 34 	or.eq %d3,%d15,0
8000a5e2:	82 0f       	mov %d15,0
8000a5e4:	df 03 62 80 	jne %d3,0,8000a6a8 <__pack_d+0x100>
8000a5e8:	19 42 08 00 	ld.w %d2,[%a4]8
8000a5ec:	3b 20 c0 ff 	mov %d15,-1022
8000a5f0:	7f f2 36 00 	jge %d2,%d15,8000a65c <__pack_d+0xb4>
8000a5f4:	a2 2f       	sub %d15,%d2
8000a5f6:	8b 9f 83 42 	ge %d4,%d15,57
8000a5fa:	82 02       	mov %d2,0
8000a5fc:	df 04 18 80 	jne %d4,0,8000a62c <__pack_d+0x84>
8000a600:	0b 98 10 48 	mov %e4,%d8,%d9
8000a604:	02 f6       	mov %d6,%d15
8000a606:	6d ff 58 fc 	call 80009eb6 <__lshrdi3>
8000a60a:	d2 14       	mov %e4,1
8000a60c:	02 f6       	mov %d6,%d15
8000a60e:	0b 32 10 a8 	mov %e10,%d2,%d3
8000a612:	6d ff 76 ff 	call 8000a4fe <__ashldi3>
8000a616:	8b f2 9f 20 	addx %d2,%d2,-1
8000a61a:	8b f3 bf 30 	addc %d3,%d3,-1
8000a61e:	26 29       	and %d9,%d2
8000a620:	26 38       	and %d8,%d3
8000a622:	a6 98       	or %d8,%d9
8000a624:	02 b2       	mov %d2,%d11
8000a626:	8b 08 00 25 	or.ne %d2,%d8,0
8000a62a:	02 a3       	mov %d3,%d10
8000a62c:	02 2f       	mov %d15,%d2
8000a62e:	16 ff       	and %d15,255
8000a630:	8b 0f 28 f2 	ne %d15,%d15,128
8000a634:	ee 07       	jnz %d15,8000a642 <__pack_d+0x9a>
8000a636:	8f 02 10 f1 	and %d15,%d2,256
8000a63a:	6e 08       	jz %d15,8000a64a <__pack_d+0xa2>
8000a63c:	8b 02 88 20 	addx %d2,%d2,128
8000a640:	3c 03       	j 8000a646 <__pack_d+0x9e>
8000a642:	8b f2 87 20 	addx %d2,%d2,127
8000a646:	8b 03 a0 30 	addc %d3,%d3,0
8000a64a:	7b 00 00 41 	movh %d4,4096
8000a64e:	0b 43 50 f1 	ge.u %d15,%d3,%d4
8000a652:	77 23 00 5c 	dextr %d5,%d3,%d2,24
8000a656:	8f 83 1f 40 	sh %d4,%d3,-8
8000a65a:	3c 27       	j 8000a6a8 <__pack_d+0x100>
8000a65c:	3b 00 40 30 	mov %d3,1024
8000a660:	3b f0 7f f0 	mov %d15,2047
8000a664:	7f 32 22 00 	jge %d2,%d3,8000a6a8 <__pack_d+0x100>
8000a668:	02 9f       	mov %d15,%d9
8000a66a:	16 ff       	and %d15,255
8000a66c:	8b 0f 28 f2 	ne %d15,%d15,128
8000a670:	ee 07       	jnz %d15,8000a67e <__pack_d+0xd6>
8000a672:	8f 09 10 f1 	and %d15,%d9,256
8000a676:	6e 08       	jz %d15,8000a686 <__pack_d+0xde>
8000a678:	8b 09 88 90 	addx %d9,%d9,128
8000a67c:	3c 03       	j 8000a682 <__pack_d+0xda>
8000a67e:	8b f9 87 90 	addx %d9,%d9,127
8000a682:	8b 08 a0 80 	addc %d8,%d8,0
8000a686:	7b 00 00 32 	movh %d3,8192
8000a68a:	0b 38 50 f1 	ge.u %d15,%d8,%d3
8000a68e:	ee 04       	jnz %d15,8000a696 <__pack_d+0xee>
8000a690:	1b f2 3f f0 	addi %d15,%d2,1023
8000a694:	3c 06       	j 8000a6a0 <__pack_d+0xf8>
8000a696:	77 98 80 9f 	dextr %d9,%d8,%d9,31
8000a69a:	1b 02 40 f0 	addi %d15,%d2,1024
8000a69e:	06 f8       	sh %d8,-1
8000a6a0:	77 98 00 5c 	dextr %d5,%d8,%d9,24
8000a6a4:	8f 88 1f 40 	sh %d4,%d8,-8
8000a6a8:	d2 02       	mov %e2,0
8000a6aa:	37 43 14 40 	insert %d4,%d3,%d4,0,20
8000a6ae:	37 f4 0b fa 	insert %d15,%d4,%d15,20,11
8000a6b2:	02 52       	mov %d2,%d5
8000a6b4:	37 cf 81 3f 	insert %d3,%d15,%d12,31,1
8000a6b8:	00 90       	ret 

8000a6ba <__unpack_d>:
8000a6ba:	19 44 04 00 	ld.w %d4,[%a4]4
8000a6be:	54 42       	ld.w %d2,[%a4]
8000a6c0:	37 04 74 50 	extr.u %d5,%d4,0,20
8000a6c4:	37 04 6b fa 	extr.u %d15,%d4,20,11
8000a6c8:	8f 14 1e 40 	sh %d4,%d4,-31
8000a6cc:	59 54 04 00 	st.w [%a5]4,%d4
8000a6d0:	02 53       	mov %d3,%d5
8000a6d2:	ee 21       	jnz %d15,8000a714 <__unpack_d+0x5a>
8000a6d4:	0f 25 a0 f0 	or %d15,%d5,%d2
8000a6d8:	ee 03       	jnz %d15,8000a6de <__unpack_d+0x24>
8000a6da:	82 2f       	mov %d15,2
8000a6dc:	3c 23       	j 8000a722 <__unpack_d+0x68>
8000a6de:	3b 20 c0 ff 	mov %d15,-1022
8000a6e2:	6c 52       	st.w [%a5]8,%d15
8000a6e4:	82 3f       	mov %d15,3
8000a6e6:	77 25 00 34 	dextr %d3,%d5,%d2,8
8000a6ea:	2c 50       	st.b [%a5]0,%d15
8000a6ec:	8f 82 00 20 	sh %d2,%d2,8
8000a6f0:	3b 10 c0 ff 	mov %d15,-1023
8000a6f4:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000a6f8:	7b 00 00 61 	movh %d6,4096
8000a6fc:	0b 63 30 51 	lt.u %d5,%d3,%d6
8000a700:	02 f4       	mov %d4,%d15
8000a702:	06 12       	sh %d2,1
8000a704:	c2 ff       	add %d15,-1
8000a706:	df 05 f7 ff 	jne %d5,0,8000a6f4 <__unpack_d+0x3a>
8000a70a:	59 54 08 00 	st.w [%a5]8,%d4
8000a70e:	59 52 0c 00 	st.w [%a5]12,%d2
8000a712:	3c 27       	j 8000a760 <__unpack_d+0xa6>
8000a714:	3b f0 7f 40 	mov %d4,2047
8000a718:	fe 47       	jne %d15,%d4,8000a746 <__unpack_d+0x8c>
8000a71a:	0f 25 a0 f0 	or %d15,%d5,%d2
8000a71e:	ee 04       	jnz %d15,8000a726 <__unpack_d+0x6c>
8000a720:	82 4f       	mov %d15,4
8000a722:	2c 50       	st.b [%a5]0,%d15
8000a724:	00 90       	ret 
8000a726:	7b 80 00 f0 	movh %d15,8
8000a72a:	26 5f       	and %d15,%d5
8000a72c:	6e 02       	jz %d15,8000a730 <__unpack_d+0x76>
8000a72e:	82 1f       	mov %d15,1
8000a730:	2c 50       	st.b [%a5]0,%d15
8000a732:	b7 03 81 f9 	insert %d15,%d3,0,19,1
8000a736:	77 2f 00 f4 	dextr %d15,%d15,%d2,8
8000a73a:	8f 82 00 40 	sh %d4,%d2,8
8000a73e:	59 54 0c 00 	st.w [%a5]12,%d4
8000a742:	6c 54       	st.w [%a5]16,%d15
8000a744:	00 90       	ret 
8000a746:	1b 1f c0 ff 	addi %d15,%d15,-1023
8000a74a:	77 25 00 34 	dextr %d3,%d5,%d2,8
8000a74e:	6c 52       	st.w [%a5]8,%d15
8000a750:	8f 82 00 20 	sh %d2,%d2,8
8000a754:	82 3f       	mov %d15,3
8000a756:	b7 f3 01 3e 	insert %d3,%d3,15,28,1
8000a75a:	2c 50       	st.b [%a5]0,%d15
8000a75c:	59 52 0c 00 	st.w [%a5]12,%d2
8000a760:	59 53 10 00 	st.w [%a5]16,%d3
8000a764:	00 90       	ret 

8000a766 <__pack_f>:
8000a766:	14 45       	ld.bu %d5,[%a4]
8000a768:	4c 43       	ld.w %d15,[%a4]12
8000a76a:	19 47 04 00 	ld.w %d7,[%a4]4
8000a76e:	ff 25 09 80 	jge.u %d5,2,8000a780 <__pack_f+0x1a>
8000a772:	37 0f f6 33 	extr.u %d3,%d15,7,22
8000a776:	b7 f3 01 3b 	insert %d3,%d3,15,22,1
8000a77a:	3b f0 0f 40 	mov %d4,255
8000a77e:	3c 4f       	j 8000a81c <__pack_f+0xb6>
8000a780:	3b f0 0f 40 	mov %d4,255
8000a784:	82 03       	mov %d3,0
8000a786:	df 45 4b 00 	jeq %d5,4,8000a81c <__pack_f+0xb6>
8000a78a:	8b 25 00 62 	eq %d6,%d5,2
8000a78e:	8b 0f e0 64 	or.eq %d6,%d15,0
8000a792:	82 04       	mov %d4,0
8000a794:	df 06 44 80 	jne %d6,0,8000a81c <__pack_f+0xb6>
8000a798:	19 45 08 00 	ld.w %d5,[%a4]8
8000a79c:	8b 25 98 42 	ge %d4,%d5,-126
8000a7a0:	df 04 24 80 	jne %d4,0,8000a7e8 <__pack_f+0x82>
8000a7a4:	8b 25 18 51 	rsub %d5,%d5,-126
8000a7a8:	8b a5 81 42 	ge %d4,%d5,26
8000a7ac:	f6 4c       	jnz %d4,8000a7c4 <__pack_f+0x5e>
8000a7ae:	82 12       	mov %d2,1
8000a7b0:	0f 52 00 20 	sh %d2,%d2,%d5
8000a7b4:	8b 05 00 31 	rsub %d3,%d5,0
8000a7b8:	c2 f2       	add %d2,-1
8000a7ba:	0f 3f 00 30 	sh %d3,%d15,%d3
8000a7be:	26 2f       	and %d15,%d2
8000a7c0:	8b 0f 00 35 	or.ne %d3,%d15,0
8000a7c4:	8f f3 07 f1 	and %d15,%d3,127
8000a7c8:	8b 0f 24 f2 	ne %d15,%d15,64
8000a7cc:	ee 06       	jnz %d15,8000a7d8 <__pack_f+0x72>
8000a7ce:	8f 03 08 f1 	and %d15,%d3,128
8000a7d2:	ab 03 04 3f 	cadd %d3,%d15,%d3,64
8000a7d6:	3c 03       	j 8000a7dc <__pack_f+0x76>
8000a7d8:	1b f3 03 30 	addi %d3,%d3,63
8000a7dc:	7b 00 00 f4 	movh %d15,16384
8000a7e0:	0b f3 50 41 	ge.u %d4,%d3,%d15
8000a7e4:	06 93       	sh %d3,-7
8000a7e6:	3c 1b       	j 8000a81c <__pack_f+0xb6>
8000a7e8:	8b 05 88 62 	ge %d6,%d5,128
8000a7ec:	3b f0 0f 40 	mov %d4,255
8000a7f0:	df 06 16 80 	jne %d6,0,8000a81c <__pack_f+0xb6>
8000a7f4:	8f ff 07 31 	and %d3,%d15,127
8000a7f8:	8b 03 24 32 	ne %d3,%d3,64
8000a7fc:	f6 36       	jnz %d3,8000a808 <__pack_f+0xa2>
8000a7fe:	8f 0f 08 31 	and %d3,%d15,128
8000a802:	ab 0f 04 f3 	cadd %d15,%d3,%d15,64
8000a806:	3c 03       	j 8000a80c <__pack_f+0xa6>
8000a808:	1b ff 03 f0 	addi %d15,%d15,63
8000a80c:	1b f5 07 40 	addi %d4,%d5,127
8000a810:	ce f4       	jgez %d15,8000a818 <__pack_f+0xb2>
8000a812:	06 ff       	sh %d15,-1
8000a814:	1b 05 08 40 	addi %d4,%d5,128
8000a818:	8f 9f 1f 30 	sh %d3,%d15,-7
8000a81c:	82 02       	mov %d2,0
8000a81e:	37 32 17 20 	insert %d2,%d2,%d3,0,23
8000a822:	37 42 88 2b 	insert %d2,%d2,%d4,23,8
8000a826:	37 72 81 2f 	insert %d2,%d2,%d7,31,1
8000a82a:	00 90       	ret 

8000a82c <malloc>:
8000a82c:	91 00 00 f7 	movh.a %a15,28672
8000a830:	99 f4 40 40 	ld.a %a4,[%a15]1280 <70000500 <_impure_ptr>>
8000a834:	1d 00 09 00 	j 8000a846 <_malloc_r>

8000a838 <free>:
8000a838:	91 00 00 f7 	movh.a %a15,28672
8000a83c:	40 45       	mov.aa %a5,%a4
8000a83e:	99 f4 40 40 	ld.a %a4,[%a15]1280 <70000500 <_impure_ptr>>
8000a842:	1d 00 f7 02 	j 8000ae30 <_free_r>

8000a846 <_malloc_r>:
8000a846:	1b b4 00 f0 	addi %d15,%d4,11
8000a84a:	8b 7f 61 82 	lt.u %d8,%d15,23
8000a84e:	8f 7f c0 f1 	andn %d15,%d15,7
8000a852:	ab 0f a1 88 	seln %d8,%d8,%d15,16
8000a856:	0b 48 30 41 	lt.u %d4,%d8,%d4
8000a85a:	8b 08 20 45 	or.lt %d4,%d8,0
8000a85e:	40 4d       	mov.aa %a13,%a4
8000a860:	76 45       	jz %d4,8000a86a <_malloc_r+0x24>
8000a862:	da 0c       	mov %d15,12
8000a864:	6c 40       	st.w [%a4]0,%d15
8000a866:	1d 00 2a 02 	j 8000acba <_malloc_r+0x474>
8000a86a:	91 00 00 f7 	movh.a %a15,28672
8000a86e:	8b 88 bf f2 	ge.u %d15,%d8,504
8000a872:	6d 00 37 02 	call 8000ace0 <__malloc_lock>
8000a876:	d9 ff 38 30 	lea %a15,[%a15]248 <700000f8 <__malloc_av_>>
8000a87a:	ee 19       	jnz %d15,8000a8ac <_malloc_r+0x66>
8000a87c:	8f d8 1f 20 	sh %d2,%d8,-3
8000a880:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000a884:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000a888:	7d 2c 09 80 	jne.a %a12,%a2,8000a89a <_malloc_r+0x54>
8000a88c:	d9 c2 08 00 	lea %a2,[%a12]8
8000a890:	99 cc 14 00 	ld.a %a12,[%a12]20
8000a894:	c2 22       	add %d2,2
8000a896:	7d 2c 58 00 	jeq.a %a12,%a2,8000a946 <_malloc_r+0x100>
8000a89a:	cc c3       	ld.a %a15,[%a12]12
8000a89c:	99 c2 08 00 	ld.a %a2,[%a12]8
8000a8a0:	4c c1       	ld.w %d15,[%a12]4
8000a8a2:	ec 23       	st.a [%a2]12,%a15
8000a8a4:	8f 3f c0 f1 	andn %d15,%d15,3
8000a8a8:	e8 22       	st.a [%a15]8,%a2
8000a8aa:	3c 74       	j 8000a992 <_malloc_r+0x14c>
8000a8ac:	8f 78 1f f0 	sh %d15,%d8,-9
8000a8b0:	3b f0 03 20 	mov %d2,63
8000a8b4:	6e 27       	jz %d15,8000a902 <_malloc_r+0xbc>
8000a8b6:	8f a8 1f 20 	sh %d2,%d8,-6
8000a8ba:	1b 82 03 20 	addi %d2,%d2,56
8000a8be:	bf 5f 22 80 	jlt.u %d15,5,8000a902 <_malloc_r+0xbc>
8000a8c2:	8b 5f a1 22 	ge.u %d2,%d15,21
8000a8c6:	f6 24       	jnz %d2,8000a8ce <_malloc_r+0x88>
8000a8c8:	1b bf 05 20 	addi %d2,%d15,91
8000a8cc:	3c 1b       	j 8000a902 <_malloc_r+0xbc>
8000a8ce:	8b 5f a5 22 	ge.u %d2,%d15,85
8000a8d2:	f6 26       	jnz %d2,8000a8de <_malloc_r+0x98>
8000a8d4:	8f 48 1f 20 	sh %d2,%d8,-12
8000a8d8:	1b e2 06 20 	addi %d2,%d2,110
8000a8dc:	3c 13       	j 8000a902 <_malloc_r+0xbc>
8000a8de:	8b 5f b5 22 	ge.u %d2,%d15,341
8000a8e2:	f6 26       	jnz %d2,8000a8ee <_malloc_r+0xa8>
8000a8e4:	8f 18 1f 20 	sh %d2,%d8,-15
8000a8e8:	1b 72 07 20 	addi %d2,%d2,119
8000a8ec:	3c 0b       	j 8000a902 <_malloc_r+0xbc>
8000a8ee:	3b 50 55 30 	mov %d3,1365
8000a8f2:	3b e0 07 20 	mov %d2,126
8000a8f6:	7f 3f 06 80 	jge.u %d15,%d3,8000a902 <_malloc_r+0xbc>
8000a8fa:	8f e8 1e 20 	sh %d2,%d8,-18
8000a8fe:	1b c2 07 20 	addi %d2,%d2,124
8000a902:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000a906:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000a90a:	7d 2c 1d 00 	jeq.a %a12,%a2,8000a944 <_malloc_r+0xfe>
8000a90e:	19 c4 04 00 	ld.w %d4,[%a12]4
8000a912:	8f 34 c0 41 	andn %d4,%d4,3
8000a916:	5a 84       	sub %d15,%d4,%d8
8000a918:	8b 0f 41 32 	lt %d3,%d15,16
8000a91c:	f6 33       	jnz %d3,8000a922 <_malloc_r+0xdc>
8000a91e:	c2 f2       	add %d2,-1
8000a920:	3c 12       	j 8000a944 <_malloc_r+0xfe>
8000a922:	0e fe       	jltz %d15,8000a93e <_malloc_r+0xf8>
8000a924:	cc c3       	ld.a %a15,[%a12]12
8000a926:	99 c2 08 00 	ld.a %a2,[%a12]8
8000a92a:	ec 23       	st.a [%a2]12,%a15
8000a92c:	e8 22       	st.a [%a15]8,%a2
8000a92e:	01 c4 00 f6 	addsc.a %a15,%a12,%d4,0
8000a932:	b7 10 21 20 	imask %e2,1,0,1
8000a936:	49 f2 44 08 	ldmst [%a15]4,%e2
8000a93a:	1d 00 cc 01 	j 8000acd2 <_malloc_r+0x48c>
8000a93e:	99 cc 0c 00 	ld.a %a12,[%a12]12
8000a942:	3c e4       	j 8000a90a <_malloc_r+0xc4>
8000a944:	c2 12       	add %d2,1
8000a946:	c8 4c       	ld.a %a12,[%a15]16
8000a948:	91 00 00 37 	movh.a %a3,28672
8000a94c:	d9 33 00 40 	lea %a3,[%a3]256 <70000100 <__malloc_av_+0x8>>
8000a950:	7d 3c 83 00 	jeq.a %a12,%a3,8000aa56 <_malloc_r+0x210>
8000a954:	4c c1       	ld.w %d15,[%a12]4
8000a956:	8f 3f c0 f1 	andn %d15,%d15,3
8000a95a:	52 83       	sub %d3,%d15,%d8
8000a95c:	8b 03 41 42 	lt %d4,%d3,16
8000a960:	df 04 16 80 	jne %d4,0,8000a98c <_malloc_r+0x146>
8000a964:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000a968:	8f 18 40 81 	or %d8,%d8,1
8000a96c:	59 c8 04 00 	st.w [%a12]4,%d8
8000a970:	e8 52       	st.a [%a15]20,%a2
8000a972:	e8 42       	st.a [%a15]16,%a2
8000a974:	8f 13 40 f1 	or %d15,%d3,1
8000a978:	b5 23 0c 00 	st.a [%a2]12,%a3
8000a97c:	b5 23 08 00 	st.a [%a2]8,%a3
8000a980:	6c 21       	st.w [%a2]4,%d15
8000a982:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000a986:	74 23       	st.w [%a2],%d3
8000a988:	1d 00 a5 01 	j 8000acd2 <_malloc_r+0x48c>
8000a98c:	e8 53       	st.a [%a15]20,%a3
8000a98e:	e8 43       	st.a [%a15]16,%a3
8000a990:	0e 33       	jltz %d3,8000a996 <_malloc_r+0x150>
8000a992:	10 cf       	addsc.a %a15,%a12,%d15,0
8000a994:	3c cf       	j 8000a932 <_malloc_r+0xec>
8000a996:	3b 00 20 30 	mov %d3,512
8000a99a:	7f 3f 15 80 	jge.u %d15,%d3,8000a9c4 <_malloc_r+0x17e>
8000a99e:	06 df       	sh %d15,-3
8000a9a0:	d0 f2       	addsc.a %a2,%a15,%d15,3
8000a9a2:	48 14       	ld.w %d4,[%a15]4
8000a9a4:	99 24 08 00 	ld.a %a4,[%a2]8
8000a9a8:	8f ef 3f 30 	sha %d3,%d15,-2
8000a9ac:	b5 c2 0c 00 	st.a [%a12]12,%a2
8000a9b0:	b5 c4 08 00 	st.a [%a12]8,%a4
8000a9b4:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
8000a9b8:	b5 2c 08 00 	st.a [%a2]8,%a12
8000a9bc:	68 13       	st.w [%a15]4,%d3
8000a9be:	b5 4c 0c 00 	st.a [%a4]12,%a12
8000a9c2:	3c 4a       	j 8000aa56 <_malloc_r+0x210>
8000a9c4:	8f af 1f 40 	sh %d4,%d15,-6
8000a9c8:	8f 7f 1f 30 	sh %d3,%d15,-9
8000a9cc:	1b 84 03 40 	addi %d4,%d4,56
8000a9d0:	bf 53 22 80 	jlt.u %d3,5,8000aa14 <_malloc_r+0x1ce>
8000a9d4:	8b 53 a1 42 	ge.u %d4,%d3,21
8000a9d8:	f6 44       	jnz %d4,8000a9e0 <_malloc_r+0x19a>
8000a9da:	1b b3 05 40 	addi %d4,%d3,91
8000a9de:	3c 1b       	j 8000aa14 <_malloc_r+0x1ce>
8000a9e0:	8b 53 a5 42 	ge.u %d4,%d3,85
8000a9e4:	f6 46       	jnz %d4,8000a9f0 <_malloc_r+0x1aa>
8000a9e6:	8f 4f 1f 40 	sh %d4,%d15,-12
8000a9ea:	1b e4 06 40 	addi %d4,%d4,110
8000a9ee:	3c 13       	j 8000aa14 <_malloc_r+0x1ce>
8000a9f0:	8b 53 b5 42 	ge.u %d4,%d3,341
8000a9f4:	f6 46       	jnz %d4,8000aa00 <_malloc_r+0x1ba>
8000a9f6:	8f 1f 1f 40 	sh %d4,%d15,-15
8000a9fa:	1b 74 07 40 	addi %d4,%d4,119
8000a9fe:	3c 0b       	j 8000aa14 <_malloc_r+0x1ce>
8000aa00:	3b 50 55 50 	mov %d5,1365
8000aa04:	3b e0 07 40 	mov %d4,126
8000aa08:	7f 53 06 80 	jge.u %d3,%d5,8000aa14 <_malloc_r+0x1ce>
8000aa0c:	8f ef 1e 40 	sh %d4,%d15,-18
8000aa10:	1b c4 07 40 	addi %d4,%d4,124
8000aa14:	01 f4 03 46 	addsc.a %a4,%a15,%d4,3
8000aa18:	99 42 08 00 	ld.a %a2,[%a4]8
8000aa1c:	7d 42 0d 80 	jne.a %a2,%a4,8000aa36 <_malloc_r+0x1f0>
8000aa20:	4c f1       	ld.w %d15,[%a15]4
8000aa22:	86 e4       	sha %d4,-2
8000aa24:	d7 1f 01 44 	insert %d4,%d15,1,%d4,1
8000aa28:	40 24       	mov.aa %a4,%a2
8000aa2a:	68 14       	st.w [%a15]4,%d4
8000aa2c:	3c 0d       	j 8000aa46 <_malloc_r+0x200>
8000aa2e:	99 22 08 00 	ld.a %a2,[%a2]8
8000aa32:	7d 42 08 00 	jeq.a %a2,%a4,8000aa42 <_malloc_r+0x1fc>
8000aa36:	19 23 04 00 	ld.w %d3,[%a2]4
8000aa3a:	8f 33 c0 31 	andn %d3,%d3,3
8000aa3e:	3f 3f f8 ff 	jlt.u %d15,%d3,8000aa2e <_malloc_r+0x1e8>
8000aa42:	99 24 0c 00 	ld.a %a4,[%a2]12
8000aa46:	b5 c4 0c 00 	st.a [%a12]12,%a4
8000aa4a:	b5 c2 08 00 	st.a [%a12]8,%a2
8000aa4e:	b5 4c 08 00 	st.a [%a4]8,%a12
8000aa52:	b5 2c 0c 00 	st.a [%a2]12,%a12
8000aa56:	8f e2 3f 30 	sha %d3,%d2,-2
8000aa5a:	82 1f       	mov %d15,1
8000aa5c:	0f 3f 00 f0 	sh %d15,%d15,%d3
8000aa60:	48 13       	ld.w %d3,[%a15]4
8000aa62:	3f f3 73 80 	jlt.u %d3,%d15,8000ab48 <_malloc_r+0x302>
8000aa66:	0f 3f 80 40 	and %d4,%d15,%d3
8000aa6a:	f6 49       	jnz %d4,8000aa7c <_malloc_r+0x236>
8000aa6c:	8f 32 c0 21 	andn %d2,%d2,3
8000aa70:	06 1f       	sh %d15,1
8000aa72:	0f 3f 80 40 	and %d4,%d15,%d3
8000aa76:	c2 42       	add %d2,4
8000aa78:	df 04 fc 7f 	jeq %d4,0,8000aa70 <_malloc_r+0x22a>
8000aa7c:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000aa80:	02 24       	mov %d4,%d2
8000aa82:	40 24       	mov.aa %a4,%a2
8000aa84:	99 4c 0c 00 	ld.a %a12,[%a4]12
8000aa88:	7d 4c 3c 00 	jeq.a %a12,%a4,8000ab00 <_malloc_r+0x2ba>
8000aa8c:	19 c6 04 00 	ld.w %d6,[%a12]4
8000aa90:	8f 36 c0 61 	andn %d6,%d6,3
8000aa94:	0b 86 80 30 	sub %d3,%d6,%d8
8000aa98:	8b 03 41 52 	lt %d5,%d3,16
8000aa9c:	df 05 1d 80 	jne %d5,0,8000aad6 <_malloc_r+0x290>
8000aaa0:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000aaa4:	8f 18 40 81 	or %d8,%d8,1
8000aaa8:	59 c8 04 00 	st.w [%a12]4,%d8
8000aaac:	99 c4 0c 00 	ld.a %a4,[%a12]12
8000aab0:	09 c5 88 05 	ld.a %a5,[+%a12]8
8000aab4:	8f 13 40 f1 	or %d15,%d3,1
8000aab8:	b5 54 0c 00 	st.a [%a5]12,%a4
8000aabc:	b5 45 08 00 	st.a [%a4]8,%a5
8000aac0:	e8 52       	st.a [%a15]20,%a2
8000aac2:	e8 42       	st.a [%a15]16,%a2
8000aac4:	b5 23 0c 00 	st.a [%a2]12,%a3
8000aac8:	b5 23 08 00 	st.a [%a2]8,%a3
8000aacc:	6c 21       	st.w [%a2]4,%d15
8000aace:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000aad2:	74 23       	st.w [%a2],%d3
8000aad4:	3c 0e       	j 8000aaf0 <_malloc_r+0x2aa>
8000aad6:	bf 03 12 00 	jlt %d3,0,8000aafa <_malloc_r+0x2b4>
8000aada:	01 c6 00 f6 	addsc.a %a15,%a12,%d6,0
8000aade:	b7 10 21 20 	imask %e2,1,0,1
8000aae2:	49 f2 44 08 	ldmst [%a15]4,%e2
8000aae6:	cc c3       	ld.a %a15,[%a12]12
8000aae8:	09 c2 88 05 	ld.a %a2,[+%a12]8
8000aaec:	ec 23       	st.a [%a2]12,%a15
8000aaee:	e8 22       	st.a [%a15]8,%a2
8000aaf0:	40 d4       	mov.aa %a4,%a13
8000aaf2:	6d 00 f8 00 	call 8000ace2 <__malloc_unlock>
8000aaf6:	1d 00 f3 00 	j 8000acdc <_malloc_r+0x496>
8000aafa:	99 cc 0c 00 	ld.a %a12,[%a12]12
8000aafe:	3c c5       	j 8000aa88 <_malloc_r+0x242>
8000ab00:	c2 14       	add %d4,1
8000ab02:	8f 34 00 31 	and %d3,%d4,3
8000ab06:	d9 44 08 00 	lea %a4,[%a4]8
8000ab0a:	df 03 bd ff 	jne %d3,0,8000aa84 <_malloc_r+0x23e>
8000ab0e:	8f 32 00 31 	and %d3,%d2,3
8000ab12:	f6 36       	jnz %d3,8000ab1e <_malloc_r+0x2d8>
8000ab14:	48 12       	ld.w %d2,[%a15]4
8000ab16:	0f f2 e0 20 	andn %d2,%d2,%d15
8000ab1a:	68 12       	st.w [%a15]4,%d2
8000ab1c:	3c 07       	j 8000ab2a <_malloc_r+0x2e4>
8000ab1e:	d9 24 f8 ff 	lea %a4,[%a2]-8
8000ab22:	d4 22       	ld.a %a2,[%a2]
8000ab24:	c2 f2       	add %d2,-1
8000ab26:	7d 42 f4 7f 	jeq.a %a2,%a4,8000ab0e <_malloc_r+0x2c8>
8000ab2a:	06 1f       	sh %d15,1
8000ab2c:	48 12       	ld.w %d2,[%a15]4
8000ab2e:	8b 0f 20 32 	ne %d3,%d15,0
8000ab32:	0b f2 50 32 	and.ge.u %d3,%d2,%d15
8000ab36:	76 39       	jz %d3,8000ab48 <_malloc_r+0x302>
8000ab38:	0f 2f 80 30 	and %d3,%d15,%d2
8000ab3c:	f6 34       	jnz %d3,8000ab44 <_malloc_r+0x2fe>
8000ab3e:	c2 44       	add %d4,4
8000ab40:	06 1f       	sh %d15,1
8000ab42:	3c fb       	j 8000ab38 <_malloc_r+0x2f2>
8000ab44:	02 42       	mov %d2,%d4
8000ab46:	3c 9b       	j 8000aa7c <_malloc_r+0x236>
8000ab48:	c8 2c       	ld.a %a12,[%a15]8
8000ab4a:	19 ca 04 00 	ld.w %d10,[%a12]4
8000ab4e:	8f 3a c0 a1 	andn %d10,%d10,3
8000ab52:	5a 8a       	sub %d15,%d10,%d8
8000ab54:	8b 0f 41 22 	lt %d2,%d15,16
8000ab58:	0b 8a a0 22 	or.lt.u %d2,%d10,%d8
8000ab5c:	df 02 b1 00 	jeq %d2,0,8000acbe <_malloc_r+0x478>
8000ab60:	91 00 00 27 	movh.a %a2,28672
8000ab64:	19 2b f8 00 	ld.w %d11,[%a2]3128 <70000c38 <__malloc_top_pad>>
8000ab68:	91 00 00 27 	movh.a %a2,28672
8000ab6c:	42 8b       	add %d11,%d8
8000ab6e:	19 23 30 30 	ld.w %d3,[%a2]240 <700000f0 <__malloc_sbrk_base>>
8000ab72:	1b fb 00 f1 	addi %d15,%d11,4111
8000ab76:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
8000ab7a:	1b 0b 01 20 	addi %d2,%d11,16
8000ab7e:	8b f3 3f b2 	ne %d11,%d3,-1
8000ab82:	2b 2f 40 bb 	sel %d11,%d11,%d15,%d2
8000ab86:	40 d4       	mov.aa %a4,%a13
8000ab88:	02 b4       	mov %d4,%d11
8000ab8a:	80 2c       	mov.d %d12,%a2
8000ab8c:	6d 00 ac 00 	call 8000ace4 <_sbrk_r>
8000ab90:	80 29       	mov.d %d9,%a2
8000ab92:	df f9 86 00 	jeq %d9,-1,8000ac9e <_malloc_r+0x458>
8000ab96:	80 c2       	mov.d %d2,%a12
8000ab98:	80 c3       	mov.d %d3,%a12
8000ab9a:	42 a2       	add %d2,%d10
8000ab9c:	80 f4       	mov.d %d4,%a15
8000ab9e:	0b 29 30 f1 	lt.u %d15,%d9,%d2
8000aba2:	0b 43 10 f2 	and.ne %d15,%d3,%d4
8000aba6:	01 fc 10 d4 	ne.a %d13,%a12,%a15
8000abaa:	ee 7a       	jnz %d15,8000ac9e <_malloc_r+0x458>
8000abac:	91 00 00 e7 	movh.a %a14,28672
8000abb0:	19 e3 c8 00 	ld.w %d3,[%a14]3080 <70000c08 <__malloc_current_mallinfo>>
8000abb4:	42 b3       	add %d3,%d11
8000abb6:	59 e3 c8 00 	st.w [%a14]3080 <70000c08 <__malloc_current_mallinfo>>,%d3
8000abba:	5f 29 0c 80 	jne %d9,%d2,8000abd2 <_malloc_r+0x38c>
8000abbe:	b7 09 14 f6 	insert %d15,%d9,0,12,20
8000abc2:	ee 08       	jnz %d15,8000abd2 <_malloc_r+0x38c>
8000abc4:	c8 22       	ld.a %a2,[%a15]8
8000abc6:	42 ba       	add %d10,%d11
8000abc8:	8f 1a 40 a1 	or %d10,%d10,1
8000abcc:	59 2a 04 00 	st.w [%a2]4,%d10
8000abd0:	3c 55       	j 8000ac7a <_malloc_r+0x434>
8000abd2:	60 c2       	mov.a %a2,%d12
8000abd4:	19 2f 30 30 	ld.w %d15,[%a2]240
8000abd8:	5e f6       	jne %d15,-1,8000abe4 <_malloc_r+0x39e>
8000abda:	91 00 00 27 	movh.a %a2,28672
8000abde:	59 29 30 30 	st.w [%a2]240 <700000f0 <__malloc_sbrk_base>>,%d9
8000abe2:	3c 06       	j 8000abee <_malloc_r+0x3a8>
8000abe4:	0b 29 80 20 	sub %d2,%d9,%d2
8000abe8:	42 23       	add %d3,%d2
8000abea:	59 e3 c8 00 	st.w [%a14]3080 <70000c08 <__malloc_current_mallinfo>>,%d3
8000abee:	8f 79 00 21 	and %d2,%d9,7
8000abf2:	82 0f       	mov %d15,0
8000abf4:	76 24       	jz %d2,8000abfc <_malloc_r+0x3b6>
8000abf6:	8b 82 00 f1 	rsub %d15,%d2,8
8000abfa:	42 f9       	add %d9,%d15
8000abfc:	42 9b       	add %d11,%d9
8000abfe:	b7 0b 14 b6 	insert %d11,%d11,0,12,20
8000ac02:	1b 0f 00 21 	addi %d2,%d15,4096
8000ac06:	5a b2       	sub %d15,%d2,%d11
8000ac08:	40 d4       	mov.aa %a4,%a13
8000ac0a:	02 f4       	mov %d4,%d15
8000ac0c:	6d 00 6c 00 	call 8000ace4 <_sbrk_r>
8000ac10:	80 22       	mov.d %d2,%a2
8000ac12:	df f2 04 80 	jne %d2,-1,8000ac1a <_malloc_r+0x3d4>
8000ac16:	60 92       	mov.a %a2,%d9
8000ac18:	82 0f       	mov %d15,0
8000ac1a:	80 2b       	mov.d %d11,%a2
8000ac1c:	19 e2 c8 00 	ld.w %d2,[%a14]3080 <70000c08 <__malloc_current_mallinfo>>
8000ac20:	a2 9b       	sub %d11,%d9
8000ac22:	42 f2       	add %d2,%d15
8000ac24:	60 92       	mov.a %a2,%d9
8000ac26:	42 bf       	add %d15,%d11
8000ac28:	68 29       	st.w [%a15]8,%d9
8000ac2a:	8f 1f 40 31 	or %d3,%d15,1
8000ac2e:	59 e2 c8 00 	st.w [%a14]3080 <70000c08 <__malloc_current_mallinfo>>,%d2
8000ac32:	59 23 04 00 	st.w [%a2]4 <70000c08 <__malloc_current_mallinfo>>,%d3
8000ac36:	df 0d 22 00 	jeq %d13,0,8000ac7a <_malloc_r+0x434>
8000ac3a:	8b 0a a1 f2 	ge.u %d15,%d10,16
8000ac3e:	ee 05       	jnz %d15,8000ac48 <_malloc_r+0x402>
8000ac40:	82 12       	mov %d2,1
8000ac42:	59 22 04 00 	st.w [%a2]4,%d2
8000ac46:	3c 2c       	j 8000ac9e <_malloc_r+0x458>
8000ac48:	1b 4a ff af 	addi %d10,%d10,-12
8000ac4c:	8f 7a c0 f1 	andn %d15,%d10,7
8000ac50:	10 c2       	addsc.a %a2,%a12,%d15,0
8000ac52:	82 52       	mov %d2,5
8000ac54:	59 22 04 00 	st.w [%a2]4,%d2
8000ac58:	59 22 08 00 	st.w [%a2]8,%d2
8000ac5c:	19 c2 04 00 	ld.w %d2,[%a12]4
8000ac60:	8f 12 00 21 	and %d2,%d2,1
8000ac64:	a6 f2       	or %d2,%d15
8000ac66:	59 c2 04 00 	st.w [%a12]4,%d2
8000ac6a:	8b 0f 61 f2 	lt.u %d15,%d15,16
8000ac6e:	ee 06       	jnz %d15,8000ac7a <_malloc_r+0x434>
8000ac70:	40 d4       	mov.aa %a4,%a13
8000ac72:	d9 c5 08 00 	lea %a5,[%a12]8
8000ac76:	6d 00 dd 00 	call 8000ae30 <_free_r>
8000ac7a:	91 00 00 27 	movh.a %a2,28672
8000ac7e:	19 ef c8 00 	ld.w %d15,[%a14]3080 <70000c08 <__malloc_current_mallinfo>>
8000ac82:	19 22 f4 00 	ld.w %d2,[%a2]3124 <70000c34 <__malloc_max_sbrked_mem>>
8000ac86:	7f f2 04 80 	jge.u %d2,%d15,8000ac8e <_malloc_r+0x448>
8000ac8a:	59 2f f4 00 	st.w [%a2]3124 <70000c34 <__malloc_max_sbrked_mem>>,%d15
8000ac8e:	91 00 00 27 	movh.a %a2,28672
8000ac92:	19 22 f0 00 	ld.w %d2,[%a2]3120 <70000c30 <__malloc_max_total_mem>>
8000ac96:	7f f2 04 80 	jge.u %d2,%d15,8000ac9e <_malloc_r+0x458>
8000ac9a:	59 2f f0 00 	st.w [%a2]3120 <70000c30 <__malloc_max_total_mem>>,%d15
8000ac9e:	c8 22       	ld.a %a2,[%a15]8
8000aca0:	19 22 04 00 	ld.w %d2,[%a2]4 <70000c30 <__malloc_max_total_mem>>
8000aca4:	8f 32 c0 21 	andn %d2,%d2,3
8000aca8:	5a 82       	sub %d15,%d2,%d8
8000acaa:	8b 0f 41 32 	lt %d3,%d15,16
8000acae:	0b 82 a0 32 	or.lt.u %d3,%d2,%d8
8000acb2:	76 36       	jz %d3,8000acbe <_malloc_r+0x478>
8000acb4:	40 d4       	mov.aa %a4,%a13
8000acb6:	6d 00 16 00 	call 8000ace2 <__malloc_unlock>
8000acba:	a0 0c       	mov.a %a12,0
8000acbc:	3c 10       	j 8000acdc <_malloc_r+0x496>
8000acbe:	c8 2c       	ld.a %a12,[%a15]8
8000acc0:	8f 18 40 21 	or %d2,%d8,1
8000acc4:	96 01       	or %d15,1
8000acc6:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000acca:	59 c2 04 00 	st.w [%a12]4,%d2
8000acce:	e8 22       	st.a [%a15]8,%a2
8000acd0:	6c 21       	st.w [%a2]4,%d15
8000acd2:	40 d4       	mov.aa %a4,%a13
8000acd4:	6d 00 07 00 	call 8000ace2 <__malloc_unlock>
8000acd8:	d9 cc 08 00 	lea %a12,[%a12]8
8000acdc:	40 c2       	mov.aa %a2,%a12
8000acde:	00 90       	ret 

8000ace0 <__malloc_lock>:
8000ace0:	00 90       	ret 

8000ace2 <__malloc_unlock>:
8000ace2:	00 90       	ret 

8000ace4 <_sbrk_r>:
8000ace4:	82 0f       	mov %d15,0
8000ace6:	91 00 00 c7 	movh.a %a12,28672
8000acea:	59 cf c0 10 	st.w [%a12]3136 <70000c40 <errno>>,%d15
8000acee:	40 4f       	mov.aa %a15,%a4
8000acf0:	6d 00 2c 17 	call 8000db48 <sbrk>
8000acf4:	80 2f       	mov.d %d15,%a2
8000acf6:	5e f5       	jne %d15,-1,8000ad00 <_sbrk_r+0x1c>
8000acf8:	19 cf c0 10 	ld.w %d15,[%a12]3136 <70000c40 <errno>>
8000acfc:	6e 02       	jz %d15,8000ad00 <_sbrk_r+0x1c>
8000acfe:	68 0f       	st.w [%a15]0,%d15
8000ad00:	00 90       	ret 

8000ad02 <strlen>:
8000ad02:	80 42       	mov.d %d2,%a4
8000ad04:	80 4f       	mov.d %d15,%a4
8000ad06:	60 ff       	mov.a %a15,%d15
8000ad08:	79 f3 00 00 	ld.b %d3,[%a15]0
8000ad0c:	76 33       	jz %d3,8000ad12 <strlen+0x10>
8000ad0e:	c2 1f       	add %d15,1
8000ad10:	3c fb       	j 8000ad06 <strlen+0x4>
8000ad12:	52 22       	sub %d2,%d15,%d2
8000ad14:	00 90       	ret 

8000ad16 <_vsnprintf_r>:
8000ad16:	20 68       	sub.a %sp,104
8000ad18:	40 4f       	mov.aa %a15,%a4
8000ad1a:	ce 45       	jgez %d4,8000ad24 <_vsnprintf_r+0xe>
8000ad1c:	da 8b       	mov %d15,139
8000ad1e:	6c 40       	st.w [%a4]0,%d15
8000ad20:	82 f2       	mov %d2,-1
8000ad22:	00 90       	ret 
8000ad24:	02 4f       	mov %d15,%d4
8000ad26:	3b 80 20 20 	mov %d2,520
8000ad2a:	f9 a2 0c 00 	st.h [%sp]12,%d2
8000ad2e:	92 f2       	add %d2,%d15,-1
8000ad30:	ea 02       	cmovn %d2,%d15,0
8000ad32:	f4 a5       	st.a [%sp],%a5
8000ad34:	b5 a5 10 00 	st.a [%sp]16,%a5
8000ad38:	59 a2 08 00 	st.w [%sp]8,%d2
8000ad3c:	59 a2 14 00 	st.w [%sp]20,%d2
8000ad40:	40 a5       	mov.aa %a5,%sp
8000ad42:	82 f2       	mov %d2,-1
8000ad44:	f9 a2 0e 00 	st.h [%sp]14,%d2
8000ad48:	6d 00 4a 01 	call 8000afdc <_svfprintf_r>
8000ad4c:	ff f2 05 00 	jge %d2,-1,8000ad56 <_vsnprintf_r+0x40>
8000ad50:	3b b0 08 30 	mov %d3,139
8000ad54:	68 03       	st.w [%a15]0,%d3
8000ad56:	6e 04       	jz %d15,8000ad5e <_vsnprintf_r+0x48>
8000ad58:	d8 00       	ld.a %a15,[%sp]0
8000ad5a:	82 0f       	mov %d15,0
8000ad5c:	28 0f       	st.b [%a15]0,%d15
8000ad5e:	00 90       	ret 

8000ad60 <vsnprintf>:
8000ad60:	91 00 00 37 	movh.a %a3,28672
8000ad64:	40 42       	mov.aa %a2,%a4
8000ad66:	99 34 40 40 	ld.a %a4,[%a3]1280 <70000500 <_impure_ptr>>
8000ad6a:	40 5f       	mov.aa %a15,%a5
8000ad6c:	40 67       	mov.aa %a7,%a6
8000ad6e:	40 25       	mov.aa %a5,%a2
8000ad70:	40 f6       	mov.aa %a6,%a15
8000ad72:	1d ff d2 ff 	j 8000ad16 <_vsnprintf_r>

8000ad76 <_malloc_trim_r>:
8000ad76:	02 4f       	mov %d15,%d4
8000ad78:	40 4f       	mov.aa %a15,%a4
8000ad7a:	6d ff b3 ff 	call 8000ace0 <__malloc_lock>
8000ad7e:	91 00 00 c7 	movh.a %a12,28672
8000ad82:	d9 cc 38 30 	lea %a12,[%a12]248 <700000f8 <__malloc_av_>>
8000ad86:	99 c2 08 00 	ld.a %a2,[%a12]8 <70000008 <osEE_ccb_var>>
8000ad8a:	3b 00 00 21 	mov %d2,4096
8000ad8e:	19 28 04 00 	ld.w %d8,[%a2]4
8000ad92:	8f 38 c0 81 	andn %d8,%d8,3
8000ad96:	5a f8       	sub %d15,%d8,%d15
8000ad98:	1b ff fe f0 	addi %d15,%d15,4079
8000ad9c:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
8000ada0:	1b 0f 00 ff 	addi %d15,%d15,-4096
8000ada4:	7f 2f 07 00 	jge %d15,%d2,8000adb2 <_malloc_trim_r+0x3c>
8000ada8:	40 f4       	mov.aa %a4,%a15
8000adaa:	6d ff 9c ff 	call 8000ace2 <__malloc_unlock>
8000adae:	82 02       	mov %d2,0
8000adb0:	00 90       	ret 
8000adb2:	40 f4       	mov.aa %a4,%a15
8000adb4:	82 04       	mov %d4,0
8000adb6:	6d ff 97 ff 	call 8000ace4 <_sbrk_r>
8000adba:	99 c3 08 00 	ld.a %a3,[%a12]8
8000adbe:	60 84       	mov.a %a4,%d8
8000adc0:	30 43       	add.a %a3,%a4
8000adc2:	7d 32 f3 ff 	jne.a %a2,%a3,8000ada8 <_malloc_trim_r+0x32>
8000adc6:	40 f4       	mov.aa %a4,%a15
8000adc8:	8b 0f 00 41 	rsub %d4,%d15,0
8000adcc:	6d ff 8c ff 	call 8000ace4 <_sbrk_r>
8000add0:	80 22       	mov.d %d2,%a2
8000add2:	df f2 1c 80 	jne %d2,-1,8000ae0a <_malloc_trim_r+0x94>
8000add6:	40 f4       	mov.aa %a4,%a15
8000add8:	82 04       	mov %d4,0
8000adda:	6d ff 85 ff 	call 8000ace4 <_sbrk_r>
8000adde:	99 c3 08 00 	ld.a %a3,[%a12]8
8000ade2:	01 32 20 40 	sub.a %a4,%a2,%a3
8000ade6:	80 4f       	mov.d %d15,%a4
8000ade8:	8b 0f 41 22 	lt %d2,%d15,16
8000adec:	df 02 de ff 	jne %d2,0,8000ada8 <_malloc_trim_r+0x32>
8000adf0:	91 00 00 47 	movh.a %a4,28672
8000adf4:	99 44 30 30 	ld.a %a4,[%a4]240 <700000f0 <__malloc_sbrk_base>>
8000adf8:	96 01       	or %d15,1
8000adfa:	6c 31       	st.w [%a3]4,%d15
8000adfc:	01 42 20 20 	sub.a %a2,%a2,%a4
8000ae00:	91 00 00 47 	movh.a %a4,28672
8000ae04:	b5 42 c8 00 	st.a [%a4]3080 <70000c08 <__malloc_current_mallinfo>>,%a2
8000ae08:	3c d0       	j 8000ada8 <_malloc_trim_r+0x32>
8000ae0a:	99 c2 08 00 	ld.a %a2,[%a12]8
8000ae0e:	a2 f8       	sub %d8,%d15
8000ae10:	8f 18 40 81 	or %d8,%d8,1
8000ae14:	59 28 04 00 	st.w [%a2]4,%d8
8000ae18:	91 00 00 27 	movh.a %a2,28672
8000ae1c:	19 22 c8 00 	ld.w %d2,[%a2]3080 <70000c08 <__malloc_current_mallinfo>>
8000ae20:	40 f4       	mov.aa %a4,%a15
8000ae22:	5a f2       	sub %d15,%d2,%d15
8000ae24:	59 2f c8 00 	st.w [%a2]3080 <70000c08 <__malloc_current_mallinfo>>,%d15
8000ae28:	6d ff 5d ff 	call 8000ace2 <__malloc_unlock>
8000ae2c:	82 12       	mov %d2,1
8000ae2e:	00 90       	ret 

8000ae30 <_free_r>:
8000ae30:	40 4d       	mov.aa %a13,%a4
8000ae32:	bd 05 d4 00 	jz.a %a5,8000afda <_free_r+0x1aa>
8000ae36:	40 5c       	mov.aa %a12,%a5
8000ae38:	6d ff 54 ff 	call 8000ace0 <__malloc_lock>
8000ae3c:	19 c4 fc ff 	ld.w %d4,[%a12]-4
8000ae40:	d9 cf f8 ff 	lea %a15,[%a12]-8
8000ae44:	8f 14 c0 f1 	andn %d15,%d4,1
8000ae48:	91 00 00 27 	movh.a %a2,28672
8000ae4c:	10 f3       	addsc.a %a3,%a15,%d15,0
8000ae4e:	d9 22 38 30 	lea %a2,[%a2]248 <700000f8 <__malloc_av_>>
8000ae52:	99 24 08 00 	ld.a %a4,[%a2]8 <70000008 <osEE_ccb_var>>
8000ae56:	19 33 04 00 	ld.w %d3,[%a3]4 <70000008 <osEE_ccb_var>>
8000ae5a:	8f 14 00 41 	and %d4,%d4,1
8000ae5e:	8f 33 c0 31 	andn %d3,%d3,3
8000ae62:	7d 43 24 80 	jne.a %a3,%a4,8000aeaa <_free_r+0x7a>
8000ae66:	42 3f       	add %d15,%d3
8000ae68:	f6 4d       	jnz %d4,8000ae82 <_free_r+0x52>
8000ae6a:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
8000ae6e:	60 23       	mov.a %a3,%d2
8000ae70:	42 2f       	add %d15,%d2
8000ae72:	01 3f 20 f0 	sub.a %a15,%a15,%a3
8000ae76:	c8 33       	ld.a %a3,[%a15]12
8000ae78:	c8 24       	ld.a %a4,[%a15]8
8000ae7a:	b5 43 0c 00 	st.a [%a4]12,%a3
8000ae7e:	b5 34 08 00 	st.a [%a3]8,%a4
8000ae82:	8f 1f 40 21 	or %d2,%d15,1
8000ae86:	68 12       	st.w [%a15]4,%d2
8000ae88:	ec 22       	st.a [%a2]8,%a15
8000ae8a:	91 00 00 f7 	movh.a %a15,28672
8000ae8e:	19 f2 34 30 	ld.w %d2,[%a15]244 <700000f4 <__malloc_trim_threshold>>
8000ae92:	3f 2f 09 80 	jlt.u %d15,%d2,8000aea4 <_free_r+0x74>
8000ae96:	91 00 00 f7 	movh.a %a15,28672
8000ae9a:	40 d4       	mov.aa %a4,%a13
8000ae9c:	19 f4 f8 00 	ld.w %d4,[%a15]3128 <70000c38 <__malloc_top_pad>>
8000aea0:	6d ff 6b ff 	call 8000ad76 <_malloc_trim_r>
8000aea4:	40 d4       	mov.aa %a4,%a13
8000aea6:	1d ff 1e ff 	j 8000ace2 <__malloc_unlock>
8000aeaa:	59 33 04 00 	st.w [%a3]4,%d3
8000aeae:	82 02       	mov %d2,0
8000aeb0:	df 04 16 80 	jne %d4,0,8000aedc <_free_r+0xac>
8000aeb4:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
8000aeb8:	60 24       	mov.a %a4,%d2
8000aeba:	42 2f       	add %d15,%d2
8000aebc:	01 4f 20 f0 	sub.a %a15,%a15,%a4
8000aec0:	c8 25       	ld.a %a5,[%a15]8
8000aec2:	91 00 00 47 	movh.a %a4,28672
8000aec6:	d9 44 00 40 	lea %a4,[%a4]256 <70000100 <__malloc_av_+0x8>>
8000aeca:	82 12       	mov %d2,1
8000aecc:	7d 45 08 00 	jeq.a %a5,%a4,8000aedc <_free_r+0xac>
8000aed0:	c8 34       	ld.a %a4,[%a15]12
8000aed2:	82 02       	mov %d2,0
8000aed4:	b5 54 0c 00 	st.a [%a5]12,%a4
8000aed8:	b5 45 08 00 	st.a [%a4]8,%a5
8000aedc:	01 33 00 46 	addsc.a %a4,%a3,%d3,0
8000aee0:	19 44 04 00 	ld.w %d4,[%a4]4
8000aee4:	6f 04 18 80 	jnz.t %d4,0,8000af14 <_free_r+0xe4>
8000aee8:	42 3f       	add %d15,%d3
8000aeea:	99 35 08 00 	ld.a %a5,[%a3]8
8000aeee:	f6 2d       	jnz %d2,8000af08 <_free_r+0xd8>
8000aef0:	91 00 00 47 	movh.a %a4,28672
8000aef4:	d9 44 00 40 	lea %a4,[%a4]256 <70000100 <__malloc_av_+0x8>>
8000aef8:	7d 45 08 80 	jne.a %a5,%a4,8000af08 <_free_r+0xd8>
8000aefc:	ec 25       	st.a [%a2]20,%a15
8000aefe:	ec 24       	st.a [%a2]16,%a15
8000af00:	e8 35       	st.a [%a15]12,%a5
8000af02:	e8 25       	st.a [%a15]8,%a5
8000af04:	82 12       	mov %d2,1
8000af06:	3c 07       	j 8000af14 <_free_r+0xe4>
8000af08:	99 33 0c 00 	ld.a %a3,[%a3]12
8000af0c:	b5 53 0c 00 	st.a [%a5]12,%a3
8000af10:	b5 35 08 00 	st.a [%a3]8,%a5
8000af14:	8f 1f 40 31 	or %d3,%d15,1
8000af18:	10 f3       	addsc.a %a3,%a15,%d15,0
8000af1a:	68 13       	st.w [%a15]4,%d3
8000af1c:	6c 30       	st.w [%a3]0,%d15
8000af1e:	df 02 c3 ff 	jne %d2,0,8000aea4 <_free_r+0x74>
8000af22:	3b 00 20 20 	mov %d2,512
8000af26:	7f 2f 12 80 	jge.u %d15,%d2,8000af4a <_free_r+0x11a>
8000af2a:	19 23 04 00 	ld.w %d3,[%a2]4
8000af2e:	06 df       	sh %d15,-3
8000af30:	8f ef 3f 20 	sha %d2,%d15,-2
8000af34:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
8000af38:	59 22 04 00 	st.w [%a2]4,%d2
8000af3c:	d0 22       	addsc.a %a2,%a2,%d15,3
8000af3e:	99 23 08 00 	ld.a %a3,[%a2]8
8000af42:	e8 32       	st.a [%a15]12,%a2
8000af44:	e8 23       	st.a [%a15]8,%a3
8000af46:	ec 22       	st.a [%a2]8,%a15
8000af48:	3c 46       	j 8000afd4 <_free_r+0x1a4>
8000af4a:	8f af 1f 30 	sh %d3,%d15,-6
8000af4e:	8f 7f 1f 20 	sh %d2,%d15,-9
8000af52:	1b 83 03 30 	addi %d3,%d3,56
8000af56:	bf 52 22 80 	jlt.u %d2,5,8000af9a <_free_r+0x16a>
8000af5a:	8b 52 a1 32 	ge.u %d3,%d2,21
8000af5e:	f6 34       	jnz %d3,8000af66 <_free_r+0x136>
8000af60:	1b b2 05 30 	addi %d3,%d2,91
8000af64:	3c 1b       	j 8000af9a <_free_r+0x16a>
8000af66:	8b 52 a5 32 	ge.u %d3,%d2,85
8000af6a:	f6 36       	jnz %d3,8000af76 <_free_r+0x146>
8000af6c:	8f 4f 1f 30 	sh %d3,%d15,-12
8000af70:	1b e3 06 30 	addi %d3,%d3,110
8000af74:	3c 13       	j 8000af9a <_free_r+0x16a>
8000af76:	8b 52 b5 32 	ge.u %d3,%d2,341
8000af7a:	f6 36       	jnz %d3,8000af86 <_free_r+0x156>
8000af7c:	8f 1f 1f 30 	sh %d3,%d15,-15
8000af80:	1b 73 07 30 	addi %d3,%d3,119
8000af84:	3c 0b       	j 8000af9a <_free_r+0x16a>
8000af86:	3b 50 55 40 	mov %d4,1365
8000af8a:	3b e0 07 30 	mov %d3,126
8000af8e:	7f 42 06 80 	jge.u %d2,%d4,8000af9a <_free_r+0x16a>
8000af92:	8f ef 1e 30 	sh %d3,%d15,-18
8000af96:	1b c3 07 30 	addi %d3,%d3,124
8000af9a:	01 23 03 66 	addsc.a %a6,%a2,%d3,3
8000af9e:	99 65 08 00 	ld.a %a5,[%a6]8
8000afa2:	40 53       	mov.aa %a3,%a5
8000afa4:	7d 65 0d 80 	jne.a %a5,%a6,8000afbe <_free_r+0x18e>
8000afa8:	4c 21       	ld.w %d15,[%a2]4
8000afaa:	86 e3       	sha %d3,-2
8000afac:	d7 1f 01 33 	insert %d3,%d15,1,%d3,1
8000afb0:	59 23 04 00 	st.w [%a2]4,%d3
8000afb4:	3c 0d       	j 8000afce <_free_r+0x19e>
8000afb6:	99 33 08 00 	ld.a %a3,[%a3]8
8000afba:	7d 63 08 00 	jeq.a %a3,%a6,8000afca <_free_r+0x19a>
8000afbe:	19 32 04 00 	ld.w %d2,[%a3]4
8000afc2:	8f 32 c0 21 	andn %d2,%d2,3
8000afc6:	3f 2f f8 ff 	jlt.u %d15,%d2,8000afb6 <_free_r+0x186>
8000afca:	99 35 0c 00 	ld.a %a5,[%a3]12
8000afce:	e8 35       	st.a [%a15]12,%a5
8000afd0:	e8 23       	st.a [%a15]8,%a3
8000afd2:	ec 52       	st.a [%a5]8,%a15
8000afd4:	ec 33       	st.a [%a3]12,%a15
8000afd6:	1d ff 67 ff 	j 8000aea4 <_free_r+0x74>
8000afda:	00 90       	ret 

8000afdc <_svfprintf_r>:
8000afdc:	20 d0       	sub.a %sp,208
8000afde:	80 5b       	mov.d %d11,%a5
8000afe0:	80 4c       	mov.d %d12,%a4
8000afe2:	b5 a6 18 00 	st.a [%sp]24,%a6
8000afe6:	40 7f       	mov.aa %a15,%a7
8000afe8:	6d 00 c4 0f 	call 8000cf70 <_localeconv_r>
8000afec:	d4 22       	ld.a %a2,[%a2]
8000afee:	40 24       	mov.aa %a4,%a2
8000aff0:	b5 a2 34 00 	st.a [%sp]52,%a2
8000aff4:	6d ff 87 fe 	call 8000ad02 <strlen>
8000aff8:	60 b2       	mov.a %a2,%d11
8000affa:	59 a2 20 00 	st.w [%sp]32,%d2
8000affe:	8c 26       	ld.h %d15,[%a2]12
8000b000:	6f 7f 16 00 	jz.t %d15,7,8000b02c <_svfprintf_r+0x50>
8000b004:	4c 24       	ld.w %d15,[%a2]16
8000b006:	ee 13       	jnz %d15,8000b02c <_svfprintf_r+0x50>
8000b008:	60 c4       	mov.a %a4,%d12
8000b00a:	3b 00 04 40 	mov %d4,64
8000b00e:	6d ff 1c fc 	call 8000a846 <_malloc_r>
8000b012:	60 b3       	mov.a %a3,%d11
8000b014:	f4 32       	st.a [%a3],%a2
8000b016:	b5 32 10 00 	st.a [%a3]16,%a2
8000b01a:	7c 26       	jnz.a %a2,8000b026 <_svfprintf_r+0x4a>
8000b01c:	60 cf       	mov.a %a15,%d12
8000b01e:	da 0c       	mov %d15,12
8000b020:	68 0f       	st.w [%a15]0,%d15
8000b022:	82 f2       	mov %d2,-1
8000b024:	00 90       	ret 
8000b026:	60 b2       	mov.a %a2,%d11
8000b028:	da 40       	mov %d15,64
8000b02a:	6c 25       	st.w [%a2]20,%d15
8000b02c:	82 0f       	mov %d15,0
8000b02e:	d9 a2 10 20 	lea %a2,[%sp]144
8000b032:	a0 03       	mov.a %a3,0
8000b034:	b5 a2 1c 10 	st.a [%sp]92,%a2
8000b038:	78 19       	st.w [%sp]100,%d15
8000b03a:	78 18       	st.w [%sp]96,%d15
8000b03c:	78 05       	st.w [%sp]20,%d15
8000b03e:	78 0b       	st.w [%sp]44,%d15
8000b040:	78 0c       	st.w [%sp]48,%d15
8000b042:	b5 a3 3c 00 	st.a [%sp]60,%a3
8000b046:	78 0e       	st.w [%sp]56,%d15
8000b048:	78 0a       	st.w [%sp]40,%d15
8000b04a:	40 2e       	mov.aa %a14,%a2
8000b04c:	99 ac 18 00 	ld.a %a12,[%sp]24
8000b050:	79 cf 00 00 	ld.b %d15,[%a12]0
8000b054:	8b 0f 20 32 	ne %d3,%d15,0
8000b058:	8b 5f 22 34 	and.ne %d3,%d15,37
8000b05c:	76 33       	jz %d3,8000b062 <_svfprintf_r+0x86>
8000b05e:	b0 1c       	add.a %a12,1
8000b060:	3c f8       	j 8000b050 <_svfprintf_r+0x74>
8000b062:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b066:	01 3c 20 30 	sub.a %a3,%a12,%a3
8000b06a:	80 3f       	mov.d %d15,%a3
8000b06c:	6e 23       	jz %d15,8000b0b2 <_svfprintf_r+0xd6>
8000b06e:	19 a3 24 10 	ld.w %d3,[%sp]100
8000b072:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b076:	42 f3       	add %d3,%d15
8000b078:	59 a3 24 10 	st.w [%sp]100,%d3
8000b07c:	19 a3 20 10 	ld.w %d3,[%sp]96
8000b080:	f4 e3       	st.a [%a14],%a3
8000b082:	c2 13       	add %d3,1
8000b084:	6c e1       	st.w [%a14]4,%d15
8000b086:	59 a3 20 10 	st.w [%sp]96,%d3
8000b08a:	8b 83 80 32 	ge %d3,%d3,8
8000b08e:	d9 ee 08 00 	lea %a14,[%a14]8
8000b092:	76 3b       	jz %d3,8000b0a8 <_svfprintf_r+0xcc>
8000b094:	60 c4       	mov.a %a4,%d12
8000b096:	60 b5       	mov.a %a5,%d11
8000b098:	d9 a6 1c 10 	lea %a6,[%sp]92
8000b09c:	6d 00 7d 12 	call 8000d596 <__ssprint_r>
8000b0a0:	df 02 69 88 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000b0a4:	d9 ae 10 20 	lea %a14,[%sp]144
8000b0a8:	19 a2 28 00 	ld.w %d2,[%sp]40
8000b0ac:	42 f2       	add %d2,%d15
8000b0ae:	59 a2 28 00 	st.w [%sp]40,%d2
8000b0b2:	79 cf 00 00 	ld.b %d15,[%a12]0
8000b0b6:	df 0f 56 08 	jeq %d15,0,8000c162 <_svfprintf_r+0x1186>
8000b0ba:	82 0f       	mov %d15,0
8000b0bc:	82 02       	mov %d2,0
8000b0be:	e9 af 01 10 	st.b [%sp]65,%d15
8000b0c2:	d9 c2 01 00 	lea %a2,[%a12]1
8000b0c6:	82 0f       	mov %d15,0
8000b0c8:	82 fe       	mov %d14,-1
8000b0ca:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b0ce:	82 0a       	mov %d10,0
8000b0d0:	79 22 00 00 	ld.b %d2,[%a2]0
8000b0d4:	d9 23 01 00 	lea %a3,[%a2]1
8000b0d8:	b5 a3 18 00 	st.a [%sp]24,%a3
8000b0dc:	59 a2 10 00 	st.w [%sp]16,%d2
8000b0e0:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b0e4:	1b 02 fe 3f 	addi %d3,%d2,-32
8000b0e8:	8b 93 a5 42 	ge.u %d4,%d3,89
8000b0ec:	df 04 19 84 	jne %d4,0,8000b91e <_svfprintf_r+0x942>
8000b0f0:	91 10 00 28 	movh.a %a2,32769
8000b0f4:	d9 22 00 4b 	lea %a2,[%a2]-20224 <8000b100 <_svfprintf_r+0x124>>
8000b0f8:	01 23 02 76 	addsc.a %a7,%a2,%d3,2
8000b0fc:	dc 07       	ji %a7
8000b0fe:	00 00       	nop 
8000b100:	1d 00 c3 00 	j 8000b286 <_svfprintf_r+0x2aa>
8000b104:	1d 00 0d 04 	j 8000b91e <_svfprintf_r+0x942>
8000b108:	1d 00 0b 04 	j 8000b91e <_svfprintf_r+0x942>
8000b10c:	1d 00 c0 00 	j 8000b28c <_svfprintf_r+0x2b0>
8000b110:	1d 00 07 04 	j 8000b91e <_svfprintf_r+0x942>
8000b114:	1d 00 05 04 	j 8000b91e <_svfprintf_r+0x942>
8000b118:	1d 00 03 04 	j 8000b91e <_svfprintf_r+0x942>
8000b11c:	1d 00 01 04 	j 8000b91e <_svfprintf_r+0x942>
8000b120:	1d 00 ff 03 	j 8000b91e <_svfprintf_r+0x942>
8000b124:	1d 00 fd 03 	j 8000b91e <_svfprintf_r+0x942>
8000b128:	1d 00 b5 00 	j 8000b292 <_svfprintf_r+0x2b6>
8000b12c:	1d 00 9c 00 	j 8000b264 <_svfprintf_r+0x288>
8000b130:	1d 00 f7 03 	j 8000b91e <_svfprintf_r+0x942>
8000b134:	1d 00 b8 00 	j 8000b2a4 <_svfprintf_r+0x2c8>
8000b138:	1d 00 b9 00 	j 8000b2aa <_svfprintf_r+0x2ce>
8000b13c:	1d 00 f1 03 	j 8000b91e <_svfprintf_r+0x942>
8000b140:	1d 00 de 00 	j 8000b2fc <_svfprintf_r+0x320>
8000b144:	1d 00 df 00 	j 8000b302 <_svfprintf_r+0x326>
8000b148:	1d 00 dd 00 	j 8000b302 <_svfprintf_r+0x326>
8000b14c:	1d 00 db 00 	j 8000b302 <_svfprintf_r+0x326>
8000b150:	1d 00 d9 00 	j 8000b302 <_svfprintf_r+0x326>
8000b154:	1d 00 d7 00 	j 8000b302 <_svfprintf_r+0x326>
8000b158:	1d 00 d5 00 	j 8000b302 <_svfprintf_r+0x326>
8000b15c:	1d 00 d3 00 	j 8000b302 <_svfprintf_r+0x326>
8000b160:	1d 00 d1 00 	j 8000b302 <_svfprintf_r+0x326>
8000b164:	1d 00 cf 00 	j 8000b302 <_svfprintf_r+0x326>
8000b168:	1d 00 db 03 	j 8000b91e <_svfprintf_r+0x942>
8000b16c:	1d 00 d9 03 	j 8000b91e <_svfprintf_r+0x942>
8000b170:	1d 00 d7 03 	j 8000b91e <_svfprintf_r+0x942>
8000b174:	1d 00 d5 03 	j 8000b91e <_svfprintf_r+0x942>
8000b178:	1d 00 d3 03 	j 8000b91e <_svfprintf_r+0x942>
8000b17c:	1d 00 d1 03 	j 8000b91e <_svfprintf_r+0x942>
8000b180:	1d 00 cf 03 	j 8000b91e <_svfprintf_r+0x942>
8000b184:	1d 00 cd 03 	j 8000b91e <_svfprintf_r+0x942>
8000b188:	1d 00 cb 03 	j 8000b91e <_svfprintf_r+0x942>
8000b18c:	1d 00 c9 03 	j 8000b91e <_svfprintf_r+0x942>
8000b190:	1d 00 f9 00 	j 8000b382 <_svfprintf_r+0x3a6>
8000b194:	1d 00 21 01 	j 8000b3d6 <_svfprintf_r+0x3fa>
8000b198:	1d 00 c3 03 	j 8000b91e <_svfprintf_r+0x942>
8000b19c:	1d 00 1d 01 	j 8000b3d6 <_svfprintf_r+0x3fa>
8000b1a0:	1d 00 bf 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1a4:	1d 00 bd 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1a8:	1d 00 bb 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1ac:	1d 00 b9 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1b0:	1d 00 c6 00 	j 8000b33c <_svfprintf_r+0x360>
8000b1b4:	1d 00 b5 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1b8:	1d 00 b3 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1bc:	1d 00 92 02 	j 8000b6e0 <_svfprintf_r+0x704>
8000b1c0:	1d 00 af 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1c4:	1d 00 ad 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1c8:	1d 00 ab 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1cc:	1d 00 a9 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1d0:	1d 00 a7 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1d4:	1d 00 d0 02 	j 8000b774 <_svfprintf_r+0x798>
8000b1d8:	1d 00 a3 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1dc:	1d 00 a1 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1e0:	1d 00 4b 00 	j 8000b276 <_svfprintf_r+0x29a>
8000b1e4:	1d 00 9d 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1e8:	1d 00 9b 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1ec:	1d 00 99 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1f0:	1d 00 97 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1f4:	1d 00 95 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1f8:	1d 00 93 03 	j 8000b91e <_svfprintf_r+0x942>
8000b1fc:	1d 00 91 03 	j 8000b91e <_svfprintf_r+0x942>
8000b200:	1d 00 8f 03 	j 8000b91e <_svfprintf_r+0x942>
8000b204:	1d 00 8d 03 	j 8000b91e <_svfprintf_r+0x942>
8000b208:	1d 00 8b 03 	j 8000b91e <_svfprintf_r+0x942>
8000b20c:	1d 00 b0 00 	j 8000b36c <_svfprintf_r+0x390>
8000b210:	1d 00 2f 00 	j 8000b26e <_svfprintf_r+0x292>
8000b214:	1d 00 e1 00 	j 8000b3d6 <_svfprintf_r+0x3fa>
8000b218:	1d 00 df 00 	j 8000b3d6 <_svfprintf_r+0x3fa>
8000b21c:	1d 00 dd 00 	j 8000b3d6 <_svfprintf_r+0x3fa>
8000b220:	1d 00 91 00 	j 8000b342 <_svfprintf_r+0x366>
8000b224:	1d 00 25 00 	j 8000b26e <_svfprintf_r+0x292>
8000b228:	1d 00 7b 03 	j 8000b91e <_svfprintf_r+0x942>
8000b22c:	1d 00 79 03 	j 8000b91e <_svfprintf_r+0x942>
8000b230:	1d 00 8c 00 	j 8000b348 <_svfprintf_r+0x36c>
8000b234:	1d 00 75 03 	j 8000b91e <_svfprintf_r+0x942>
8000b238:	1d 00 39 02 	j 8000b6aa <_svfprintf_r+0x6ce>
8000b23c:	1d 00 54 02 	j 8000b6e4 <_svfprintf_r+0x708>
8000b240:	1d 00 66 02 	j 8000b70c <_svfprintf_r+0x730>
8000b244:	1d 00 90 00 	j 8000b364 <_svfprintf_r+0x388>
8000b248:	1d 00 6b 03 	j 8000b91e <_svfprintf_r+0x942>
8000b24c:	1d 00 77 02 	j 8000b73a <_svfprintf_r+0x75e>
8000b250:	1d 00 67 03 	j 8000b91e <_svfprintf_r+0x942>
8000b254:	1d 00 92 02 	j 8000b778 <_svfprintf_r+0x79c>
8000b258:	1d 00 63 03 	j 8000b91e <_svfprintf_r+0x942>
8000b25c:	1d 00 61 03 	j 8000b91e <_svfprintf_r+0x942>
8000b260:	1d 00 a0 02 	j 8000b7a0 <_svfprintf_r+0x7c4>
8000b264:	da 2b       	mov %d15,43
8000b266:	99 a2 18 00 	ld.a %a2,[%sp]24
8000b26a:	1d ff 33 ff 	j 8000b0d0 <_svfprintf_r+0xf4>
8000b26e:	e9 af 01 10 	st.b [%sp]65,%d15
8000b272:	1d 00 8c 00 	j 8000b38a <_svfprintf_r+0x3ae>
8000b276:	e9 af 01 10 	st.b [%sp]65,%d15
8000b27a:	7b 00 00 f8 	movh %d15,32768
8000b27e:	1b 0f dd f0 	addi %d15,%d15,3536
8000b282:	1d 00 95 02 	j 8000b7ac <_svfprintf_r+0x7d0>
8000b286:	ab 0f 82 ff 	sel %d15,%d15,%d15,32
8000b28a:	3c ee       	j 8000b266 <_svfprintf_r+0x28a>
8000b28c:	8f 1a 40 a1 	or %d10,%d10,1
8000b290:	3c eb       	j 8000b266 <_svfprintf_r+0x28a>
8000b292:	48 02       	ld.w %d2,[%a15]0
8000b294:	b0 4f       	add.a %a15,4
8000b296:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b29a:	ff 02 e6 7f 	jge %d2,0,8000b266 <_svfprintf_r+0x28a>
8000b29e:	32 52       	rsub %d2
8000b2a0:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b2a4:	8f 4a 40 a1 	or %d10,%d10,4
8000b2a8:	3c df       	j 8000b266 <_svfprintf_r+0x28a>
8000b2aa:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b2ae:	99 a2 18 00 	ld.a %a2,[%sp]24
8000b2b2:	79 32 00 00 	ld.b %d2,[%a3]0
8000b2b6:	b0 12       	add.a %a2,1
8000b2b8:	59 a2 10 00 	st.w [%sp]16,%d2
8000b2bc:	8b a2 02 32 	eq %d3,%d2,42
8000b2c0:	f6 33       	jnz %d3,8000b2c6 <_svfprintf_r+0x2ea>
8000b2c2:	82 05       	mov %d5,0
8000b2c4:	3c 08       	j 8000b2d4 <_svfprintf_r+0x2f8>
8000b2c6:	48 0e       	ld.w %d14,[%a15]0
8000b2c8:	b5 a2 18 00 	st.a [%sp]24,%a2
8000b2cc:	b0 4f       	add.a %a15,4
8000b2ce:	8b fe 5f e3 	max %d14,%d14,-1
8000b2d2:	3c ca       	j 8000b266 <_svfprintf_r+0x28a>
8000b2d4:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b2d8:	1b 02 fd 3f 	addi %d3,%d2,-48
8000b2dc:	ff a3 0a 80 	jge.u %d3,10,8000b2f0 <_svfprintf_r+0x314>
8000b2e0:	79 22 00 00 	ld.b %d2,[%a2]0
8000b2e4:	13 a5 20 53 	madd %d5,%d3,%d5,10
8000b2e8:	59 a2 10 00 	st.w [%sp]16,%d2
8000b2ec:	b0 12       	add.a %a2,1
8000b2ee:	3c f3       	j 8000b2d4 <_svfprintf_r+0x2f8>
8000b2f0:	8b f5 5f e3 	max %d14,%d5,-1
8000b2f4:	b5 a2 18 00 	st.a [%sp]24,%a2
8000b2f8:	1d ff f4 fe 	j 8000b0e0 <_svfprintf_r+0x104>
8000b2fc:	8f 0a 48 a1 	or %d10,%d10,128
8000b300:	3c b3       	j 8000b266 <_svfprintf_r+0x28a>
8000b302:	82 02       	mov %d2,0
8000b304:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b308:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b30c:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b310:	1b 02 fd 4f 	addi %d4,%d2,-48
8000b314:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000b318:	99 a2 18 00 	ld.a %a2,[%sp]24
8000b31c:	13 a2 20 24 	madd %d2,%d4,%d2,10
8000b320:	b0 12       	add.a %a2,1
8000b322:	59 a2 1c 00 	st.w [%sp]28,%d2
8000b326:	79 32 00 00 	ld.b %d2,[%a3]0
8000b32a:	b5 a2 18 00 	st.a [%sp]24,%a2
8000b32e:	59 a2 10 00 	st.w [%sp]16,%d2
8000b332:	1b 02 fd 4f 	addi %d4,%d2,-48
8000b336:	bf a4 e9 ff 	jlt.u %d4,10,8000b308 <_svfprintf_r+0x32c>
8000b33a:	3c dd       	j 8000b2f4 <_svfprintf_r+0x318>
8000b33c:	8f 8a 40 a1 	or %d10,%d10,8
8000b340:	3c 93       	j 8000b266 <_svfprintf_r+0x28a>
8000b342:	8f 0a 44 a1 	or %d10,%d10,64
8000b346:	3c 90       	j 8000b266 <_svfprintf_r+0x28a>
8000b348:	99 a3 18 00 	ld.a %a3,[%sp]24
8000b34c:	79 33 00 00 	ld.b %d3,[%a3]0
8000b350:	8b c3 26 32 	ne %d3,%d3,108
8000b354:	f6 35       	jnz %d3,8000b35e <_svfprintf_r+0x382>
8000b356:	b0 13       	add.a %a3,1
8000b358:	b5 a3 18 00 	st.a [%sp]24,%a3
8000b35c:	3c 04       	j 8000b364 <_svfprintf_r+0x388>
8000b35e:	8f 0a 41 a1 	or %d10,%d10,16
8000b362:	3c 82       	j 8000b266 <_svfprintf_r+0x28a>
8000b364:	8f 0a 42 a1 	or %d10,%d10,32
8000b368:	1d ff 7f ff 	j 8000b266 <_svfprintf_r+0x28a>
8000b36c:	48 03       	ld.w %d3,[%a15]0
8000b36e:	d9 fc 04 00 	lea %a12,[%a15]4
8000b372:	e9 a3 28 10 	st.b [%sp]104,%d3
8000b376:	82 03       	mov %d3,0
8000b378:	e9 a3 01 10 	st.b [%sp]65,%d3
8000b37c:	60 ad       	mov.a %a13,%d10
8000b37e:	1d 00 dc 02 	j 8000b936 <_svfprintf_r+0x95a>
8000b382:	e9 af 01 10 	st.b [%sp]65,%d15
8000b386:	8f 0a 41 a1 	or %d10,%d10,16
8000b38a:	60 ad       	mov.a %a13,%d10
8000b38c:	6f 5a 07 00 	jz.t %d10,5,8000b39a <_svfprintf_r+0x3be>
8000b390:	d9 fc 08 00 	lea %a12,[%a15]8
8000b394:	09 f8 40 09 	ld.d %e8,[%a15]
8000b398:	3c 12       	j 8000b3bc <_svfprintf_r+0x3e0>
8000b39a:	d9 f2 04 00 	lea %a2,[%a15]4
8000b39e:	6f 4a 05 00 	jz.t %d10,4,8000b3a8 <_svfprintf_r+0x3cc>
8000b3a2:	40 2c       	mov.aa %a12,%a2
8000b3a4:	48 08       	ld.w %d8,[%a15]0
8000b3a6:	3c 09       	j 8000b3b8 <_svfprintf_r+0x3dc>
8000b3a8:	48 03       	ld.w %d3,[%a15]0
8000b3aa:	40 2c       	mov.aa %a12,%a2
8000b3ac:	0b 30 00 88 	mov %e8,%d3
8000b3b0:	6f 6a 06 00 	jz.t %d10,6,8000b3bc <_svfprintf_r+0x3e0>
8000b3b4:	37 03 50 80 	extr %d8,%d3,0,16
8000b3b8:	0b 80 00 88 	mov %e8,%d8
8000b3bc:	82 13       	mov %d3,1
8000b3be:	ff 09 1d 02 	jge %d9,0,8000b7f8 <_svfprintf_r+0x81c>
8000b3c2:	32 59       	rsub %d9
8000b3c4:	32 58       	rsub %d8
8000b3c6:	3b d0 02 70 	mov %d7,45
8000b3ca:	ab f9 1f 98 	cadd %d9,%d8,%d9,-1
8000b3ce:	e9 a7 01 10 	st.b [%sp]65,%d7
8000b3d2:	1d 00 13 02 	j 8000b7f8 <_svfprintf_r+0x81c>
8000b3d6:	e9 af 01 10 	st.b [%sp]65,%d15
8000b3da:	4c f0       	ld.w %d15,[%a15]0
8000b3dc:	d9 fc 08 00 	lea %a12,[%a15]8
8000b3e0:	78 0b       	st.w [%sp]44,%d15
8000b3e2:	4c f1       	ld.w %d15,[%a15]4
8000b3e4:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000b3e8:	78 0c       	st.w [%sp]48,%d15
8000b3ea:	19 a5 30 00 	ld.w %d5,[%sp]48
8000b3ee:	6d 00 b3 10 	call 8000d554 <__fpclassifyd>
8000b3f2:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000b3f6:	19 a5 30 00 	ld.w %d5,[%sp]48
8000b3fa:	df 12 18 80 	jne %d2,1,8000b42a <_svfprintf_r+0x44e>
8000b3fe:	d2 06       	mov %e6,0
8000b400:	6d 00 50 14 	call 8000dca0 <__ltdf2>
8000b404:	ce 25       	jgez %d2,8000b40e <_svfprintf_r+0x432>
8000b406:	3b d0 02 30 	mov %d3,45
8000b40a:	e9 a3 01 10 	st.b [%sp]65,%d3
8000b40e:	58 04       	ld.w %d15,[%sp]16
8000b410:	7b 00 00 78 	movh %d7,32768
8000b414:	8b 8f 84 32 	ge %d3,%d15,72
8000b418:	1b 47 dc d0 	addi %d13,%d7,3524
8000b41c:	df 03 17 80 	jne %d3,0,8000b44a <_svfprintf_r+0x46e>
8000b420:	7b 00 00 78 	movh %d7,32768
8000b424:	1b 07 dc d0 	addi %d13,%d7,3520
8000b428:	3c 11       	j 8000b44a <_svfprintf_r+0x46e>
8000b42a:	6d 00 95 10 	call 8000d554 <__fpclassifyd>
8000b42e:	58 04       	ld.w %d15,[%sp]16
8000b430:	df 02 13 80 	jne %d2,0,8000b456 <_svfprintf_r+0x47a>
8000b434:	7b 00 00 78 	movh %d7,32768
8000b438:	8b 8f 84 32 	ge %d3,%d15,72
8000b43c:	1b c7 dc d0 	addi %d13,%d7,3532
8000b440:	f6 35       	jnz %d3,8000b44a <_svfprintf_r+0x46e>
8000b442:	7b 00 00 78 	movh %d7,32768
8000b446:	1b 87 dc d0 	addi %d13,%d7,3528
8000b44a:	8f 0a c8 a1 	andn %d10,%d10,128
8000b44e:	60 ad       	mov.a %a13,%d10
8000b450:	82 39       	mov %d9,3
8000b452:	1d 00 78 02 	j 8000b942 <_svfprintf_r+0x966>
8000b456:	8f 0f c2 f1 	andn %d15,%d15,32
8000b45a:	78 01       	st.w [%sp]4,%d15
8000b45c:	df fe 09 00 	jeq %d14,-1,8000b46e <_svfprintf_r+0x492>
8000b460:	8b 0e 00 72 	eq %d7,%d14,0
8000b464:	8b 7f 04 74 	and.eq %d7,%d15,71
8000b468:	ab 1e a0 e7 	seln %d14,%d7,%d14,1
8000b46c:	3c 02       	j 8000b470 <_svfprintf_r+0x494>
8000b46e:	82 6e       	mov %d14,6
8000b470:	19 a3 30 00 	ld.w %d3,[%sp]48
8000b474:	8f 0a 50 21 	or %d2,%d10,256
8000b478:	60 2d       	mov.a %a13,%d2
8000b47a:	d8 0b       	ld.a %a15,[%sp]44
8000b47c:	82 0f       	mov %d15,0
8000b47e:	ce 34       	jgez %d3,8000b486 <_svfprintf_r+0x4aa>
8000b480:	9b 03 00 38 	addih %d3,%d3,32768
8000b484:	da 2d       	mov %d15,45
8000b486:	78 09       	st.w [%sp]36,%d15
8000b488:	58 01       	ld.w %d15,[%sp]4
8000b48a:	02 e9       	mov %d9,%d14
8000b48c:	8b 6f 04 22 	eq %d2,%d15,70
8000b490:	82 36       	mov %d6,3
8000b492:	f6 28       	jnz %d2,8000b4a2 <_svfprintf_r+0x4c6>
8000b494:	8b 5f 24 12 	ne %d1,%d15,69
8000b498:	1b 1e 00 50 	addi %d5,%d14,1
8000b49c:	82 26       	mov %d6,2
8000b49e:	2b e5 50 91 	seln %d9,%d1,%d5,%d14
8000b4a2:	60 c4       	mov.a %a4,%d12
8000b4a4:	80 f4       	mov.d %d4,%a15
8000b4a6:	02 35       	mov %d5,%d3
8000b4a8:	02 97       	mov %d7,%d9
8000b4aa:	d9 a5 04 10 	lea %a5,[%sp]68
8000b4ae:	d9 a6 08 10 	lea %a6,[%sp]72
8000b4b2:	d9 a7 14 10 	lea %a7,[%sp]84
8000b4b6:	59 a2 0c 00 	st.w [%sp]12,%d2
8000b4ba:	59 a3 08 00 	st.w [%sp]8,%d3
8000b4be:	6d 00 ef 06 	call 8000c29c <_dtoa_r>
8000b4c2:	58 01       	ld.w %d15,[%sp]4
8000b4c4:	80 2d       	mov.d %d13,%a2
8000b4c6:	8b 7f 24 12 	ne %d1,%d15,71
8000b4ca:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000b4ce:	19 a3 08 00 	ld.w %d3,[%sp]8
8000b4d2:	df 01 11 80 	jne %d1,0,8000b4f4 <_svfprintf_r+0x518>
8000b4d6:	6f 0a 0f 80 	jnz.t %d10,0,8000b4f4 <_svfprintf_r+0x518>
8000b4da:	19 a2 14 10 	ld.w %d2,[%sp]84
8000b4de:	58 01       	ld.w %d15,[%sp]4
8000b4e0:	a2 d2       	sub %d2,%d13
8000b4e2:	59 a2 14 00 	st.w [%sp]20,%d2
8000b4e6:	8b 7f 04 42 	eq %d4,%d15,71
8000b4ea:	19 a5 04 10 	ld.w %d5,[%sp]68
8000b4ee:	df 04 36 80 	jne %d4,0,8000b55a <_svfprintf_r+0x57e>
8000b4f2:	3c 3e       	j 8000b56e <_svfprintf_r+0x592>
8000b4f4:	0b 9d 00 80 	add %d8,%d13,%d9
8000b4f8:	df 02 1c 00 	jeq %d2,0,8000b530 <_svfprintf_r+0x554>
8000b4fc:	60 d2       	mov.a %a2,%d13
8000b4fe:	80 f4       	mov.d %d4,%a15
8000b500:	79 20 00 00 	ld.b %d0,[%a2]0
8000b504:	d2 06       	mov %e6,0
8000b506:	02 35       	mov %d5,%d3
8000b508:	8b 00 03 f2 	eq %d15,%d0,48
8000b50c:	59 a3 08 00 	st.w [%sp]8,%d3
8000b510:	6d 00 68 13 	call 8000dbe0 <__nedf2>
8000b514:	8b 02 20 22 	ne %d2,%d2,0
8000b518:	0f 2f 80 00 	and %d0,%d15,%d2
8000b51c:	19 a3 08 00 	ld.w %d3,[%sp]8
8000b520:	76 05       	jz %d0,8000b52a <_svfprintf_r+0x54e>
8000b522:	8b 19 00 01 	rsub %d0,%d9,1
8000b526:	59 a0 04 10 	st.w [%sp]68,%d0
8000b52a:	19 a2 04 10 	ld.w %d2,[%sp]68
8000b52e:	42 28       	add %d8,%d2
8000b530:	80 f4       	mov.d %d4,%a15
8000b532:	d2 06       	mov %e6,0
8000b534:	02 35       	mov %d5,%d3
8000b536:	6d 00 35 13 	call 8000dba0 <__eqdf2>
8000b53a:	f6 23       	jnz %d2,8000b540 <_svfprintf_r+0x564>
8000b53c:	59 a8 14 10 	st.w [%sp]84,%d8
8000b540:	3b 00 03 00 	mov %d0,48
8000b544:	19 a3 14 10 	ld.w %d3,[%sp]84
8000b548:	7f 83 c9 ff 	jge.u %d3,%d8,8000b4da <_svfprintf_r+0x4fe>
8000b54c:	1b 13 00 10 	addi %d1,%d3,1
8000b550:	60 32       	mov.a %a2,%d3
8000b552:	59 a1 14 10 	st.w [%sp]84,%d1
8000b556:	34 20       	st.b [%a2],%d0
8000b558:	3c f6       	j 8000b544 <_svfprintf_r+0x568>
8000b55a:	0b 5e 20 31 	lt %d3,%d14,%d5
8000b55e:	8b d5 3f 35 	or.lt %d3,%d5,-3
8000b562:	df 03 88 00 	jeq %d3,0,8000b672 <_svfprintf_r+0x696>
8000b566:	58 04       	ld.w %d15,[%sp]16
8000b568:	c2 ef       	add %d15,-2
8000b56a:	78 04       	st.w [%sp]16,%d15
8000b56c:	3c 06       	j 8000b578 <_svfprintf_r+0x59c>
8000b56e:	58 04       	ld.w %d15,[%sp]16
8000b570:	8b 6f 86 32 	ge %d3,%d15,102
8000b574:	df 03 69 80 	jne %d3,0,8000b646 <_svfprintf_r+0x66a>
8000b578:	19 a2 10 00 	ld.w %d2,[%sp]16
8000b57c:	9a f5       	add %d15,%d5,-1
8000b57e:	78 11       	st.w [%sp]68,%d15
8000b580:	e9 a2 0d 10 	st.b [%sp]77,%d2
8000b584:	3b b0 02 30 	mov %d3,43
8000b588:	ce f4       	jgez %d15,8000b590 <_svfprintf_r+0x5b4>
8000b58a:	32 5f       	rsub %d15
8000b58c:	3b d0 02 30 	mov %d3,45
8000b590:	e9 a3 0e 10 	st.b [%sp]78,%d3
8000b594:	8b af 40 32 	lt %d3,%d15,10
8000b598:	df 03 3e 80 	jne %d3,0,8000b614 <_svfprintf_r+0x638>
8000b59c:	82 06       	mov %d6,0
8000b59e:	3b a0 00 00 	mov %d0,10
8000b5a2:	4b 0f 01 42 	div %e4,%d15,%d0
8000b5a6:	8b 66 00 71 	rsub %d7,%d6,6
8000b5aa:	60 72       	mov.a %a2,%d7
8000b5ac:	d9 af 14 10 	lea %a15,[%sp]84
8000b5b0:	1b 05 03 30 	addi %d3,%d5,48
8000b5b4:	30 2f       	add.a %a15,%a2
8000b5b6:	28 03       	st.b [%a15]0,%d3
8000b5b8:	8b a4 80 32 	ge %d3,%d4,10
8000b5bc:	02 4f       	mov %d15,%d4
8000b5be:	c2 16       	add %d6,1
8000b5c0:	df 03 f1 ff 	jne %d3,0,8000b5a2 <_svfprintf_r+0x5c6>
8000b5c4:	60 74       	mov.a %a4,%d7
8000b5c6:	d9 a2 10 30 	lea %a2,[%sp]208
8000b5ca:	1b 04 03 f0 	addi %d15,%d4,48
8000b5ce:	30 42       	add.a %a2,%a4
8000b5d0:	d9 f7 ff ff 	lea %a7,[%a15]-1
8000b5d4:	e9 ff ff ff 	st.b [%a15]-1,%d15
8000b5d8:	80 22       	mov.d %d2,%a2
8000b5da:	d9 af 1b 10 	lea %a15,[%sp]91
8000b5de:	80 ff       	mov.d %d15,%a15
8000b5e0:	1b 32 f8 4f 	addi %d4,%d2,-125
8000b5e4:	82 03       	mov %d3,0
8000b5e6:	01 7f 20 30 	sub.a %a3,%a15,%a7
8000b5ea:	3f 4f 08 80 	jlt.u %d15,%d4,8000b5fa <_svfprintf_r+0x61e>
8000b5ee:	80 a2       	mov.d %d2,%sp
8000b5f0:	1b 02 0d 20 	addi %d2,%d2,208
8000b5f4:	8b 52 07 42 	eq %d4,%d2,117
8000b5f8:	76 46       	jz %d4,8000b604 <_svfprintf_r+0x628>
8000b5fa:	a0 03       	mov.a %a3,0
8000b5fc:	3c 04       	j 8000b604 <_svfprintf_r+0x628>
8000b5fe:	0c 70       	ld.bu %d15,[%a7]0
8000b600:	b0 17       	add.a %a7,1
8000b602:	28 0f       	st.b [%a15]0,%d15
8000b604:	60 3f       	mov.a %a15,%d3
8000b606:	d9 a2 0d 10 	lea %a2,[%sp]77
8000b60a:	b0 2f       	add.a %a15,2
8000b60c:	30 2f       	add.a %a15,%a2
8000b60e:	c2 13       	add %d3,1
8000b610:	fc 37       	loop %a3,8000b5fe <_svfprintf_r+0x622>
8000b612:	3c 0b       	j 8000b628 <_svfprintf_r+0x64c>
8000b614:	3b 00 03 30 	mov %d3,48
8000b618:	1b 0f 03 f0 	addi %d15,%d15,48
8000b61c:	e9 a3 0f 10 	st.b [%sp]79,%d3
8000b620:	e9 af 10 10 	st.b [%sp]80,%d15
8000b624:	d9 af 11 10 	lea %a15,[%sp]81
8000b628:	d9 a7 0d 10 	lea %a7,[%sp]77
8000b62c:	01 7f 20 70 	sub.a %a7,%a15,%a7
8000b630:	80 79       	mov.d %d9,%a7
8000b632:	58 05       	ld.w %d15,[%sp]20
8000b634:	b5 a7 38 00 	st.a [%sp]56,%a7
8000b638:	42 f9       	add %d9,%d15
8000b63a:	ff 2f 04 00 	jge %d15,2,8000b642 <_svfprintf_r+0x666>
8000b63e:	6f 0a 2c 00 	jz.t %d10,0,8000b696 <_svfprintf_r+0x6ba>
8000b642:	c2 19       	add %d9,1
8000b644:	3c 29       	j 8000b696 <_svfprintf_r+0x6ba>
8000b646:	58 04       	ld.w %d15,[%sp]16
8000b648:	8b 6f 26 42 	ne %d4,%d15,102
8000b64c:	df 04 15 80 	jne %d4,0,8000b676 <_svfprintf_r+0x69a>
8000b650:	02 59       	mov %d9,%d5
8000b652:	8e 59       	jlez %d5,8000b664 <_svfprintf_r+0x688>
8000b654:	f6 e3       	jnz %d14,8000b65a <_svfprintf_r+0x67e>
8000b656:	6f 0a 20 00 	jz.t %d10,0,8000b696 <_svfprintf_r+0x6ba>
8000b65a:	1b 1e 00 30 	addi %d3,%d14,1
8000b65e:	0b 35 00 90 	add %d9,%d5,%d3
8000b662:	3c 1a       	j 8000b696 <_svfprintf_r+0x6ba>
8000b664:	f6 e4       	jnz %d14,8000b66c <_svfprintf_r+0x690>
8000b666:	82 19       	mov %d9,1
8000b668:	6f 0a 17 00 	jz.t %d10,0,8000b696 <_svfprintf_r+0x6ba>
8000b66c:	1b 2e 00 90 	addi %d9,%d14,2
8000b670:	3c 13       	j 8000b696 <_svfprintf_r+0x6ba>
8000b672:	da 67       	mov %d15,103
8000b674:	78 04       	st.w [%sp]16,%d15
8000b676:	58 05       	ld.w %d15,[%sp]20
8000b678:	8f 1a 00 a1 	and %d10,%d10,1
8000b67c:	0b a5 00 90 	add %d9,%d5,%d10
8000b680:	7f f5 0b 00 	jge %d5,%d15,8000b696 <_svfprintf_r+0x6ba>
8000b684:	8b 15 40 92 	lt %d9,%d5,1
8000b688:	8b 25 00 31 	rsub %d3,%d5,2
8000b68c:	ab 13 80 39 	sel %d3,%d9,%d3,1
8000b690:	19 a9 14 00 	ld.w %d9,[%sp]20
8000b694:	42 39       	add %d9,%d3
8000b696:	58 09       	ld.w %d15,[%sp]36
8000b698:	82 0e       	mov %d14,0
8000b69a:	df 0f 55 01 	jeq %d15,0,8000b944 <_svfprintf_r+0x968>
8000b69e:	3b d0 02 70 	mov %d7,45
8000b6a2:	e9 a7 01 10 	st.b [%sp]65,%d7
8000b6a6:	1d 00 4f 01 	j 8000b944 <_svfprintf_r+0x968>
8000b6aa:	e9 af 01 10 	st.b [%sp]65,%d15
8000b6ae:	d9 f2 04 00 	lea %a2,[%a15]4
8000b6b2:	6f 5a 09 00 	jz.t %d10,5,8000b6c4 <_svfprintf_r+0x6e8>
8000b6b6:	58 0a       	ld.w %d15,[%sp]40
8000b6b8:	c8 03       	ld.a %a3,[%a15]0
8000b6ba:	0b f0 00 48 	mov %e4,%d15
8000b6be:	89 34 40 09 	st.d [%a3],%e4
8000b6c2:	3c 0c       	j 8000b6da <_svfprintf_r+0x6fe>
8000b6c4:	6f 4a 08 80 	jnz.t %d10,4,8000b6d4 <_svfprintf_r+0x6f8>
8000b6c8:	6f 6a 06 00 	jz.t %d10,6,8000b6d4 <_svfprintf_r+0x6f8>
8000b6cc:	c8 03       	ld.a %a3,[%a15]0
8000b6ce:	58 0a       	ld.w %d15,[%sp]40
8000b6d0:	ac 30       	st.h [%a3]0,%d15
8000b6d2:	3c 04       	j 8000b6da <_svfprintf_r+0x6fe>
8000b6d4:	c8 03       	ld.a %a3,[%a15]0
8000b6d6:	58 0a       	ld.w %d15,[%sp]40
8000b6d8:	6c 30       	st.w [%a3]0,%d15
8000b6da:	40 2f       	mov.aa %a15,%a2
8000b6dc:	1d ff b8 fc 	j 8000b04c <_svfprintf_r+0x70>
8000b6e0:	8f 0a 41 a1 	or %d10,%d10,16
8000b6e4:	6f 5a 07 00 	jz.t %d10,5,8000b6f2 <_svfprintf_r+0x716>
8000b6e8:	d9 fc 08 00 	lea %a12,[%a15]8
8000b6ec:	09 f8 40 09 	ld.d %e8,[%a15]
8000b6f0:	3c 0c       	j 8000b708 <_svfprintf_r+0x72c>
8000b6f2:	d9 fc 04 00 	lea %a12,[%a15]4
8000b6f6:	6f 4a 07 80 	jnz.t %d10,4,8000b704 <_svfprintf_r+0x728>
8000b6fa:	6f 6a 05 00 	jz.t %d10,6,8000b704 <_svfprintf_r+0x728>
8000b6fe:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000b702:	3c 02       	j 8000b706 <_svfprintf_r+0x72a>
8000b704:	48 08       	ld.w %d8,[%a15]0
8000b706:	82 09       	mov %d9,0
8000b708:	82 03       	mov %d3,0
8000b70a:	3c 73       	j 8000b7f0 <_svfprintf_r+0x814>
8000b70c:	3b 00 03 40 	mov %d4,48
8000b710:	7b 00 00 f8 	movh %d15,32768
8000b714:	1b 1f de f0 	addi %d15,%d15,3553
8000b718:	e9 a4 02 10 	st.b [%sp]66,%d4
8000b71c:	3b 80 07 40 	mov %d4,120
8000b720:	78 0f       	st.w [%sp]60,%d15
8000b722:	02 4f       	mov %d15,%d4
8000b724:	d9 fc 04 00 	lea %a12,[%a15]4
8000b728:	48 08       	ld.w %d8,[%a15]0
8000b72a:	82 09       	mov %d9,0
8000b72c:	8f 2a 40 a1 	or %d10,%d10,2
8000b730:	e9 a4 03 10 	st.b [%sp]67,%d4
8000b734:	82 23       	mov %d3,2
8000b736:	78 04       	st.w [%sp]16,%d15
8000b738:	3c 5c       	j 8000b7f0 <_svfprintf_r+0x814>
8000b73a:	82 07       	mov %d7,0
8000b73c:	48 0d       	ld.w %d13,[%a15]0
8000b73e:	e9 a7 01 10 	st.b [%sp]65,%d7
8000b742:	02 e9       	mov %d9,%d14
8000b744:	60 ad       	mov.a %a13,%d10
8000b746:	d9 fc 04 00 	lea %a12,[%a15]4
8000b74a:	60 d4       	mov.a %a4,%d13
8000b74c:	0e ef       	jltz %d14,8000b76a <_svfprintf_r+0x78e>
8000b74e:	82 04       	mov %d4,0
8000b750:	02 e5       	mov %d5,%d14
8000b752:	6d 00 14 0c 	call 8000cf7a <memchr>
8000b756:	bd 02 f6 00 	jz.a %a2,8000b942 <_svfprintf_r+0x966>
8000b75a:	60 d4       	mov.a %a4,%d13
8000b75c:	01 42 20 30 	sub.a %a3,%a2,%a4
8000b760:	80 32       	mov.d %d2,%a3
8000b762:	0b e2 80 91 	min %d9,%d2,%d14
8000b766:	1d 00 ee 00 	j 8000b942 <_svfprintf_r+0x966>
8000b76a:	6d ff cc fa 	call 8000ad02 <strlen>
8000b76e:	02 29       	mov %d9,%d2
8000b770:	1d 00 e9 00 	j 8000b942 <_svfprintf_r+0x966>
8000b774:	8f 0a 41 a1 	or %d10,%d10,16
8000b778:	6f 5a 07 00 	jz.t %d10,5,8000b786 <_svfprintf_r+0x7aa>
8000b77c:	d9 fc 08 00 	lea %a12,[%a15]8
8000b780:	09 f8 40 09 	ld.d %e8,[%a15]
8000b784:	3c 0c       	j 8000b79c <_svfprintf_r+0x7c0>
8000b786:	d9 fc 04 00 	lea %a12,[%a15]4
8000b78a:	6f 4a 07 80 	jnz.t %d10,4,8000b798 <_svfprintf_r+0x7bc>
8000b78e:	6f 6a 05 00 	jz.t %d10,6,8000b798 <_svfprintf_r+0x7bc>
8000b792:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000b796:	3c 02       	j 8000b79a <_svfprintf_r+0x7be>
8000b798:	48 08       	ld.w %d8,[%a15]0
8000b79a:	82 09       	mov %d9,0
8000b79c:	82 13       	mov %d3,1
8000b79e:	3c 29       	j 8000b7f0 <_svfprintf_r+0x814>
8000b7a0:	e9 af 01 10 	st.b [%sp]65,%d15
8000b7a4:	7b 00 00 f8 	movh %d15,32768
8000b7a8:	1b 1f de f0 	addi %d15,%d15,3553
8000b7ac:	78 0f       	st.w [%sp]60,%d15
8000b7ae:	6f 5a 07 00 	jz.t %d10,5,8000b7bc <_svfprintf_r+0x7e0>
8000b7b2:	d9 fc 08 00 	lea %a12,[%a15]8
8000b7b6:	09 f8 40 09 	ld.d %e8,[%a15]
8000b7ba:	3c 0c       	j 8000b7d2 <_svfprintf_r+0x7f6>
8000b7bc:	d9 fc 04 00 	lea %a12,[%a15]4
8000b7c0:	6f 4a 07 80 	jnz.t %d10,4,8000b7ce <_svfprintf_r+0x7f2>
8000b7c4:	6f 6a 05 00 	jz.t %d10,6,8000b7ce <_svfprintf_r+0x7f2>
8000b7c8:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000b7cc:	3c 02       	j 8000b7d0 <_svfprintf_r+0x7f4>
8000b7ce:	48 08       	ld.w %d8,[%a15]0
8000b7d0:	82 09       	mov %d9,0
8000b7d2:	82 23       	mov %d3,2
8000b7d4:	6f 0a 0e 00 	jz.t %d10,0,8000b7f0 <_svfprintf_r+0x814>
8000b7d8:	0f 89 a0 40 	or %d4,%d9,%d8
8000b7dc:	76 4a       	jz %d4,8000b7f0 <_svfprintf_r+0x814>
8000b7de:	58 04       	ld.w %d15,[%sp]16
8000b7e0:	3b 00 03 70 	mov %d7,48
8000b7e4:	e9 a7 02 10 	st.b [%sp]66,%d7
8000b7e8:	e9 af 03 10 	st.b [%sp]67,%d15
8000b7ec:	8f 2a 40 a1 	or %d10,%d10,2
8000b7f0:	82 07       	mov %d7,0
8000b7f2:	60 ad       	mov.a %a13,%d10
8000b7f4:	e9 a7 01 10 	st.b [%sp]65,%d7
8000b7f8:	80 d2       	mov.d %d2,%a13
8000b7fa:	8b 0e 80 72 	ge %d7,%d14,0
8000b7fe:	8f 02 c8 41 	andn %d4,%d2,128
8000b802:	2b 24 40 27 	sel %d2,%d7,%d4,%d2
8000b806:	0f 98 a0 60 	or %d6,%d8,%d9
8000b80a:	8b 0e 20 42 	ne %d4,%d14,0
8000b80e:	8b 06 00 45 	or.ne %d4,%d6,0
8000b812:	60 2d       	mov.a %a13,%d2
8000b814:	df 04 72 00 	jeq %d4,0,8000b8f8 <_svfprintf_r+0x91c>
8000b818:	df 13 06 00 	jeq %d3,1,8000b824 <_svfprintf_r+0x848>
8000b81c:	df 23 57 00 	jeq %d3,2,8000b8ca <_svfprintf_r+0x8ee>
8000b820:	82 03       	mov %d3,0
8000b822:	3c 03       	j 8000b828 <_svfprintf_r+0x84c>
8000b824:	82 04       	mov %d4,0
8000b826:	3c 22       	j 8000b86a <_svfprintf_r+0x88e>
8000b828:	8b 73 02 71 	rsub %d7,%d3,39
8000b82c:	60 72       	mov.a %a2,%d7
8000b82e:	8f 78 00 41 	and %d4,%d8,7
8000b832:	d9 a3 28 10 	lea %a3,[%sp]104
8000b836:	77 89 80 8e 	dextr %d8,%d9,%d8,29
8000b83a:	30 23       	add.a %a3,%a2
8000b83c:	1b 04 03 40 	addi %d4,%d4,48
8000b840:	06 d9       	sh %d9,-3
8000b842:	34 34       	st.b [%a3],%d4
8000b844:	0f 89 a0 60 	or %d6,%d9,%d8
8000b848:	c2 13       	add %d3,1
8000b84a:	df 06 ef ff 	jne %d6,0,8000b828 <_svfprintf_r+0x84c>
8000b84e:	80 d2       	mov.d %d2,%a13
8000b850:	80 3d       	mov.d %d13,%a3
8000b852:	6f 02 61 00 	jz.t %d2,0,8000b914 <_svfprintf_r+0x938>
8000b856:	8b 04 03 42 	eq %d4,%d4,48
8000b85a:	df 04 5d 80 	jne %d4,0,8000b914 <_svfprintf_r+0x938>
8000b85e:	3b 00 03 70 	mov %d7,48
8000b862:	c2 fd       	add %d13,-1
8000b864:	e9 37 ff ff 	st.b [%a3]-1,%d7
8000b868:	3c 56       	j 8000b914 <_svfprintf_r+0x938>
8000b86a:	8b 84 02 71 	rsub %d7,%d4,40
8000b86e:	8b 09 00 32 	eq %d3,%d9,0
8000b872:	60 73       	mov.a %a3,%d7
8000b874:	8b a8 a0 34 	and.ge.u %d3,%d8,10
8000b878:	d9 a7 28 10 	lea %a7,[%sp]104
8000b87c:	8b 09 00 35 	or.ne %d3,%d9,0
8000b880:	30 37       	add.a %a7,%a3
8000b882:	1b 14 00 d0 	addi %d13,%d4,1
8000b886:	df 03 1b 00 	jeq %d3,0,8000b8bc <_svfprintf_r+0x8e0>
8000b88a:	8b 74 02 41 	rsub %d4,%d4,39
8000b88e:	60 42       	mov.a %a2,%d4
8000b890:	fb a0 00 60 	mov %e6,10
8000b894:	0b 89 10 48 	mov %e4,%d9,%d8
8000b898:	d9 af 28 10 	lea %a15,[%sp]104
8000b89c:	30 2f       	add.a %a15,%a2
8000b89e:	6d 00 98 12 	call 8000ddce <__umoddi3>
8000b8a2:	0b 89 10 48 	mov %e4,%d9,%d8
8000b8a6:	1b 02 03 20 	addi %d2,%d2,48
8000b8aa:	fb a0 00 60 	mov %e6,10
8000b8ae:	28 02       	st.b [%a15]0,%d2
8000b8b0:	6d 00 3f 12 	call 8000dd2e <__udivdi3>
8000b8b4:	02 d4       	mov %d4,%d13
8000b8b6:	0b 23 10 88 	mov %e8,%d3,%d2
8000b8ba:	3c d8       	j 8000b86a <_svfprintf_r+0x88e>
8000b8bc:	80 7d       	mov.d %d13,%a7
8000b8be:	1b 08 03 80 	addi %d8,%d8,48
8000b8c2:	c2 fd       	add %d13,-1
8000b8c4:	e9 78 ff ff 	st.b [%a7]-1,%d8
8000b8c8:	3c 26       	j 8000b914 <_svfprintf_r+0x938>
8000b8ca:	82 03       	mov %d3,0
8000b8cc:	d8 0f       	ld.a %a15,[%sp]60
8000b8ce:	80 ad       	mov.d %d13,%sp
8000b8d0:	8f f8 00 f1 	and %d15,%d8,15
8000b8d4:	8b 73 02 71 	rsub %d7,%d3,39
8000b8d8:	1b 8d 06 d0 	addi %d13,%d13,104
8000b8dc:	10 f7       	addsc.a %a7,%a15,%d15,0
8000b8de:	42 7d       	add %d13,%d7
8000b8e0:	77 89 00 8e 	dextr %d8,%d9,%d8,28
8000b8e4:	0c 70       	ld.bu %d15,[%a7]0
8000b8e6:	60 d2       	mov.a %a2,%d13
8000b8e8:	06 c9       	sh %d9,-4
8000b8ea:	2c 20       	st.b [%a2]0,%d15
8000b8ec:	0f 89 a0 40 	or %d4,%d9,%d8
8000b8f0:	c2 13       	add %d3,1
8000b8f2:	df 04 ed ff 	jne %d4,0,8000b8cc <_svfprintf_r+0x8f0>
8000b8f6:	3c 0f       	j 8000b914 <_svfprintf_r+0x938>
8000b8f8:	80 a2       	mov.d %d2,%sp
8000b8fa:	1b 02 09 d0 	addi %d13,%d2,144
8000b8fe:	f6 3b       	jnz %d3,8000b914 <_svfprintf_r+0x938>
8000b900:	80 df       	mov.d %d15,%a13
8000b902:	2e 09       	jz.t %d15,0,8000b914 <_svfprintf_r+0x938>
8000b904:	1b 02 0d d0 	addi %d13,%d2,208
8000b908:	60 d2       	mov.a %a2,%d13
8000b90a:	3b 00 03 70 	mov %d7,48
8000b90e:	89 27 3f e4 	st.b [+%a2]-65,%d7
8000b912:	80 2d       	mov.d %d13,%a2
8000b914:	d9 a3 10 20 	lea %a3,[%sp]144
8000b918:	80 39       	mov.d %d9,%a3
8000b91a:	a2 d9       	sub %d9,%d13
8000b91c:	3c 14       	j 8000b944 <_svfprintf_r+0x968>
8000b91e:	e9 af 01 10 	st.b [%sp]65,%d15
8000b922:	58 04       	ld.w %d15,[%sp]16
8000b924:	df 0f 1f 04 	jeq %d15,0,8000c162 <_svfprintf_r+0x1186>
8000b928:	82 03       	mov %d3,0
8000b92a:	60 ad       	mov.a %a13,%d10
8000b92c:	e9 af 28 10 	st.b [%sp]104,%d15
8000b930:	e9 a3 01 10 	st.b [%sp]65,%d3
8000b934:	40 fc       	mov.aa %a12,%a15
8000b936:	80 a2       	mov.d %d2,%sp
8000b938:	82 19       	mov %d9,1
8000b93a:	82 0e       	mov %d14,0
8000b93c:	1b 82 06 d0 	addi %d13,%d2,104
8000b940:	3c 02       	j 8000b944 <_svfprintf_r+0x968>
8000b942:	82 0e       	mov %d14,0
8000b944:	79 a7 01 10 	ld.b %d7,[%sp]65
8000b948:	80 df       	mov.d %d15,%a13
8000b94a:	0b e9 a0 a1 	max %d10,%d9,%d14
8000b94e:	80 d2       	mov.d %d2,%a13
8000b950:	16 02       	and %d15,2
8000b952:	ab 1a 00 a7 	cadd %d10,%d7,%d10,1
8000b956:	60 ff       	mov.a %a15,%d15
8000b958:	8a 2a       	cadd %d10,%d15,2
8000b95a:	8f 42 08 f1 	and %d15,%d2,132
8000b95e:	ee 48       	jnz %d15,8000b9ee <_svfprintf_r+0xa12>
8000b960:	19 a8 1c 00 	ld.w %d8,[%sp]28
8000b964:	a2 a8       	sub %d8,%d10
8000b966:	bf 18 44 00 	jlt %d8,1,8000b9ee <_svfprintf_r+0xa12>
8000b96a:	91 00 00 28 	movh.a %a2,32768
8000b96e:	d9 22 c4 80 	lea %a2,[%a2]3588 <80000e04 <blanks.4035>>
8000b972:	19 a1 24 10 	ld.w %d1,[%sp]100 <80000e04 <blanks.4035>>
8000b976:	19 a4 20 10 	ld.w %d4,[%sp]96 <80000e04 <blanks.4035>>
8000b97a:	8b 18 81 72 	ge %d7,%d8,17
8000b97e:	f4 e2       	st.a [%a14],%a2
8000b980:	df 07 20 00 	jeq %d7,0,8000b9c0 <_svfprintf_r+0x9e4>
8000b984:	1b 14 00 00 	addi %d0,%d4,1
8000b988:	3b 00 01 20 	mov %d2,16
8000b98c:	1b 01 01 10 	addi %d1,%d1,16
8000b990:	59 e2 04 00 	st.w [%a14]4,%d2
8000b994:	59 a0 20 10 	st.w [%sp]96,%d0
8000b998:	59 a1 24 10 	st.w [%sp]100,%d1
8000b99c:	8b 80 80 02 	ge %d0,%d0,8
8000b9a0:	d9 ee 08 00 	lea %a14,[%a14]8
8000b9a4:	76 0b       	jz %d0,8000b9ba <_svfprintf_r+0x9de>
8000b9a6:	60 c4       	mov.a %a4,%d12
8000b9a8:	60 b5       	mov.a %a5,%d11
8000b9aa:	d9 a6 1c 10 	lea %a6,[%sp]92
8000b9ae:	6d 00 f4 0d 	call 8000d596 <__ssprint_r>
8000b9b2:	df 02 e0 83 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000b9b6:	d9 ae 10 20 	lea %a14,[%sp]144
8000b9ba:	1b 08 ff 8f 	addi %d8,%d8,-16
8000b9be:	3c d6       	j 8000b96a <_svfprintf_r+0x98e>
8000b9c0:	c2 14       	add %d4,1
8000b9c2:	42 81       	add %d1,%d8
8000b9c4:	59 e8 04 00 	st.w [%a14]4,%d8
8000b9c8:	59 a4 20 10 	st.w [%sp]96,%d4
8000b9cc:	59 a1 24 10 	st.w [%sp]100,%d1
8000b9d0:	8b 84 80 42 	ge %d4,%d4,8
8000b9d4:	d9 ee 08 00 	lea %a14,[%a14]8
8000b9d8:	76 4b       	jz %d4,8000b9ee <_svfprintf_r+0xa12>
8000b9da:	60 c4       	mov.a %a4,%d12
8000b9dc:	60 b5       	mov.a %a5,%d11
8000b9de:	d9 a6 1c 10 	lea %a6,[%sp]92
8000b9e2:	6d 00 da 0d 	call 8000d596 <__ssprint_r>
8000b9e6:	df 02 c6 83 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000b9ea:	d9 ae 10 20 	lea %a14,[%sp]144
8000b9ee:	79 a4 01 10 	ld.b %d4,[%sp]65
8000b9f2:	df 04 21 00 	jeq %d4,0,8000ba34 <_svfprintf_r+0xa58>
8000b9f6:	19 a4 24 10 	ld.w %d4,[%sp]100
8000b9fa:	d9 a7 01 10 	lea %a7,[%sp]65
8000b9fe:	c2 14       	add %d4,1
8000ba00:	59 a4 24 10 	st.w [%sp]100,%d4
8000ba04:	19 a4 20 10 	ld.w %d4,[%sp]96
8000ba08:	82 17       	mov %d7,1
8000ba0a:	c2 14       	add %d4,1
8000ba0c:	f4 e7       	st.a [%a14],%a7
8000ba0e:	59 e7 04 00 	st.w [%a14]4,%d7
8000ba12:	59 a4 20 10 	st.w [%sp]96,%d4
8000ba16:	8b 84 80 42 	ge %d4,%d4,8
8000ba1a:	d9 ee 08 00 	lea %a14,[%a14]8
8000ba1e:	76 4b       	jz %d4,8000ba34 <_svfprintf_r+0xa58>
8000ba20:	60 c4       	mov.a %a4,%d12
8000ba22:	60 b5       	mov.a %a5,%d11
8000ba24:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ba28:	6d 00 b7 0d 	call 8000d596 <__ssprint_r>
8000ba2c:	df 02 a3 83 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000ba30:	d9 ae 10 20 	lea %a14,[%sp]144
8000ba34:	bd 0f 21 00 	jz.a %a15,8000ba76 <_svfprintf_r+0xa9a>
8000ba38:	19 a4 24 10 	ld.w %d4,[%sp]100
8000ba3c:	d9 a7 02 10 	lea %a7,[%sp]66
8000ba40:	c2 24       	add %d4,2
8000ba42:	59 a4 24 10 	st.w [%sp]100,%d4
8000ba46:	19 a4 20 10 	ld.w %d4,[%sp]96
8000ba4a:	82 27       	mov %d7,2
8000ba4c:	c2 14       	add %d4,1
8000ba4e:	f4 e7       	st.a [%a14],%a7
8000ba50:	59 e7 04 00 	st.w [%a14]4,%d7
8000ba54:	59 a4 20 10 	st.w [%sp]96,%d4
8000ba58:	8b 84 80 42 	ge %d4,%d4,8
8000ba5c:	d9 ee 08 00 	lea %a14,[%a14]8
8000ba60:	76 4b       	jz %d4,8000ba76 <_svfprintf_r+0xa9a>
8000ba62:	60 c4       	mov.a %a4,%d12
8000ba64:	60 b5       	mov.a %a5,%d11
8000ba66:	d9 a6 1c 10 	lea %a6,[%sp]92
8000ba6a:	6d 00 96 0d 	call 8000d596 <__ssprint_r>
8000ba6e:	df 02 82 83 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000ba72:	d9 ae 10 20 	lea %a14,[%sp]144
8000ba76:	8b 0f 28 42 	ne %d4,%d15,128
8000ba7a:	df 04 48 80 	jne %d4,0,8000bb0a <_svfprintf_r+0xb2e>
8000ba7e:	58 07       	ld.w %d15,[%sp]28
8000ba80:	7b 00 00 28 	movh %d2,32768
8000ba84:	60 23       	mov.a %a3,%d2
8000ba86:	a2 af       	sub %d15,%d10
8000ba88:	d9 3f f4 70 	lea %a15,[%a3]3572
8000ba8c:	bf 1f 3f 00 	jlt %d15,1,8000bb0a <_svfprintf_r+0xb2e>
8000ba90:	19 a7 24 10 	ld.w %d7,[%sp]100
8000ba94:	19 a4 20 10 	ld.w %d4,[%sp]96
8000ba98:	8b 1f 81 82 	ge %d8,%d15,17
8000ba9c:	ec e0       	st.a [%a14]0,%a15
8000ba9e:	df 08 20 00 	jeq %d8,0,8000bade <_svfprintf_r+0xb02>
8000baa2:	1b 14 00 00 	addi %d0,%d4,1
8000baa6:	3b 00 01 20 	mov %d2,16
8000baaa:	1b 07 01 10 	addi %d1,%d7,16
8000baae:	59 e2 04 00 	st.w [%a14]4,%d2
8000bab2:	59 a0 20 10 	st.w [%sp]96,%d0
8000bab6:	59 a1 24 10 	st.w [%sp]100,%d1
8000baba:	8b 80 80 02 	ge %d0,%d0,8
8000babe:	d9 ee 08 00 	lea %a14,[%a14]8
8000bac2:	76 0b       	jz %d0,8000bad8 <_svfprintf_r+0xafc>
8000bac4:	60 c4       	mov.a %a4,%d12
8000bac6:	60 b5       	mov.a %a5,%d11
8000bac8:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bacc:	6d 00 65 0d 	call 8000d596 <__ssprint_r>
8000bad0:	df 02 51 83 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bad4:	d9 ae 10 20 	lea %a14,[%sp]144
8000bad8:	1b 0f ff ff 	addi %d15,%d15,-16
8000badc:	3c da       	j 8000ba90 <_svfprintf_r+0xab4>
8000bade:	c2 14       	add %d4,1
8000bae0:	42 f7       	add %d7,%d15
8000bae2:	6c e1       	st.w [%a14]4,%d15
8000bae4:	59 a4 20 10 	st.w [%sp]96,%d4
8000bae8:	59 a7 24 10 	st.w [%sp]100,%d7
8000baec:	8b 84 80 42 	ge %d4,%d4,8
8000baf0:	d9 ee 08 00 	lea %a14,[%a14]8
8000baf4:	76 4b       	jz %d4,8000bb0a <_svfprintf_r+0xb2e>
8000baf6:	60 c4       	mov.a %a4,%d12
8000baf8:	60 b5       	mov.a %a5,%d11
8000bafa:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bafe:	6d 00 4c 0d 	call 8000d596 <__ssprint_r>
8000bb02:	df 02 38 83 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bb06:	d9 ae 10 20 	lea %a14,[%sp]144
8000bb0a:	7b 00 00 88 	movh %d8,32768
8000bb0e:	a2 9e       	sub %d14,%d9
8000bb10:	1b 48 df 80 	addi %d8,%d8,3572
8000bb14:	c5 0f 10 00 	lea %a15,10 <_.+0xf>
8000bb18:	bf 1e 3c 00 	jlt %d14,1,8000bb90 <_svfprintf_r+0xbb4>
8000bb1c:	19 a6 24 10 	ld.w %d6,[%sp]100
8000bb20:	19 a4 20 10 	ld.w %d4,[%sp]96
8000bb24:	8b 1e 81 02 	ge %d0,%d14,17
8000bb28:	74 e8       	st.w [%a14],%d8
8000bb2a:	df 00 1c 00 	jeq %d0,0,8000bb62 <_svfprintf_r+0xb86>
8000bb2e:	c2 14       	add %d4,1
8000bb30:	1b 06 01 00 	addi %d0,%d6,16
8000bb34:	ec e1       	st.a [%a14]4,%a15
8000bb36:	59 a4 20 10 	st.w [%sp]96,%d4
8000bb3a:	59 a0 24 10 	st.w [%sp]100,%d0
8000bb3e:	8b 84 80 42 	ge %d4,%d4,8
8000bb42:	d9 ee 08 00 	lea %a14,[%a14]8
8000bb46:	76 4b       	jz %d4,8000bb5c <_svfprintf_r+0xb80>
8000bb48:	60 c4       	mov.a %a4,%d12
8000bb4a:	60 b5       	mov.a %a5,%d11
8000bb4c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bb50:	6d 00 23 0d 	call 8000d596 <__ssprint_r>
8000bb54:	df 02 0f 83 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bb58:	d9 ae 10 20 	lea %a14,[%sp]144
8000bb5c:	1b 0e ff ef 	addi %d14,%d14,-16
8000bb60:	3c de       	j 8000bb1c <_svfprintf_r+0xb40>
8000bb62:	c2 14       	add %d4,1
8000bb64:	42 e6       	add %d6,%d14
8000bb66:	59 ee 04 00 	st.w [%a14]4,%d14
8000bb6a:	59 a4 20 10 	st.w [%sp]96,%d4
8000bb6e:	59 a6 24 10 	st.w [%sp]100,%d6
8000bb72:	8b 84 80 42 	ge %d4,%d4,8
8000bb76:	d9 ee 08 00 	lea %a14,[%a14]8
8000bb7a:	76 4b       	jz %d4,8000bb90 <_svfprintf_r+0xbb4>
8000bb7c:	60 c4       	mov.a %a4,%d12
8000bb7e:	60 b5       	mov.a %a5,%d11
8000bb80:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bb84:	6d 00 09 0d 	call 8000d596 <__ssprint_r>
8000bb88:	df 02 f5 82 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bb8c:	d9 ae 10 20 	lea %a14,[%sp]144
8000bb90:	80 df       	mov.d %d15,%a13
8000bb92:	19 ae 24 10 	ld.w %d14,[%sp]100
8000bb96:	19 a8 20 10 	ld.w %d8,[%sp]96
8000bb9a:	6f 8f 1d 80 	jnz.t %d15,8,8000bbd4 <_svfprintf_r+0xbf8>
8000bb9e:	c2 18       	add %d8,1
8000bba0:	59 e9 04 00 	st.w [%a14]4,%d9
8000bba4:	42 e9       	add %d9,%d14
8000bba6:	59 a8 20 10 	st.w [%sp]96,%d8
8000bbaa:	74 ed       	st.w [%a14],%d13
8000bbac:	59 a9 24 10 	st.w [%sp]100,%d9
8000bbb0:	8b 88 80 82 	ge %d8,%d8,8
8000bbb4:	d9 ef 08 00 	lea %a15,[%a14]8
8000bbb8:	df 08 79 02 	jeq %d8,0,8000c0aa <_svfprintf_r+0x10ce>
8000bbbc:	60 c4       	mov.a %a4,%d12
8000bbbe:	60 b5       	mov.a %a5,%d11
8000bbc0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bbc4:	6d 00 e9 0c 	call 8000d596 <__ssprint_r>
8000bbc8:	df 02 d5 82 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bbcc:	d9 af 10 20 	lea %a15,[%sp]144
8000bbd0:	1d 00 6d 02 	j 8000c0aa <_svfprintf_r+0x10ce>
8000bbd4:	19 a2 10 00 	ld.w %d2,[%sp]16
8000bbd8:	8b 62 46 f2 	lt %d15,%d2,102
8000bbdc:	df 0f be 81 	jne %d15,0,8000bf58 <_svfprintf_r+0xf7c>
8000bbe0:	d2 06       	mov %e6,0
8000bbe2:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000bbe6:	19 a5 30 00 	ld.w %d5,[%sp]48
8000bbea:	6d 00 db 0f 	call 8000dba0 <__eqdf2>
8000bbee:	df 02 78 80 	jne %d2,0,8000bcde <_svfprintf_r+0xd02>
8000bbf2:	7b 00 00 38 	movh %d3,32768
8000bbf6:	1b 23 df 30 	addi %d3,%d3,3570
8000bbfa:	c2 18       	add %d8,1
8000bbfc:	74 e3       	st.w [%a14],%d3
8000bbfe:	1b 1e 00 90 	addi %d9,%d14,1
8000bc02:	82 13       	mov %d3,1
8000bc04:	59 a8 20 10 	st.w [%sp]96,%d8
8000bc08:	59 e3 04 00 	st.w [%a14]4,%d3
8000bc0c:	59 a9 24 10 	st.w [%sp]100,%d9
8000bc10:	8b 88 80 82 	ge %d8,%d8,8
8000bc14:	d9 ef 08 00 	lea %a15,[%a14]8
8000bc18:	76 8b       	jz %d8,8000bc2e <_svfprintf_r+0xc52>
8000bc1a:	60 c4       	mov.a %a4,%d12
8000bc1c:	60 b5       	mov.a %a5,%d11
8000bc1e:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bc22:	6d 00 ba 0c 	call 8000d596 <__ssprint_r>
8000bc26:	df 02 a6 82 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bc2a:	d9 af 10 20 	lea %a15,[%sp]144
8000bc2e:	58 11       	ld.w %d15,[%sp]68
8000bc30:	19 a2 14 00 	ld.w %d2,[%sp]20
8000bc34:	3f 2f 05 00 	jlt %d15,%d2,8000bc3e <_svfprintf_r+0xc62>
8000bc38:	80 df       	mov.d %d15,%a13
8000bc3a:	6f 0f 38 02 	jz.t %d15,0,8000c0aa <_svfprintf_r+0x10ce>
8000bc3e:	58 08       	ld.w %d15,[%sp]32
8000bc40:	19 a2 20 00 	ld.w %d2,[%sp]32
8000bc44:	68 1f       	st.w [%a15]4,%d15
8000bc46:	58 19       	ld.w %d15,[%sp]100
8000bc48:	99 a3 34 00 	ld.a %a3,[%sp]52
8000bc4c:	42 2f       	add %d15,%d2
8000bc4e:	78 19       	st.w [%sp]100,%d15
8000bc50:	58 18       	ld.w %d15,[%sp]96
8000bc52:	e8 03       	st.a [%a15]0,%a3
8000bc54:	c2 1f       	add %d15,1
8000bc56:	78 18       	st.w [%sp]96,%d15
8000bc58:	8b 8f 80 f2 	ge %d15,%d15,8
8000bc5c:	d9 ff 08 00 	lea %a15,[%a15]8
8000bc60:	6e 0b       	jz %d15,8000bc76 <_svfprintf_r+0xc9a>
8000bc62:	60 c4       	mov.a %a4,%d12
8000bc64:	60 b5       	mov.a %a5,%d11
8000bc66:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bc6a:	6d 00 96 0c 	call 8000d596 <__ssprint_r>
8000bc6e:	df 02 82 82 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bc72:	d9 af 10 20 	lea %a15,[%sp]144
8000bc76:	58 05       	ld.w %d15,[%sp]20
8000bc78:	7b 00 00 88 	movh %d8,32768
8000bc7c:	c2 ff       	add %d15,-1
8000bc7e:	1b 48 df 80 	addi %d8,%d8,3572
8000bc82:	3b 00 01 90 	mov %d9,16
8000bc86:	bf 1f 12 02 	jlt %d15,1,8000c0aa <_svfprintf_r+0x10ce>
8000bc8a:	19 a5 24 10 	ld.w %d5,[%sp]100
8000bc8e:	19 a3 20 10 	ld.w %d3,[%sp]96
8000bc92:	8b 1f 81 42 	ge %d4,%d15,17
8000bc96:	68 08       	st.w [%a15]0,%d8
8000bc98:	df 04 1c 00 	jeq %d4,0,8000bcd0 <_svfprintf_r+0xcf4>
8000bc9c:	c2 13       	add %d3,1
8000bc9e:	1b 05 01 40 	addi %d4,%d5,16
8000bca2:	68 19       	st.w [%a15]4,%d9
8000bca4:	59 a3 20 10 	st.w [%sp]96,%d3
8000bca8:	59 a4 24 10 	st.w [%sp]100,%d4
8000bcac:	8b 83 80 32 	ge %d3,%d3,8
8000bcb0:	d9 ff 08 00 	lea %a15,[%a15]8
8000bcb4:	76 3b       	jz %d3,8000bcca <_svfprintf_r+0xcee>
8000bcb6:	60 c4       	mov.a %a4,%d12
8000bcb8:	60 b5       	mov.a %a5,%d11
8000bcba:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bcbe:	6d 00 6c 0c 	call 8000d596 <__ssprint_r>
8000bcc2:	df 02 58 82 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bcc6:	d9 af 10 20 	lea %a15,[%sp]144
8000bcca:	1b 0f ff ff 	addi %d15,%d15,-16
8000bcce:	3c de       	j 8000bc8a <_svfprintf_r+0xcae>
8000bcd0:	12 54       	add %d4,%d15,%d5
8000bcd2:	68 1f       	st.w [%a15]4,%d15
8000bcd4:	59 a4 24 10 	st.w [%sp]100,%d4
8000bcd8:	9a 13       	add %d15,%d3,1
8000bcda:	1d 00 e1 01 	j 8000c09c <_svfprintf_r+0x10c0>
8000bcde:	19 a3 04 10 	ld.w %d3,[%sp]68
8000bce2:	ff 13 8e 00 	jge %d3,1,8000bdfe <_svfprintf_r+0xe22>
8000bce6:	7b 00 00 38 	movh %d3,32768
8000bcea:	1b 23 df 30 	addi %d3,%d3,3570
8000bcee:	c2 18       	add %d8,1
8000bcf0:	74 e3       	st.w [%a14],%d3
8000bcf2:	1b 1e 00 90 	addi %d9,%d14,1
8000bcf6:	82 13       	mov %d3,1
8000bcf8:	59 a8 20 10 	st.w [%sp]96,%d8
8000bcfc:	59 e3 04 00 	st.w [%a14]4,%d3
8000bd00:	59 a9 24 10 	st.w [%sp]100,%d9
8000bd04:	8b 88 80 82 	ge %d8,%d8,8
8000bd08:	d9 ef 08 00 	lea %a15,[%a14]8
8000bd0c:	76 8b       	jz %d8,8000bd22 <_svfprintf_r+0xd46>
8000bd0e:	60 c4       	mov.a %a4,%d12
8000bd10:	60 b5       	mov.a %a5,%d11
8000bd12:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bd16:	6d 00 40 0c 	call 8000d596 <__ssprint_r>
8000bd1a:	df 02 2c 82 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bd1e:	d9 af 10 20 	lea %a15,[%sp]144
8000bd22:	58 11       	ld.w %d15,[%sp]68
8000bd24:	19 a2 14 00 	ld.w %d2,[%sp]20
8000bd28:	a6 2f       	or %d15,%d2
8000bd2a:	ee 04       	jnz %d15,8000bd32 <_svfprintf_r+0xd56>
8000bd2c:	80 df       	mov.d %d15,%a13
8000bd2e:	6f 0f be 01 	jz.t %d15,0,8000c0aa <_svfprintf_r+0x10ce>
8000bd32:	58 08       	ld.w %d15,[%sp]32
8000bd34:	19 a2 20 00 	ld.w %d2,[%sp]32
8000bd38:	68 1f       	st.w [%a15]4,%d15
8000bd3a:	58 19       	ld.w %d15,[%sp]100
8000bd3c:	99 a3 34 00 	ld.a %a3,[%sp]52
8000bd40:	42 2f       	add %d15,%d2
8000bd42:	78 19       	st.w [%sp]100,%d15
8000bd44:	58 18       	ld.w %d15,[%sp]96
8000bd46:	e8 03       	st.a [%a15]0,%a3
8000bd48:	c2 1f       	add %d15,1
8000bd4a:	78 18       	st.w [%sp]96,%d15
8000bd4c:	8b 8f 80 f2 	ge %d15,%d15,8
8000bd50:	d9 ff 08 00 	lea %a15,[%a15]8
8000bd54:	6e 0b       	jz %d15,8000bd6a <_svfprintf_r+0xd8e>
8000bd56:	60 c4       	mov.a %a4,%d12
8000bd58:	60 b5       	mov.a %a5,%d11
8000bd5a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bd5e:	6d 00 1c 0c 	call 8000d596 <__ssprint_r>
8000bd62:	df 02 08 82 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bd66:	d9 af 10 20 	lea %a15,[%sp]144
8000bd6a:	58 11       	ld.w %d15,[%sp]68
8000bd6c:	7b 00 00 88 	movh %d8,32768
8000bd70:	32 5f       	rsub %d15
8000bd72:	1b 48 df 80 	addi %d8,%d8,3572
8000bd76:	3b 00 01 90 	mov %d9,16
8000bd7a:	bf 1f 3a 00 	jlt %d15,1,8000bdee <_svfprintf_r+0xe12>
8000bd7e:	19 a5 24 10 	ld.w %d5,[%sp]100
8000bd82:	19 a3 20 10 	ld.w %d3,[%sp]96
8000bd86:	8b 1f 81 42 	ge %d4,%d15,17
8000bd8a:	68 08       	st.w [%a15]0,%d8
8000bd8c:	df 04 1c 00 	jeq %d4,0,8000bdc4 <_svfprintf_r+0xde8>
8000bd90:	c2 13       	add %d3,1
8000bd92:	1b 05 01 40 	addi %d4,%d5,16
8000bd96:	68 19       	st.w [%a15]4,%d9
8000bd98:	59 a3 20 10 	st.w [%sp]96,%d3
8000bd9c:	59 a4 24 10 	st.w [%sp]100,%d4
8000bda0:	8b 83 80 32 	ge %d3,%d3,8
8000bda4:	d9 ff 08 00 	lea %a15,[%a15]8
8000bda8:	76 3b       	jz %d3,8000bdbe <_svfprintf_r+0xde2>
8000bdaa:	60 c4       	mov.a %a4,%d12
8000bdac:	60 b5       	mov.a %a5,%d11
8000bdae:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bdb2:	6d 00 f2 0b 	call 8000d596 <__ssprint_r>
8000bdb6:	df 02 de 81 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bdba:	d9 af 10 20 	lea %a15,[%sp]144
8000bdbe:	1b 0f ff ff 	addi %d15,%d15,-16
8000bdc2:	3c de       	j 8000bd7e <_svfprintf_r+0xda2>
8000bdc4:	68 1f       	st.w [%a15]4,%d15
8000bdc6:	12 54       	add %d4,%d15,%d5
8000bdc8:	9a 13       	add %d15,%d3,1
8000bdca:	78 18       	st.w [%sp]96,%d15
8000bdcc:	59 a4 24 10 	st.w [%sp]100,%d4
8000bdd0:	8b 8f 80 f2 	ge %d15,%d15,8
8000bdd4:	d9 ff 08 00 	lea %a15,[%a15]8
8000bdd8:	6e 0b       	jz %d15,8000bdee <_svfprintf_r+0xe12>
8000bdda:	60 c4       	mov.a %a4,%d12
8000bddc:	60 b5       	mov.a %a5,%d11
8000bdde:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bde2:	6d 00 da 0b 	call 8000d596 <__ssprint_r>
8000bde6:	df 02 c6 81 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bdea:	d9 af 10 20 	lea %a15,[%sp]144
8000bdee:	58 05       	ld.w %d15,[%sp]20
8000bdf0:	68 0d       	st.w [%a15]0,%d13
8000bdf2:	68 1f       	st.w [%a15]4,%d15
8000bdf4:	19 a2 14 00 	ld.w %d2,[%sp]20
8000bdf8:	58 19       	ld.w %d15,[%sp]100
8000bdfa:	1d 00 4d 01 	j 8000c094 <_svfprintf_r+0x10b8>
8000bdfe:	58 05       	ld.w %d15,[%sp]20
8000be00:	74 ed       	st.w [%a14],%d13
8000be02:	3f f3 6a 00 	jlt %d3,%d15,8000bed6 <_svfprintf_r+0xefa>
8000be06:	02 f9       	mov %d9,%d15
8000be08:	c2 18       	add %d8,1
8000be0a:	42 e9       	add %d9,%d14
8000be0c:	59 a8 20 10 	st.w [%sp]96,%d8
8000be10:	6c e1       	st.w [%a14]4,%d15
8000be12:	59 a9 24 10 	st.w [%sp]100,%d9
8000be16:	8b 88 80 82 	ge %d8,%d8,8
8000be1a:	d9 ef 08 00 	lea %a15,[%a14]8
8000be1e:	76 8b       	jz %d8,8000be34 <_svfprintf_r+0xe58>
8000be20:	60 c4       	mov.a %a4,%d12
8000be22:	60 b5       	mov.a %a5,%d11
8000be24:	d9 a6 1c 10 	lea %a6,[%sp]92
8000be28:	6d 00 b7 0b 	call 8000d596 <__ssprint_r>
8000be2c:	df 02 a3 81 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000be30:	d9 af 10 20 	lea %a15,[%sp]144
8000be34:	58 11       	ld.w %d15,[%sp]68
8000be36:	19 a2 14 00 	ld.w %d2,[%sp]20
8000be3a:	7b 00 00 88 	movh %d8,32768
8000be3e:	a2 2f       	sub %d15,%d2
8000be40:	1b 48 df 80 	addi %d8,%d8,3572
8000be44:	3b 00 01 90 	mov %d9,16
8000be48:	bf 1f 3a 00 	jlt %d15,1,8000bebc <_svfprintf_r+0xee0>
8000be4c:	19 a5 24 10 	ld.w %d5,[%sp]100
8000be50:	19 a3 20 10 	ld.w %d3,[%sp]96
8000be54:	8b 1f 81 42 	ge %d4,%d15,17
8000be58:	68 08       	st.w [%a15]0,%d8
8000be5a:	df 04 1c 00 	jeq %d4,0,8000be92 <_svfprintf_r+0xeb6>
8000be5e:	c2 13       	add %d3,1
8000be60:	1b 05 01 40 	addi %d4,%d5,16
8000be64:	68 19       	st.w [%a15]4,%d9
8000be66:	59 a3 20 10 	st.w [%sp]96,%d3
8000be6a:	59 a4 24 10 	st.w [%sp]100,%d4
8000be6e:	8b 83 80 32 	ge %d3,%d3,8
8000be72:	d9 ff 08 00 	lea %a15,[%a15]8
8000be76:	76 3b       	jz %d3,8000be8c <_svfprintf_r+0xeb0>
8000be78:	60 c4       	mov.a %a4,%d12
8000be7a:	60 b5       	mov.a %a5,%d11
8000be7c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000be80:	6d 00 8b 0b 	call 8000d596 <__ssprint_r>
8000be84:	df 02 77 81 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000be88:	d9 af 10 20 	lea %a15,[%sp]144
8000be8c:	1b 0f ff ff 	addi %d15,%d15,-16
8000be90:	3c de       	j 8000be4c <_svfprintf_r+0xe70>
8000be92:	68 1f       	st.w [%a15]4,%d15
8000be94:	12 54       	add %d4,%d15,%d5
8000be96:	9a 13       	add %d15,%d3,1
8000be98:	78 18       	st.w [%sp]96,%d15
8000be9a:	59 a4 24 10 	st.w [%sp]100,%d4
8000be9e:	8b 8f 80 f2 	ge %d15,%d15,8
8000bea2:	d9 ff 08 00 	lea %a15,[%a15]8
8000bea6:	6e 0b       	jz %d15,8000bebc <_svfprintf_r+0xee0>
8000bea8:	60 c4       	mov.a %a4,%d12
8000beaa:	60 b5       	mov.a %a5,%d11
8000beac:	d9 a6 1c 10 	lea %a6,[%sp]92
8000beb0:	6d 00 73 0b 	call 8000d596 <__ssprint_r>
8000beb4:	df 02 5f 81 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000beb8:	d9 af 10 20 	lea %a15,[%sp]144
8000bebc:	80 df       	mov.d %d15,%a13
8000bebe:	6f 0f f6 00 	jz.t %d15,0,8000c0aa <_svfprintf_r+0x10ce>
8000bec2:	99 a3 34 00 	ld.a %a3,[%sp]52
8000bec6:	58 08       	ld.w %d15,[%sp]32
8000bec8:	19 a2 20 00 	ld.w %d2,[%sp]32
8000becc:	68 1f       	st.w [%a15]4,%d15
8000bece:	e8 03       	st.a [%a15]0,%a3
8000bed0:	58 19       	ld.w %d15,[%sp]100
8000bed2:	1d 00 e1 00 	j 8000c094 <_svfprintf_r+0x10b8>
8000bed6:	c2 18       	add %d8,1
8000bed8:	59 e3 04 00 	st.w [%a14]4,%d3
8000bedc:	42 e3       	add %d3,%d14
8000bede:	59 a8 20 10 	st.w [%sp]96,%d8
8000bee2:	59 a3 24 10 	st.w [%sp]100,%d3
8000bee6:	8b 88 80 82 	ge %d8,%d8,8
8000beea:	d9 ef 08 00 	lea %a15,[%a14]8
8000beee:	76 8b       	jz %d8,8000bf04 <_svfprintf_r+0xf28>
8000bef0:	60 c4       	mov.a %a4,%d12
8000bef2:	60 b5       	mov.a %a5,%d11
8000bef4:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bef8:	6d 00 4f 0b 	call 8000d596 <__ssprint_r>
8000befc:	df 02 3b 81 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bf00:	d9 af 10 20 	lea %a15,[%sp]144
8000bf04:	58 08       	ld.w %d15,[%sp]32
8000bf06:	19 a2 20 00 	ld.w %d2,[%sp]32
8000bf0a:	68 1f       	st.w [%a15]4,%d15
8000bf0c:	58 19       	ld.w %d15,[%sp]100
8000bf0e:	99 a3 34 00 	ld.a %a3,[%sp]52
8000bf12:	42 2f       	add %d15,%d2
8000bf14:	78 19       	st.w [%sp]100,%d15
8000bf16:	58 18       	ld.w %d15,[%sp]96
8000bf18:	99 ae 04 10 	ld.a %a14,[%sp]68
8000bf1c:	c2 1f       	add %d15,1
8000bf1e:	60 d2       	mov.a %a2,%d13
8000bf20:	e8 03       	st.a [%a15]0,%a3
8000bf22:	78 18       	st.w [%sp]96,%d15
8000bf24:	8b 8f 80 f2 	ge %d15,%d15,8
8000bf28:	30 2e       	add.a %a14,%a2
8000bf2a:	d9 ff 08 00 	lea %a15,[%a15]8
8000bf2e:	6e 0b       	jz %d15,8000bf44 <_svfprintf_r+0xf68>
8000bf30:	60 c4       	mov.a %a4,%d12
8000bf32:	60 b5       	mov.a %a5,%d11
8000bf34:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bf38:	6d 00 2f 0b 	call 8000d596 <__ssprint_r>
8000bf3c:	df 02 1b 81 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bf40:	d9 af 10 20 	lea %a15,[%sp]144
8000bf44:	19 a2 14 00 	ld.w %d2,[%sp]20
8000bf48:	58 11       	ld.w %d15,[%sp]68
8000bf4a:	e8 0e       	st.a [%a15]0,%a14
8000bf4c:	5a f2       	sub %d15,%d2,%d15
8000bf4e:	68 1f       	st.w [%a15]4,%d15
8000bf50:	19 a2 24 10 	ld.w %d2,[%sp]100
8000bf54:	1d 00 a0 00 	j 8000c094 <_svfprintf_r+0x10b8>
8000bf58:	c2 18       	add %d8,1
8000bf5a:	82 13       	mov %d3,1
8000bf5c:	1b 1e 00 90 	addi %d9,%d14,1
8000bf60:	58 05       	ld.w %d15,[%sp]20
8000bf62:	59 a8 20 10 	st.w [%sp]96,%d8
8000bf66:	74 ed       	st.w [%a14],%d13
8000bf68:	59 e3 04 00 	st.w [%a14]4,%d3
8000bf6c:	59 a9 24 10 	st.w [%sp]100,%d9
8000bf70:	8b 88 80 82 	ge %d8,%d8,8
8000bf74:	ff 2f 05 00 	jge %d15,2,8000bf7e <_svfprintf_r+0xfa2>
8000bf78:	80 d2       	mov.d %d2,%a13
8000bf7a:	6f 02 81 00 	jz.t %d2,0,8000c07c <_svfprintf_r+0x10a0>
8000bf7e:	d9 ef 08 00 	lea %a15,[%a14]8
8000bf82:	76 8b       	jz %d8,8000bf98 <_svfprintf_r+0xfbc>
8000bf84:	60 c4       	mov.a %a4,%d12
8000bf86:	60 b5       	mov.a %a5,%d11
8000bf88:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bf8c:	6d 00 05 0b 	call 8000d596 <__ssprint_r>
8000bf90:	df 02 f1 80 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bf94:	d9 af 10 20 	lea %a15,[%sp]144
8000bf98:	58 08       	ld.w %d15,[%sp]32
8000bf9a:	19 a2 20 00 	ld.w %d2,[%sp]32
8000bf9e:	68 1f       	st.w [%a15]4,%d15
8000bfa0:	58 19       	ld.w %d15,[%sp]100
8000bfa2:	99 a3 34 00 	ld.a %a3,[%sp]52
8000bfa6:	42 2f       	add %d15,%d2
8000bfa8:	78 19       	st.w [%sp]100,%d15
8000bfaa:	58 18       	ld.w %d15,[%sp]96
8000bfac:	e8 03       	st.a [%a15]0,%a3
8000bfae:	c2 1f       	add %d15,1
8000bfb0:	78 18       	st.w [%sp]96,%d15
8000bfb2:	8b 8f 80 f2 	ge %d15,%d15,8
8000bfb6:	d9 ff 08 00 	lea %a15,[%a15]8
8000bfba:	6e 0b       	jz %d15,8000bfd0 <_svfprintf_r+0xff4>
8000bfbc:	60 c4       	mov.a %a4,%d12
8000bfbe:	60 b5       	mov.a %a5,%d11
8000bfc0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000bfc4:	6d 00 e9 0a 	call 8000d596 <__ssprint_r>
8000bfc8:	df 02 d5 80 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000bfcc:	d9 af 10 20 	lea %a15,[%sp]144
8000bfd0:	d2 06       	mov %e6,0
8000bfd2:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000bfd6:	19 a5 30 00 	ld.w %d5,[%sp]48
8000bfda:	6d 00 03 0e 	call 8000dbe0 <__nedf2>
8000bfde:	58 05       	ld.w %d15,[%sp]20
8000bfe0:	c2 ff       	add %d15,-1
8000bfe2:	76 2c       	jz %d2,8000bffa <_svfprintf_r+0x101e>
8000bfe4:	19 a2 24 10 	ld.w %d2,[%sp]100
8000bfe8:	60 de       	mov.a %a14,%d13
8000bfea:	68 1f       	st.w [%a15]4,%d15
8000bfec:	42 2f       	add %d15,%d2
8000bfee:	78 19       	st.w [%sp]100,%d15
8000bff0:	58 18       	ld.w %d15,[%sp]96
8000bff2:	b0 1e       	add.a %a14,1
8000bff4:	e8 0e       	st.a [%a15]0,%a14
8000bff6:	c2 1f       	add %d15,1
8000bff8:	3c 31       	j 8000c05a <_svfprintf_r+0x107e>
8000bffa:	7b 00 00 88 	movh %d8,32768
8000bffe:	1b 48 df 80 	addi %d8,%d8,3572
8000c002:	3b 00 01 90 	mov %d9,16
8000c006:	bf 1f 3f 00 	jlt %d15,1,8000c084 <_svfprintf_r+0x10a8>
8000c00a:	19 a5 24 10 	ld.w %d5,[%sp]100
8000c00e:	19 a3 20 10 	ld.w %d3,[%sp]96
8000c012:	8b 1f 81 42 	ge %d4,%d15,17
8000c016:	68 08       	st.w [%a15]0,%d8
8000c018:	df 04 1c 00 	jeq %d4,0,8000c050 <_svfprintf_r+0x1074>
8000c01c:	c2 13       	add %d3,1
8000c01e:	1b 05 01 40 	addi %d4,%d5,16
8000c022:	68 19       	st.w [%a15]4,%d9
8000c024:	59 a3 20 10 	st.w [%sp]96,%d3
8000c028:	59 a4 24 10 	st.w [%sp]100,%d4
8000c02c:	8b 83 80 32 	ge %d3,%d3,8
8000c030:	d9 ff 08 00 	lea %a15,[%a15]8
8000c034:	76 3b       	jz %d3,8000c04a <_svfprintf_r+0x106e>
8000c036:	60 c4       	mov.a %a4,%d12
8000c038:	60 b5       	mov.a %a5,%d11
8000c03a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c03e:	6d 00 ac 0a 	call 8000d596 <__ssprint_r>
8000c042:	df 02 98 80 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000c046:	d9 af 10 20 	lea %a15,[%sp]144
8000c04a:	1b 0f ff ff 	addi %d15,%d15,-16
8000c04e:	3c de       	j 8000c00a <_svfprintf_r+0x102e>
8000c050:	12 54       	add %d4,%d15,%d5
8000c052:	68 1f       	st.w [%a15]4,%d15
8000c054:	59 a4 24 10 	st.w [%sp]100,%d4
8000c058:	9a 13       	add %d15,%d3,1
8000c05a:	78 18       	st.w [%sp]96,%d15
8000c05c:	8b 8f 80 f2 	ge %d15,%d15,8
8000c060:	d9 ff 08 00 	lea %a15,[%a15]8
8000c064:	6e 10       	jz %d15,8000c084 <_svfprintf_r+0x10a8>
8000c066:	60 c4       	mov.a %a4,%d12
8000c068:	60 b5       	mov.a %a5,%d11
8000c06a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c06e:	6d 00 94 0a 	call 8000d596 <__ssprint_r>
8000c072:	df 02 80 80 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000c076:	d9 af 10 20 	lea %a15,[%sp]144
8000c07a:	3c 05       	j 8000c084 <_svfprintf_r+0x10a8>
8000c07c:	df 08 f5 ff 	jne %d8,0,8000c066 <_svfprintf_r+0x108a>
8000c080:	d9 ef 08 00 	lea %a15,[%a14]8
8000c084:	58 0e       	ld.w %d15,[%sp]56
8000c086:	d9 a3 0d 10 	lea %a3,[%sp]77
8000c08a:	68 1f       	st.w [%a15]4,%d15
8000c08c:	19 a2 38 00 	ld.w %d2,[%sp]56
8000c090:	58 19       	ld.w %d15,[%sp]100
8000c092:	e8 03       	st.a [%a15]0,%a3
8000c094:	42 2f       	add %d15,%d2
8000c096:	78 19       	st.w [%sp]100,%d15
8000c098:	58 18       	ld.w %d15,[%sp]96
8000c09a:	c2 1f       	add %d15,1
8000c09c:	78 18       	st.w [%sp]96,%d15
8000c09e:	8b 8f 80 f2 	ge %d15,%d15,8
8000c0a2:	df 0f 8d fd 	jne %d15,0,8000bbbc <_svfprintf_r+0xbe0>
8000c0a6:	d9 ff 08 00 	lea %a15,[%a15]8
8000c0aa:	80 df       	mov.d %d15,%a13
8000c0ac:	ae 2d       	jnz.t %d15,2,8000c0c6 <_svfprintf_r+0x10ea>
8000c0ae:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000c0b2:	0b 2a a0 f1 	max %d15,%d10,%d2
8000c0b6:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c0ba:	42 f2       	add %d2,%d15
8000c0bc:	58 19       	ld.w %d15,[%sp]100
8000c0be:	59 a2 28 00 	st.w [%sp]40,%d2
8000c0c2:	6e 49       	jz %d15,8000c154 <_svfprintf_r+0x1178>
8000c0c4:	3c 40       	j 8000c144 <_svfprintf_r+0x1168>
8000c0c6:	58 07       	ld.w %d15,[%sp]28
8000c0c8:	3b 00 01 80 	mov %d8,16
8000c0cc:	a2 af       	sub %d15,%d10
8000c0ce:	bf 1f f0 7f 	jlt %d15,1,8000c0ae <_svfprintf_r+0x10d2>
8000c0d2:	91 00 00 28 	movh.a %a2,32768
8000c0d6:	d9 22 c4 80 	lea %a2,[%a2]3588 <80000e04 <blanks.4035>>
8000c0da:	19 a5 24 10 	ld.w %d5,[%sp]100 <80000e04 <blanks.4035>>
8000c0de:	19 a3 20 10 	ld.w %d3,[%sp]96 <80000e04 <blanks.4035>>
8000c0e2:	8b 1f 81 42 	ge %d4,%d15,17
8000c0e6:	e8 02       	st.a [%a15]0,%a2
8000c0e8:	df 04 1c 00 	jeq %d4,0,8000c120 <_svfprintf_r+0x1144>
8000c0ec:	c2 13       	add %d3,1
8000c0ee:	1b 05 01 40 	addi %d4,%d5,16
8000c0f2:	68 18       	st.w [%a15]4,%d8
8000c0f4:	59 a3 20 10 	st.w [%sp]96,%d3
8000c0f8:	59 a4 24 10 	st.w [%sp]100,%d4
8000c0fc:	8b 83 80 32 	ge %d3,%d3,8
8000c100:	d9 ff 08 00 	lea %a15,[%a15]8
8000c104:	76 3b       	jz %d3,8000c11a <_svfprintf_r+0x113e>
8000c106:	60 c4       	mov.a %a4,%d12
8000c108:	60 b5       	mov.a %a5,%d11
8000c10a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c10e:	6d 00 44 0a 	call 8000d596 <__ssprint_r>
8000c112:	df 02 30 80 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000c116:	d9 af 10 20 	lea %a15,[%sp]144
8000c11a:	1b 0f ff ff 	addi %d15,%d15,-16
8000c11e:	3c da       	j 8000c0d2 <_svfprintf_r+0x10f6>
8000c120:	12 54       	add %d4,%d15,%d5
8000c122:	68 1f       	st.w [%a15]4,%d15
8000c124:	9a 13       	add %d15,%d3,1
8000c126:	78 18       	st.w [%sp]96,%d15
8000c128:	59 a4 24 10 	st.w [%sp]100,%d4
8000c12c:	8b 8f 40 f2 	lt %d15,%d15,8
8000c130:	ee bf       	jnz %d15,8000c0ae <_svfprintf_r+0x10d2>
8000c132:	60 c4       	mov.a %a4,%d12
8000c134:	60 b5       	mov.a %a5,%d11
8000c136:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c13a:	6d 00 2e 0a 	call 8000d596 <__ssprint_r>
8000c13e:	df 02 b8 7f 	jeq %d2,0,8000c0ae <_svfprintf_r+0x10d2>
8000c142:	3c 18       	j 8000c172 <_svfprintf_r+0x1196>
8000c144:	60 c4       	mov.a %a4,%d12
8000c146:	60 b5       	mov.a %a5,%d11
8000c148:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c14c:	6d 00 25 0a 	call 8000d596 <__ssprint_r>
8000c150:	df 02 11 80 	jne %d2,0,8000c172 <_svfprintf_r+0x1196>
8000c154:	82 0f       	mov %d15,0
8000c156:	78 18       	st.w [%sp]96,%d15
8000c158:	40 cf       	mov.aa %a15,%a12
8000c15a:	d9 ae 10 20 	lea %a14,[%sp]144
8000c15e:	1d ff 77 f7 	j 8000b04c <_svfprintf_r+0x70>
8000c162:	58 19       	ld.w %d15,[%sp]100
8000c164:	6e 07       	jz %d15,8000c172 <_svfprintf_r+0x1196>
8000c166:	60 c4       	mov.a %a4,%d12
8000c168:	60 b5       	mov.a %a5,%d11
8000c16a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000c16e:	6d 00 14 0a 	call 8000d596 <__ssprint_r>
8000c172:	60 b3       	mov.a %a3,%d11
8000c174:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c178:	8c 36       	ld.h %d15,[%a3]12
8000c17a:	16 40       	and %d15,64
8000c17c:	aa f2       	cmov %d2,%d15,-1
8000c17e:	00 90       	ret 

8000c180 <quorem>:
8000c180:	19 58 10 00 	ld.w %d8,[%a5]16
8000c184:	4c 44       	ld.w %d15,[%a4]16
8000c186:	82 02       	mov %d2,0
8000c188:	3f 8f 88 00 	jlt %d15,%d8,8000c298 <quorem+0x118>
8000c18c:	c2 f8       	add %d8,-1
8000c18e:	80 4f       	mov.d %d15,%a4
8000c190:	8f 28 00 20 	sh %d2,%d8,2
8000c194:	60 2f       	mov.a %a15,%d2
8000c196:	1b 4f 01 90 	addi %d9,%d15,20
8000c19a:	d9 5c 14 00 	lea %a12,[%a5]20
8000c19e:	01 fc 10 d0 	add.a %a13,%a12,%a15
8000c1a2:	01 f9 00 f6 	addsc.a %a15,%a15,%d9,0
8000c1a6:	54 dc       	ld.w %d12,[%a13]
8000c1a8:	4c f0       	ld.w %d15,[%a15]0
8000c1aa:	c2 1c       	add %d12,1
8000c1ac:	4b cf 11 c2 	div.u %e12,%d15,%d12
8000c1b0:	02 ca       	mov %d10,%d12
8000c1b2:	df 0c 3d 00 	jeq %d12,0,8000c22c <quorem+0xac>
8000c1b6:	60 96       	mov.a %a6,%d9
8000c1b8:	40 c2       	mov.aa %a2,%a12
8000c1ba:	82 05       	mov %d5,0
8000c1bc:	82 06       	mov %d6,0
8000c1be:	54 22       	ld.w %d2,[%a2]
8000c1c0:	40 63       	mov.aa %a3,%a6
8000c1c2:	b7 02 10 38 	insert %d3,%d2,0,16,16
8000c1c6:	8f 02 1f 20 	sh %d2,%d2,-16
8000c1ca:	03 a3 0a 35 	madd %d3,%d5,%d3,%d10
8000c1ce:	b0 42       	add.a %a2,4
8000c1d0:	8f 03 1f 40 	sh %d4,%d3,-16
8000c1d4:	03 a2 0a 24 	madd %d2,%d4,%d2,%d10
8000c1d8:	44 34       	ld.w %d4,[%a3+]
8000c1da:	b7 03 10 38 	insert %d3,%d3,0,16,16
8000c1de:	b7 04 10 f8 	insert %d15,%d4,0,16,16
8000c1e2:	8f 02 1f 50 	sh %d5,%d2,-16
8000c1e6:	42 f6       	add %d6,%d15
8000c1e8:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000c1ec:	0b 36 80 30 	sub %d3,%d6,%d3
8000c1f0:	8f 04 1f 40 	sh %d4,%d4,-16
8000c1f4:	8f 03 3f f0 	sha %d15,%d3,-16
8000c1f8:	0b 24 80 20 	sub %d2,%d4,%d2
8000c1fc:	42 f2       	add %d2,%d15
8000c1fe:	37 23 10 38 	insert %d3,%d3,%d2,16,16
8000c202:	8f 02 3f 60 	sha %d6,%d2,-16
8000c206:	80 2f       	mov.d %d15,%a2
8000c208:	80 d2       	mov.d %d2,%a13
8000c20a:	74 63       	st.w [%a6],%d3
8000c20c:	40 36       	mov.aa %a6,%a3
8000c20e:	7f f2 d8 ff 	jge.u %d2,%d15,8000c1be <quorem+0x3e>
8000c212:	4c f0       	ld.w %d15,[%a15]0
8000c214:	ee 0c       	jnz %d15,8000c22c <quorem+0xac>
8000c216:	b0 cf       	add.a %a15,-4
8000c218:	80 f2       	mov.d %d2,%a15
8000c21a:	3f 29 05 80 	jlt.u %d9,%d2,8000c224 <quorem+0xa4>
8000c21e:	59 48 10 00 	st.w [%a4]16,%d8
8000c222:	3c 05       	j 8000c22c <quorem+0xac>
8000c224:	4c f0       	ld.w %d15,[%a15]0
8000c226:	ee fc       	jnz %d15,8000c21e <quorem+0x9e>
8000c228:	c2 f8       	add %d8,-1
8000c22a:	3c f6       	j 8000c216 <quorem+0x96>
8000c22c:	40 4e       	mov.aa %a14,%a4
8000c22e:	6d 00 b9 08 	call 8000d3a0 <__mcmp>
8000c232:	bf 02 32 00 	jlt %d2,0,8000c296 <quorem+0x116>
8000c236:	60 92       	mov.a %a2,%d9
8000c238:	1b 1c 00 a0 	addi %d10,%d12,1
8000c23c:	82 04       	mov %d4,0
8000c23e:	40 2f       	mov.aa %a15,%a2
8000c240:	44 f3       	ld.w %d3,[%a15+]
8000c242:	54 c5       	ld.w %d5,[%a12]
8000c244:	b7 03 10 28 	insert %d2,%d3,0,16,16
8000c248:	8f 05 1f f0 	sh %d15,%d5,-16
8000c24c:	42 42       	add %d2,%d4
8000c24e:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000c252:	8f 03 1f 30 	sh %d3,%d3,-16
8000c256:	a2 42       	sub %d2,%d4
8000c258:	8f 02 3f 40 	sha %d4,%d2,-16
8000c25c:	a2 f3       	sub %d3,%d15
8000c25e:	42 43       	add %d3,%d4
8000c260:	8f 03 3f 40 	sha %d4,%d3,-16
8000c264:	b0 4c       	add.a %a12,4
8000c266:	37 32 10 38 	insert %d3,%d2,%d3,16,16
8000c26a:	80 df       	mov.d %d15,%a13
8000c26c:	80 c2       	mov.d %d2,%a12
8000c26e:	74 23       	st.w [%a2],%d3
8000c270:	40 f2       	mov.aa %a2,%a15
8000c272:	7f 2f e6 ff 	jge.u %d15,%d2,8000c23e <quorem+0xbe>
8000c276:	60 92       	mov.a %a2,%d9
8000c278:	01 28 02 f6 	addsc.a %a15,%a2,%d8,2
8000c27c:	4c f0       	ld.w %d15,[%a15]0
8000c27e:	ee 0c       	jnz %d15,8000c296 <quorem+0x116>
8000c280:	b0 cf       	add.a %a15,-4
8000c282:	80 f2       	mov.d %d2,%a15
8000c284:	3f 29 05 80 	jlt.u %d9,%d2,8000c28e <quorem+0x10e>
8000c288:	59 e8 10 00 	st.w [%a14]16,%d8
8000c28c:	3c 05       	j 8000c296 <quorem+0x116>
8000c28e:	4c f0       	ld.w %d15,[%a15]0
8000c290:	ee fc       	jnz %d15,8000c288 <quorem+0x108>
8000c292:	c2 f8       	add %d8,-1
8000c294:	3c f6       	j 8000c280 <quorem+0x100>
8000c296:	02 a2       	mov %d2,%d10
8000c298:	00 90       	ret 
	...

8000c29c <_dtoa_r>:
8000c29c:	20 58       	sub.a %sp,88
8000c29e:	b5 a5 08 10 	st.a [%sp]72,%a5
8000c2a2:	99 45 00 10 	ld.a %a5,[%a4]64
8000c2a6:	59 a6 1c 00 	st.w [%sp]28,%d6
8000c2aa:	59 a7 28 00 	st.w [%sp]40,%d7
8000c2ae:	b5 a7 38 00 	st.a [%sp]56,%a7
8000c2b2:	40 4d       	mov.aa %a13,%a4
8000c2b4:	0b 45 10 88 	mov %e8,%d5,%d4
8000c2b8:	40 6c       	mov.aa %a12,%a6
8000c2ba:	0b 45 10 c8 	mov %e12,%d5,%d4
8000c2be:	bc 5e       	jz.a %a5,8000c2da <_dtoa_r+0x3e>
8000c2c0:	19 4f 04 10 	ld.w %d15,[%a4]68
8000c2c4:	82 12       	mov %d2,1
8000c2c6:	0f f2 00 20 	sh %d2,%d2,%d15
8000c2ca:	6c 51       	st.w [%a5]4,%d15
8000c2cc:	59 52 08 00 	st.w [%a5]8,%d2
8000c2d0:	82 0f       	mov %d15,0
8000c2d2:	6d 00 99 06 	call 8000d004 <_Bfree>
8000c2d6:	59 df 00 10 	st.w [%a13]64,%d15
8000c2da:	ce 96       	jgez %d9,8000c2e6 <_dtoa_r+0x4a>
8000c2dc:	82 1f       	mov %d15,1
8000c2de:	6c c0       	st.w [%a12]0,%d15
8000c2e0:	b7 09 81 df 	insert %d13,%d9,0,31,1
8000c2e4:	3c 03       	j 8000c2ea <_dtoa_r+0x4e>
8000c2e6:	82 0f       	mov %d15,0
8000c2e8:	6c c0       	st.w [%a12]0,%d15
8000c2ea:	7b 00 ff 27 	movh %d2,32752
8000c2ee:	26 d2       	and %d2,%d13
8000c2f0:	7b 00 ff 37 	movh %d3,32752
8000c2f4:	5f 32 22 80 	jne %d2,%d3,8000c338 <_dtoa_r+0x9c>
8000c2f8:	99 a3 08 10 	ld.a %a3,[%sp]72
8000c2fc:	3b f0 70 22 	mov %d2,9999
8000c300:	91 00 00 f8 	movh.a %a15,32768
8000c304:	74 32       	st.w [%a3],%d2
8000c306:	d9 ff dd 80 	lea %a15,[%a15]3613 <80000e1d <blanks.4035+0x19>>
8000c30a:	f6 c8       	jnz %d12,8000c31a <_dtoa_r+0x7e>
8000c30c:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000c310:	ee 05       	jnz %d15,8000c31a <_dtoa_r+0x7e>
8000c312:	91 00 00 f8 	movh.a %a15,32768
8000c316:	d9 ff d4 80 	lea %a15,[%a15]3604 <80000e14 <blanks.4035+0x10>>
8000c31a:	99 a3 38 00 	ld.a %a3,[%sp]56 <80000e14 <blanks.4035+0x10>>
8000c31e:	40 f2       	mov.aa %a2,%a15
8000c320:	bd 03 26 06 	jz.a %a3,8000cf6c <_dtoa_r+0xcd0>
8000c324:	80 ff       	mov.d %d15,%a15
8000c326:	79 f3 03 00 	ld.b %d3,[%a15]3 <80000003 <BootModeHeader0+0x3>>
8000c32a:	1b 8f 00 20 	addi %d2,%d15,8
8000c32e:	c2 3f       	add %d15,3
8000c330:	2b 2f 50 f3 	seln %d15,%d3,%d15,%d2
8000c334:	6c 30       	st.w [%a3]0,%d15
8000c336:	00 90       	ret 
8000c338:	0b cd 10 48 	mov %e4,%d13,%d12
8000c33c:	d2 06       	mov %e6,0
8000c33e:	0b cd 10 88 	mov %e8,%d13,%d12
8000c342:	6d 00 2f 0c 	call 8000dba0 <__eqdf2>
8000c346:	df 02 13 80 	jne %d2,0,8000c36c <_dtoa_r+0xd0>
8000c34a:	99 a3 08 10 	ld.a %a3,[%sp]72
8000c34e:	d8 0e       	ld.a %a15,[%sp]56
8000c350:	82 1f       	mov %d15,1
8000c352:	91 00 00 28 	movh.a %a2,32768
8000c356:	6c 30       	st.w [%a3]0,%d15
8000c358:	d9 22 e1 80 	lea %a2,[%a2]3617 <80000e21 <blanks.4035+0x1d>>
8000c35c:	bd 0f 08 06 	jz.a %a15,8000cf6c <_dtoa_r+0xcd0>
8000c360:	7b 00 00 f8 	movh %d15,32768
8000c364:	1b 2f e2 f0 	addi %d15,%d15,3618
8000c368:	68 0f       	st.w [%a15]0,%d15
8000c36a:	00 90       	ret 
8000c36c:	0b cd 10 48 	mov %e4,%d13,%d12
8000c370:	40 d4       	mov.aa %a4,%a13
8000c372:	d9 a5 14 10 	lea %a5,[%sp]84
8000c376:	d9 a6 10 10 	lea %a6,[%sp]80
8000c37a:	6d 00 99 08 	call 8000d4ac <__d2b>
8000c37e:	37 0d 6b ba 	extr.u %d11,%d13,20,11
8000c382:	40 2e       	mov.aa %a14,%a2
8000c384:	19 aa 10 10 	ld.w %d10,[%sp]80
8000c388:	76 bd       	jz %d11,8000c3a2 <_dtoa_r+0x106>
8000c38a:	b7 09 0c fa 	insert %d15,%d9,0,20,12
8000c38e:	0b cd 10 48 	mov %e4,%d13,%d12
8000c392:	7b 00 ff 23 	movh %d2,16368
8000c396:	0f 2f a0 50 	or %d5,%d15,%d2
8000c39a:	1b 1b c0 bf 	addi %d11,%d11,-1023
8000c39e:	82 0f       	mov %d15,0
8000c3a0:	3c 22       	j 8000c3e4 <_dtoa_r+0x148>
8000c3a2:	19 ab 14 10 	ld.w %d11,[%sp]84
8000c3a6:	3b e0 be 4f 	mov %d4,-1042
8000c3aa:	42 ab       	add %d11,%d10
8000c3ac:	a2 b4       	sub %d4,%d11
8000c3ae:	3b f0 be 2f 	mov %d2,-1041
8000c3b2:	0f 4c 00 40 	sh %d4,%d12,%d4
8000c3b6:	3f 2b 0f 00 	jlt %d11,%d2,8000c3d4 <_dtoa_r+0x138>
8000c3ba:	1b 2b 41 30 	addi %d3,%d11,1042
8000c3be:	3b e0 c0 4f 	mov %d4,-1010
8000c3c2:	a2 b4       	sub %d4,%d11
8000c3c4:	8b 03 00 21 	rsub %d2,%d3,0
8000c3c8:	0f 2c 00 20 	sh %d2,%d12,%d2
8000c3cc:	0f 4d 00 f0 	sh %d15,%d13,%d4
8000c3d0:	0f f2 a0 40 	or %d4,%d2,%d15
8000c3d4:	6d ff 7c f0 	call 8000a4cc <__floatunsidf>
8000c3d8:	0b 23 10 48 	mov %e4,%d3,%d2
8000c3dc:	9b 03 e1 5f 	addih %d5,%d3,65040
8000c3e0:	c2 fb       	add %d11,-1
8000c3e2:	82 1f       	mov %d15,1
8000c3e4:	b7 00 ab 69 	imask %e6,0,19,11
8000c3e8:	78 13       	st.w [%sp]76,%d15
8000c3ea:	6d ff a2 ee 	call 8000a12e <__subdf3>
8000c3ee:	7b 30 fd 73 	movh %d7,16339
8000c3f2:	0b 23 10 48 	mov %e4,%d3,%d2
8000c3f6:	7b f0 36 66 	movh %d6,25455
8000c3fa:	1b 77 7a 78 	addi %d7,%d7,-30809
8000c3fe:	1b 16 36 64 	addi %d6,%d6,17249
8000c402:	6d ff b6 ee 	call 8000a16e <__muldf3>
8000c406:	7b 70 fc 73 	movh %d7,16327
8000c40a:	0b 23 10 48 	mov %e4,%d3,%d2
8000c40e:	7b 10 b6 68 	movh %d6,35681
8000c412:	1b 87 a2 78 	addi %d7,%d7,-30168
8000c416:	1b 36 8b 6c 	addi %d6,%d6,-14157
8000c41a:	6d ff 6e ee 	call 8000a0f6 <__adddf3>
8000c41e:	02 b4       	mov %d4,%d11
8000c420:	0b 23 10 88 	mov %e8,%d3,%d2
8000c424:	6d ff 03 f0 	call 8000a42a <__floatsidf>
8000c428:	7b 30 fd 73 	movh %d7,16339
8000c42c:	0b 23 10 48 	mov %e4,%d3,%d2
8000c430:	7b f0 09 65 	movh %d6,20639
8000c434:	1b 37 41 74 	addi %d7,%d7,17427
8000c438:	1b b6 9f 67 	addi %d6,%d6,31227
8000c43c:	6d ff 99 ee 	call 8000a16e <__muldf3>
8000c440:	0b 89 10 48 	mov %e4,%d9,%d8
8000c444:	0b 23 10 68 	mov %e6,%d3,%d2
8000c448:	6d ff 57 ee 	call 8000a0f6 <__adddf3>
8000c44c:	0b 23 10 48 	mov %e4,%d3,%d2
8000c450:	0b 23 10 88 	mov %e8,%d3,%d2
8000c454:	6d 00 46 0c 	call 8000dce0 <__fixdfsi>
8000c458:	0b 89 10 48 	mov %e4,%d9,%d8
8000c45c:	d2 06       	mov %e6,0
8000c45e:	59 a2 08 00 	st.w [%sp]8,%d2
8000c462:	6d 00 1f 0c 	call 8000dca0 <__ltdf2>
8000c466:	ff 02 12 00 	jge %d2,0,8000c48a <_dtoa_r+0x1ee>
8000c46a:	19 a4 08 00 	ld.w %d4,[%sp]8
8000c46e:	6d ff de ef 	call 8000a42a <__floatsidf>
8000c472:	0b 89 10 48 	mov %e4,%d9,%d8
8000c476:	0b 23 10 68 	mov %e6,%d3,%d2
8000c47a:	6d 00 b3 0b 	call 8000dbe0 <__nedf2>
8000c47e:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c482:	ab f3 1f 32 	cadd %d3,%d2,%d3,-1
8000c486:	59 a3 08 00 	st.w [%sp]8,%d3
8000c48a:	19 a2 08 00 	ld.w %d2,[%sp]8
8000c48e:	82 13       	mov %d3,1
8000c490:	8b 72 a1 f2 	ge.u %d15,%d2,23
8000c494:	59 a3 3c 00 	st.w [%sp]60,%d3
8000c498:	ee 18       	jnz %d15,8000c4c8 <_dtoa_r+0x22c>
8000c49a:	91 00 00 f8 	movh.a %a15,32768
8000c49e:	d9 ff c4 b0 	lea %a15,[%a15]3780 <80000ec4 <__mprec_tens>>
8000c4a2:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000c4a6:	0b cd 10 68 	mov %e6,%d13,%d12
8000c4aa:	09 f4 40 09 	ld.d %e4,[%a15]
8000c4ae:	6d 00 b9 0b 	call 8000dc20 <__gtdf2>
8000c4b2:	8e 28       	jlez %d2,8000c4c2 <_dtoa_r+0x226>
8000c4b4:	58 02       	ld.w %d15,[%sp]8
8000c4b6:	82 02       	mov %d2,0
8000c4b8:	c2 ff       	add %d15,-1
8000c4ba:	78 02       	st.w [%sp]8,%d15
8000c4bc:	59 a2 3c 00 	st.w [%sp]60,%d2
8000c4c0:	3c 04       	j 8000c4c8 <_dtoa_r+0x22c>
8000c4c2:	82 03       	mov %d3,0
8000c4c4:	59 a3 3c 00 	st.w [%sp]60,%d3
8000c4c8:	0b ba 80 b0 	sub %d11,%d10,%d11
8000c4cc:	9a fb       	add %d15,%d11,-1
8000c4ce:	82 02       	mov %d2,0
8000c4d0:	78 06       	st.w [%sp]24,%d15
8000c4d2:	59 a2 14 00 	st.w [%sp]20,%d2
8000c4d6:	ce f6       	jgez %d15,8000c4e2 <_dtoa_r+0x246>
8000c4d8:	32 5f       	rsub %d15
8000c4da:	82 03       	mov %d3,0
8000c4dc:	78 05       	st.w [%sp]20,%d15
8000c4de:	59 a3 18 00 	st.w [%sp]24,%d3
8000c4e2:	58 02       	ld.w %d15,[%sp]8
8000c4e4:	0e fa       	jltz %d15,8000c4f8 <_dtoa_r+0x25c>
8000c4e6:	19 a2 18 00 	ld.w %d2,[%sp]24
8000c4ea:	78 0d       	st.w [%sp]52,%d15
8000c4ec:	42 f2       	add %d2,%d15
8000c4ee:	82 0f       	mov %d15,0
8000c4f0:	59 a2 18 00 	st.w [%sp]24,%d2
8000c4f4:	78 08       	st.w [%sp]32,%d15
8000c4f6:	3c 0d       	j 8000c510 <_dtoa_r+0x274>
8000c4f8:	19 a2 14 00 	ld.w %d2,[%sp]20
8000c4fc:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c500:	82 0f       	mov %d15,0
8000c502:	a2 32       	sub %d2,%d3
8000c504:	32 53       	rsub %d3
8000c506:	59 a2 14 00 	st.w [%sp]20,%d2
8000c50a:	59 a3 20 00 	st.w [%sp]32,%d3
8000c50e:	78 0d       	st.w [%sp]52,%d15
8000c510:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000c514:	82 18       	mov %d8,1
8000c516:	ff a2 46 80 	jge.u %d2,10,8000c5a2 <_dtoa_r+0x306>
8000c51a:	bf 62 06 00 	jlt %d2,6,8000c526 <_dtoa_r+0x28a>
8000c51e:	c2 c2       	add %d2,-4
8000c520:	59 a2 1c 00 	st.w [%sp]28,%d2
8000c524:	82 08       	mov %d8,0
8000c526:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000c52a:	c2 e3       	add %d3,-2
8000c52c:	ff 43 4b 80 	jge.u %d3,4,8000c5c2 <_dtoa_r+0x326>
8000c530:	91 10 00 f8 	movh.a %a15,32769
8000c534:	d9 ff 40 5c 	lea %a15,[%a15]-15040 <8000c540 <_dtoa_r+0x2a4>>
8000c538:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000c53c:	dc 0f       	ji %a15
8000c53e:	00 00       	nop 
8000c540:	1d 00 08 00 	j 8000c550 <_dtoa_r+0x2b4>
8000c544:	1d 00 1c 00 	j 8000c57c <_dtoa_r+0x2e0>
8000c548:	1d 00 08 00 	j 8000c558 <_dtoa_r+0x2bc>
8000c54c:	1d 00 1c 00 	j 8000c584 <_dtoa_r+0x2e8>
8000c550:	82 03       	mov %d3,0
8000c552:	59 a3 24 00 	st.w [%sp]36,%d3
8000c556:	3c 03       	j 8000c55c <_dtoa_r+0x2c0>
8000c558:	82 1f       	mov %d15,1
8000c55a:	78 09       	st.w [%sp]36,%d15
8000c55c:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c560:	59 a2 2c 00 	st.w [%sp]44,%d2
8000c564:	59 a2 10 00 	st.w [%sp]16,%d2
8000c568:	02 23       	mov %d3,%d2
8000c56a:	ff 12 38 00 	jge %d2,1,8000c5da <_dtoa_r+0x33e>
8000c56e:	82 13       	mov %d3,1
8000c570:	82 1f       	mov %d15,1
8000c572:	59 a3 2c 00 	st.w [%sp]44,%d3
8000c576:	78 04       	st.w [%sp]16,%d15
8000c578:	82 12       	mov %d2,1
8000c57a:	3c 21       	j 8000c5bc <_dtoa_r+0x320>
8000c57c:	82 03       	mov %d3,0
8000c57e:	59 a3 24 00 	st.w [%sp]36,%d3
8000c582:	3c 03       	j 8000c588 <_dtoa_r+0x2ec>
8000c584:	82 1f       	mov %d15,1
8000c586:	78 09       	st.w [%sp]36,%d15
8000c588:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c58c:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c590:	42 32       	add %d2,%d3
8000c592:	59 a2 2c 00 	st.w [%sp]44,%d2
8000c596:	c2 12       	add %d2,1
8000c598:	59 a2 10 00 	st.w [%sp]16,%d2
8000c59c:	8b 12 40 33 	max %d3,%d2,1
8000c5a0:	3c 1d       	j 8000c5da <_dtoa_r+0x33e>
8000c5a2:	82 0f       	mov %d15,0
8000c5a4:	82 12       	mov %d2,1
8000c5a6:	82 f3       	mov %d3,-1
8000c5a8:	78 07       	st.w [%sp]28,%d15
8000c5aa:	82 ff       	mov %d15,-1
8000c5ac:	59 a2 24 00 	st.w [%sp]36,%d2
8000c5b0:	59 a3 2c 00 	st.w [%sp]44,%d3
8000c5b4:	78 04       	st.w [%sp]16,%d15
8000c5b6:	3b 20 01 30 	mov %d3,18
8000c5ba:	82 02       	mov %d2,0
8000c5bc:	59 a2 28 00 	st.w [%sp]40,%d2
8000c5c0:	3c 0d       	j 8000c5da <_dtoa_r+0x33e>
8000c5c2:	82 ff       	mov %d15,-1
8000c5c4:	82 13       	mov %d3,1
8000c5c6:	78 0b       	st.w [%sp]44,%d15
8000c5c8:	82 f2       	mov %d2,-1
8000c5ca:	82 0f       	mov %d15,0
8000c5cc:	59 a3 24 00 	st.w [%sp]36,%d3
8000c5d0:	59 a2 10 00 	st.w [%sp]16,%d2
8000c5d4:	3b 20 01 30 	mov %d3,18
8000c5d8:	78 0a       	st.w [%sp]40,%d15
8000c5da:	82 05       	mov %d5,0
8000c5dc:	59 d5 04 10 	st.w [%a13]68,%d5
8000c5e0:	82 45       	mov %d5,4
8000c5e2:	1b 45 01 00 	addi %d0,%d5,20
8000c5e6:	3f 03 09 80 	jlt.u %d3,%d0,8000c5f8 <_dtoa_r+0x35c>
8000c5ea:	19 d0 04 10 	ld.w %d0,[%a13]68
8000c5ee:	06 15       	sh %d5,1
8000c5f0:	c2 10       	add %d0,1
8000c5f2:	59 d0 04 10 	st.w [%a13]68,%d0
8000c5f6:	3c f6       	j 8000c5e2 <_dtoa_r+0x346>
8000c5f8:	40 d4       	mov.aa %a4,%a13
8000c5fa:	19 d4 04 10 	ld.w %d4,[%a13]68
8000c5fe:	6d 00 d8 04 	call 8000cfae <_Balloc>
8000c602:	19 a2 10 00 	ld.w %d2,[%sp]16
8000c606:	b5 a2 0c 00 	st.a [%sp]12,%a2
8000c60a:	8b f2 60 32 	lt.u %d3,%d2,15
8000c60e:	b5 d2 00 10 	st.a [%a13]64,%a2
8000c612:	26 38       	and %d8,%d3
8000c614:	df 08 97 01 	jeq %d8,0,8000c942 <_dtoa_r+0x6a6>
8000c618:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c61c:	89 ac 40 19 	st.d [%sp]64,%e12
8000c620:	bf 13 3f 00 	jlt %d3,1,8000c69e <_dtoa_r+0x402>
8000c624:	91 00 00 f8 	movh.a %a15,32768
8000c628:	8f f3 00 31 	and %d3,%d3,15
8000c62c:	d9 ff c4 b0 	lea %a15,[%a15]3780 <80000ec4 <__mprec_tens>>
8000c630:	19 ae 08 00 	ld.w %d14,[%sp]8 <80000ec4 <__mprec_tens>>
8000c634:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000c638:	86 ce       	sha %d14,-4
8000c63a:	09 f8 40 09 	ld.d %e8,[%a15]
8000c63e:	82 2a       	mov %d10,2
8000c640:	6f 4e 11 00 	jz.t %d14,4,8000c662 <_dtoa_r+0x3c6>
8000c644:	91 00 00 f8 	movh.a %a15,32768
8000c648:	0b cd 10 48 	mov %e4,%d13,%d12
8000c64c:	d9 ff dc a0 	lea %a15,[%a15]3740 <80000e9c <__mprec_bigtens>>
8000c650:	09 f6 60 09 	ld.d %e6,[%a15]32 <80000020 <_start>>
8000c654:	6d ff 5f ee 	call 8000a312 <__divdf3>
8000c658:	0b 23 10 c8 	mov %e12,%d3,%d2
8000c65c:	8f fe 00 e1 	and %d14,%d14,15
8000c660:	82 3a       	mov %d10,3
8000c662:	7b 00 00 b8 	movh %d11,32768
8000c666:	82 0f       	mov %d15,0
8000c668:	1b cb e9 b0 	addi %d11,%d11,3740
8000c66c:	df 0e 12 00 	jeq %d14,0,8000c690 <_dtoa_r+0x3f4>
8000c670:	6f 0e 0d 00 	jz.t %d14,0,8000c68a <_dtoa_r+0x3ee>
8000c674:	60 b2       	mov.a %a2,%d11
8000c676:	d0 2f       	addsc.a %a15,%a2,%d15,3
8000c678:	0b 89 10 48 	mov %e4,%d9,%d8
8000c67c:	09 f6 40 09 	ld.d %e6,[%a15]
8000c680:	6d ff 77 ed 	call 8000a16e <__muldf3>
8000c684:	0b 23 10 88 	mov %e8,%d3,%d2
8000c688:	c2 1a       	add %d10,1
8000c68a:	86 fe       	sha %d14,-1
8000c68c:	c2 1f       	add %d15,1
8000c68e:	3c ef       	j 8000c66c <_dtoa_r+0x3d0>
8000c690:	0b cd 10 48 	mov %e4,%d13,%d12
8000c694:	0b 89 10 68 	mov %e6,%d9,%d8
8000c698:	6d ff 3d ee 	call 8000a312 <__divdf3>
8000c69c:	3c 2c       	j 8000c6f4 <_dtoa_r+0x458>
8000c69e:	19 a8 08 00 	ld.w %d8,[%sp]8
8000c6a2:	82 2a       	mov %d10,2
8000c6a4:	32 58       	rsub %d8
8000c6a6:	df 08 29 00 	jeq %d8,0,8000c6f8 <_dtoa_r+0x45c>
8000c6aa:	91 00 00 f8 	movh.a %a15,32768
8000c6ae:	8f f8 00 31 	and %d3,%d8,15
8000c6b2:	d9 ff c4 b0 	lea %a15,[%a15]3780 <80000ec4 <__mprec_tens>>
8000c6b6:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000c6ba:	09 a4 40 19 	ld.d %e4,[%sp]64
8000c6be:	09 f6 40 09 	ld.d %e6,[%a15]
8000c6c2:	7b 00 00 c8 	movh %d12,32768
8000c6c6:	6d ff 54 ed 	call 8000a16e <__muldf3>
8000c6ca:	82 09       	mov %d9,0
8000c6cc:	86 c8       	sha %d8,-4
8000c6ce:	1b cc e9 c0 	addi %d12,%d12,3740
8000c6d2:	df 08 11 00 	jeq %d8,0,8000c6f4 <_dtoa_r+0x458>
8000c6d6:	6f 08 0c 00 	jz.t %d8,0,8000c6ee <_dtoa_r+0x452>
8000c6da:	60 c3       	mov.a %a3,%d12
8000c6dc:	01 39 03 f6 	addsc.a %a15,%a3,%d9,3
8000c6e0:	0b 23 10 48 	mov %e4,%d3,%d2
8000c6e4:	09 f6 40 09 	ld.d %e6,[%a15]
8000c6e8:	c2 1a       	add %d10,1
8000c6ea:	6d ff 42 ed 	call 8000a16e <__muldf3>
8000c6ee:	86 f8       	sha %d8,-1
8000c6f0:	c2 19       	add %d9,1
8000c6f2:	3c f0       	j 8000c6d2 <_dtoa_r+0x436>
8000c6f4:	0b 23 10 c8 	mov %e12,%d3,%d2
8000c6f8:	19 a2 3c 00 	ld.w %d2,[%sp]60
8000c6fc:	df 02 23 00 	jeq %d2,0,8000c742 <_dtoa_r+0x4a6>
8000c700:	0b cd 10 48 	mov %e4,%d13,%d12
8000c704:	b7 00 2a 6a 	imask %e6,0,20,10
8000c708:	6d 00 cc 0a 	call 8000dca0 <__ltdf2>
8000c70c:	ff 02 20 00 	jge %d2,0,8000c74c <_dtoa_r+0x4b0>
8000c710:	19 a3 10 00 	ld.w %d3,[%sp]16
8000c714:	df 03 21 00 	jeq %d3,0,8000c756 <_dtoa_r+0x4ba>
8000c718:	58 0b       	ld.w %d15,[%sp]44
8000c71a:	bf 1f 12 01 	jlt %d15,1,8000c93e <_dtoa_r+0x6a2>
8000c71e:	19 a2 08 00 	ld.w %d2,[%sp]8
8000c722:	0b cd 10 48 	mov %e4,%d13,%d12
8000c726:	c2 f2       	add %d2,-1
8000c728:	82 06       	mov %d6,0
8000c72a:	7b 40 02 74 	movh %d7,16420
8000c72e:	59 a2 30 00 	st.w [%sp]48,%d2
8000c732:	6d ff 1e ed 	call 8000a16e <__muldf3>
8000c736:	c2 1a       	add %d10,1
8000c738:	0b 23 10 c8 	mov %e12,%d3,%d2
8000c73c:	99 ac 2c 00 	ld.a %a12,[%sp]44
8000c740:	3c 10       	j 8000c760 <_dtoa_r+0x4c4>
8000c742:	19 a3 08 00 	ld.w %d3,[%sp]8
8000c746:	59 a3 30 00 	st.w [%sp]48,%d3
8000c74a:	3c 03       	j 8000c750 <_dtoa_r+0x4b4>
8000c74c:	58 02       	ld.w %d15,[%sp]8
8000c74e:	78 0c       	st.w [%sp]48,%d15
8000c750:	99 ac 10 00 	ld.a %a12,[%sp]16
8000c754:	3c 06       	j 8000c760 <_dtoa_r+0x4c4>
8000c756:	19 a2 08 00 	ld.w %d2,[%sp]8
8000c75a:	a0 0c       	mov.a %a12,0
8000c75c:	59 a2 30 00 	st.w [%sp]48,%d2
8000c760:	02 a4       	mov %d4,%d10
8000c762:	6d ff 64 ee 	call 8000a42a <__floatsidf>
8000c766:	0b cd 10 68 	mov %e6,%d13,%d12
8000c76a:	0b 23 10 48 	mov %e4,%d3,%d2
8000c76e:	6d ff 00 ed 	call 8000a16e <__muldf3>
8000c772:	0b 23 10 48 	mov %e4,%d3,%d2
8000c776:	82 06       	mov %d6,0
8000c778:	7b c0 01 74 	movh %d7,16412
8000c77c:	6d ff bd ec 	call 8000a0f6 <__adddf3>
8000c780:	0b 23 10 a8 	mov %e10,%d3,%d2
8000c784:	0b 23 10 e8 	mov %e14,%d3,%d2
8000c788:	60 b2       	mov.a %a2,%d11
8000c78a:	11 02 cc ff 	addih.a %a15,%a2,64704
8000c78e:	80 ff       	mov.d %d15,%a15
8000c790:	bd 0c 1e 80 	jnz.a %a12,8000c7cc <_dtoa_r+0x530>
8000c794:	0b cd 10 48 	mov %e4,%d13,%d12
8000c798:	82 06       	mov %d6,0
8000c79a:	7b 40 01 74 	movh %d7,16404
8000c79e:	6d ff c8 ec 	call 8000a12e <__subdf3>
8000c7a2:	80 f7       	mov.d %d7,%a15
8000c7a4:	0b 23 10 48 	mov %e4,%d3,%d2
8000c7a8:	02 e6       	mov %d6,%d14
8000c7aa:	0b 23 10 88 	mov %e8,%d3,%d2
8000c7ae:	6d 00 39 0a 	call 8000dc20 <__gtdf2>
8000c7b2:	ff 12 8e 02 	jge %d2,1,8000ccce <_dtoa_r+0xa32>
8000c7b6:	0b 89 10 48 	mov %e4,%d9,%d8
8000c7ba:	02 e6       	mov %d6,%d14
8000c7bc:	9b 0b cc 77 	addih %d7,%d11,31936
8000c7c0:	6d 00 70 0a 	call 8000dca0 <__ltdf2>
8000c7c4:	bf 02 7d 02 	jlt %d2,0,8000ccbe <_dtoa_r+0xa22>
8000c7c8:	1d 00 bb 00 	j 8000c93e <_dtoa_r+0x6a2>
8000c7cc:	80 c5       	mov.d %d5,%a12
8000c7ce:	91 00 00 f8 	movh.a %a15,32768
8000c7d2:	19 a2 24 00 	ld.w %d2,[%sp]36
8000c7d6:	d9 ff c4 b0 	lea %a15,[%a15]3780 <80000ec4 <__mprec_tens>>
8000c7da:	c2 f5       	add %d5,-1
8000c7dc:	01 f5 03 f6 	addsc.a %a15,%a15,%d5,3
8000c7e0:	df 02 57 00 	jeq %d2,0,8000c88e <_dtoa_r+0x5f2>
8000c7e4:	b7 00 a9 4a 	imask %e4,0,21,9
8000c7e8:	09 f6 40 09 	ld.d %e6,[%a15]
8000c7ec:	6d ff 93 ed 	call 8000a312 <__divdf3>
8000c7f0:	0b ef 10 68 	mov %e6,%d15,%d14
8000c7f4:	0b 23 10 48 	mov %e4,%d3,%d2
8000c7f8:	6d ff 9b ec 	call 8000a12e <__subdf3>
8000c7fc:	d8 03       	ld.a %a15,[%sp]12
8000c7fe:	0b 23 10 a8 	mov %e10,%d3,%d2
8000c802:	0b cd 10 48 	mov %e4,%d13,%d12
8000c806:	80 fe       	mov.d %d14,%a15
8000c808:	6d 00 6c 0a 	call 8000dce0 <__fixdfsi>
8000c80c:	02 24       	mov %d4,%d2
8000c80e:	02 2f       	mov %d15,%d2
8000c810:	6d ff 0d ee 	call 8000a42a <__floatsidf>
8000c814:	0b cd 10 48 	mov %e4,%d13,%d12
8000c818:	0b 23 10 68 	mov %e6,%d3,%d2
8000c81c:	c2 1e       	add %d14,1
8000c81e:	6d ff 88 ec 	call 8000a12e <__subdf3>
8000c822:	1b 0f 03 50 	addi %d5,%d15,48
8000c826:	28 05       	st.b [%a15]0,%d5
8000c828:	0b ab 10 68 	mov %e6,%d11,%d10
8000c82c:	0b 23 10 48 	mov %e4,%d3,%d2
8000c830:	0b 23 10 88 	mov %e8,%d3,%d2
8000c834:	6d 00 36 0a 	call 8000dca0 <__ltdf2>
8000c838:	bf 02 86 03 	jlt %d2,0,8000cf44 <_dtoa_r+0xca8>
8000c83c:	b7 00 2a 4a 	imask %e4,0,20,10
8000c840:	0b 89 10 68 	mov %e6,%d9,%d8
8000c844:	6d ff 75 ec 	call 8000a12e <__subdf3>
8000c848:	0b ab 10 68 	mov %e6,%d11,%d10
8000c84c:	0b 23 10 48 	mov %e4,%d3,%d2
8000c850:	6d 00 28 0a 	call 8000dca0 <__ltdf2>
8000c854:	bf 02 ea 00 	jlt %d2,0,8000ca28 <_dtoa_r+0x78c>
8000c858:	19 a3 0c 00 	ld.w %d3,[%sp]12
8000c85c:	02 e5       	mov %d5,%d14
8000c85e:	80 cf       	mov.d %d15,%a12
8000c860:	a2 35       	sub %d5,%d3
8000c862:	7f f5 6e 00 	jge %d5,%d15,8000c93e <_dtoa_r+0x6a2>
8000c866:	0b ab 10 48 	mov %e4,%d11,%d10
8000c86a:	82 06       	mov %d6,0
8000c86c:	7b 40 02 74 	movh %d7,16420
8000c870:	6d ff 7f ec 	call 8000a16e <__muldf3>
8000c874:	0b 89 10 48 	mov %e4,%d9,%d8
8000c878:	82 06       	mov %d6,0
8000c87a:	7b 40 02 74 	movh %d7,16420
8000c87e:	0b 23 10 a8 	mov %e10,%d3,%d2
8000c882:	6d ff 76 ec 	call 8000a16e <__muldf3>
8000c886:	60 ef       	mov.a %a15,%d14
8000c888:	0b 23 10 c8 	mov %e12,%d3,%d2
8000c88c:	3c bb       	j 8000c802 <_dtoa_r+0x566>
8000c88e:	0b ef 10 68 	mov %e6,%d15,%d14
8000c892:	09 f4 40 09 	ld.d %e4,[%a15]
8000c896:	6d ff 6c ec 	call 8000a16e <__muldf3>
8000c89a:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000c89e:	0b 23 10 a8 	mov %e10,%d3,%d2
8000c8a2:	30 c3       	add.a %a3,%a12
8000c8a4:	99 ac 0c 00 	ld.a %a12,[%sp]12
8000c8a8:	80 3e       	mov.d %d14,%a3
8000c8aa:	0b cd 10 48 	mov %e4,%d13,%d12
8000c8ae:	d9 cf 01 00 	lea %a15,[%a12]1
8000c8b2:	6d 00 17 0a 	call 8000dce0 <__fixdfsi>
8000c8b6:	02 24       	mov %d4,%d2
8000c8b8:	02 2f       	mov %d15,%d2
8000c8ba:	6d ff b8 ed 	call 8000a42a <__floatsidf>
8000c8be:	0b cd 10 48 	mov %e4,%d13,%d12
8000c8c2:	0b 23 10 68 	mov %e6,%d3,%d2
8000c8c6:	6d ff 34 ec 	call 8000a12e <__subdf3>
8000c8ca:	1b 0f 03 50 	addi %d5,%d15,48
8000c8ce:	0b 23 10 88 	mov %e8,%d3,%d2
8000c8d2:	80 f2       	mov.d %d2,%a15
8000c8d4:	34 c5       	st.b [%a12],%d5
8000c8d6:	5f e2 29 80 	jne %d2,%d14,8000c928 <_dtoa_r+0x68c>
8000c8da:	0b ab 10 48 	mov %e4,%d11,%d10
8000c8de:	b7 00 a9 6a 	imask %e6,0,21,9
8000c8e2:	6d ff 0a ec 	call 8000a0f6 <__adddf3>
8000c8e6:	0b 89 10 48 	mov %e4,%d9,%d8
8000c8ea:	0b 23 10 68 	mov %e6,%d3,%d2
8000c8ee:	6d 00 99 09 	call 8000dc20 <__gtdf2>
8000c8f2:	ff 12 9b 00 	jge %d2,1,8000ca28 <_dtoa_r+0x78c>
8000c8f6:	b7 00 a9 4a 	imask %e4,0,21,9
8000c8fa:	0b ab 10 68 	mov %e6,%d11,%d10
8000c8fe:	6d ff 18 ec 	call 8000a12e <__subdf3>
8000c902:	0b 89 10 48 	mov %e4,%d9,%d8
8000c906:	0b 23 10 68 	mov %e6,%d3,%d2
8000c90a:	6d 00 cb 09 	call 8000dca0 <__ltdf2>
8000c90e:	ff 02 18 00 	jge %d2,0,8000c93e <_dtoa_r+0x6a2>
8000c912:	60 e2       	mov.a %a2,%d14
8000c914:	60 ef       	mov.a %a15,%d14
8000c916:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000c91a:	b0 ff       	add.a %a15,-1
8000c91c:	8b 0f 03 f2 	eq %d15,%d15,48
8000c920:	df 0f 12 03 	jeq %d15,0,8000cf44 <_dtoa_r+0xca8>
8000c924:	80 fe       	mov.d %d14,%a15
8000c926:	3c f6       	j 8000c912 <_dtoa_r+0x676>
8000c928:	0b 89 10 48 	mov %e4,%d9,%d8
8000c92c:	82 06       	mov %d6,0
8000c92e:	7b 40 02 74 	movh %d7,16420
8000c932:	6d ff 1e ec 	call 8000a16e <__muldf3>
8000c936:	40 fc       	mov.aa %a12,%a15
8000c938:	0b 23 10 c8 	mov %e12,%d3,%d2
8000c93c:	3c b7       	j 8000c8aa <_dtoa_r+0x60e>
8000c93e:	09 ac 40 19 	ld.d %e12,[%sp]64
8000c942:	19 a3 14 10 	ld.w %d3,[%sp]84
8000c946:	19 a2 08 00 	ld.w %d2,[%sp]8
8000c94a:	8b 03 80 52 	ge %d5,%d3,0
8000c94e:	8b f2 40 54 	and.lt %d5,%d2,15
8000c952:	df 05 9e 00 	jeq %d5,0,8000ca8e <_dtoa_r+0x7f2>
8000c956:	91 00 00 f8 	movh.a %a15,32768
8000c95a:	d9 ff c4 b0 	lea %a15,[%a15]3780 <80000ec4 <__mprec_tens>>
8000c95e:	19 a3 10 00 	ld.w %d3,[%sp]16 <80000ec4 <__mprec_tens>>
8000c962:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000c966:	19 a2 28 00 	ld.w %d2,[%sp]40
8000c96a:	fa 13       	lt %d15,%d3,1
8000c96c:	87 f2 1f f0 	and.t %d15,%d2,31,%d15,0
8000c970:	09 f8 40 09 	ld.d %e8,[%a15]
8000c974:	6e 16       	jz %d15,8000c9a0 <_dtoa_r+0x704>
8000c976:	df 03 a4 81 	jne %d3,0,8000ccbe <_dtoa_r+0xa22>
8000c97a:	0b 89 10 48 	mov %e4,%d9,%d8
8000c97e:	82 06       	mov %d6,0
8000c980:	7b 40 01 74 	movh %d7,16404
8000c984:	6d ff f5 eb 	call 8000a16e <__muldf3>
8000c988:	0b cd 10 68 	mov %e6,%d13,%d12
8000c98c:	0b 23 10 48 	mov %e4,%d3,%d2
8000c990:	a0 0c       	mov.a %a12,0
8000c992:	6d 00 67 09 	call 8000dc60 <__gedf2>
8000c996:	a0 0f       	mov.a %a15,0
8000c998:	ff 02 95 01 	jge %d2,0,8000ccc2 <_dtoa_r+0xa26>
8000c99c:	1d 00 9d 01 	j 8000ccd6 <_dtoa_r+0xa3a>
8000c9a0:	d8 03       	ld.a %a15,[%sp]12
8000c9a2:	0b cd 10 a8 	mov %e10,%d13,%d12
8000c9a6:	0b 89 10 68 	mov %e6,%d9,%d8
8000c9aa:	0b ab 10 48 	mov %e4,%d11,%d10
8000c9ae:	80 fe       	mov.d %d14,%a15
8000c9b0:	6d ff b1 ec 	call 8000a312 <__divdf3>
8000c9b4:	0b 23 10 48 	mov %e4,%d3,%d2
8000c9b8:	c2 1e       	add %d14,1
8000c9ba:	6d 00 93 09 	call 8000dce0 <__fixdfsi>
8000c9be:	02 24       	mov %d4,%d2
8000c9c0:	02 2f       	mov %d15,%d2
8000c9c2:	6d ff 34 ed 	call 8000a42a <__floatsidf>
8000c9c6:	0b 89 10 68 	mov %e6,%d9,%d8
8000c9ca:	0b 23 10 48 	mov %e4,%d3,%d2
8000c9ce:	6d ff d0 eb 	call 8000a16e <__muldf3>
8000c9d2:	0b ab 10 48 	mov %e4,%d11,%d10
8000c9d6:	0b 23 10 68 	mov %e6,%d3,%d2
8000c9da:	6d ff aa eb 	call 8000a12e <__subdf3>
8000c9de:	0b 23 10 48 	mov %e4,%d3,%d2
8000c9e2:	1b 0f 03 30 	addi %d3,%d15,48
8000c9e6:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000c9ea:	28 03       	st.b [%a15]0,%d3
8000c9ec:	02 e3       	mov %d3,%d14
8000c9ee:	a2 23       	sub %d3,%d2
8000c9f0:	19 a2 10 00 	ld.w %d2,[%sp]16
8000c9f4:	5f 23 3c 80 	jne %d3,%d2,8000ca6c <_dtoa_r+0x7d0>
8000c9f8:	0b 45 10 68 	mov %e6,%d5,%d4
8000c9fc:	6d ff 7d eb 	call 8000a0f6 <__adddf3>
8000ca00:	0b 89 10 68 	mov %e6,%d9,%d8
8000ca04:	0b 23 10 48 	mov %e4,%d3,%d2
8000ca08:	0b 23 10 a8 	mov %e10,%d3,%d2
8000ca0c:	6d 00 0a 09 	call 8000dc20 <__gtdf2>
8000ca10:	4e 2e       	jgtz %d2,8000ca2c <_dtoa_r+0x790>
8000ca12:	0b ab 10 48 	mov %e4,%d11,%d10
8000ca16:	0b 89 10 68 	mov %e6,%d9,%d8
8000ca1a:	6d 00 c3 08 	call 8000dba0 <__eqdf2>
8000ca1e:	df 02 95 82 	jne %d2,0,8000cf48 <_dtoa_r+0xcac>
8000ca22:	ae 05       	jnz.t %d15,0,8000ca2c <_dtoa_r+0x790>
8000ca24:	1d 00 92 02 	j 8000cf48 <_dtoa_r+0xcac>
8000ca28:	58 0c       	ld.w %d15,[%sp]48
8000ca2a:	78 02       	st.w [%sp]8,%d15
8000ca2c:	58 03       	ld.w %d15,[%sp]12
8000ca2e:	a2 ef       	sub %d15,%d14
8000ca30:	46 0f       	not %d15
8000ca32:	60 e2       	mov.a %a2,%d14
8000ca34:	60 ef       	mov.a %a15,%d14
8000ca36:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000ca3a:	b0 ff       	add.a %a15,-1
8000ca3c:	8b 93 03 32 	eq %d3,%d3,57
8000ca40:	df 03 11 00 	jeq %d3,0,8000ca62 <_dtoa_r+0x7c6>
8000ca44:	9f 0f 0d 80 	jned %d15,0,8000ca5e <_dtoa_r+0x7c2>
8000ca48:	19 a3 08 00 	ld.w %d3,[%sp]8
8000ca4c:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000ca50:	c2 13       	add %d3,1
8000ca52:	da 30       	mov %d15,48
8000ca54:	59 a3 08 00 	st.w [%sp]8,%d3
8000ca58:	2c 30       	st.b [%a3]0,%d15
8000ca5a:	40 3f       	mov.aa %a15,%a3
8000ca5c:	3c 03       	j 8000ca62 <_dtoa_r+0x7c6>
8000ca5e:	80 fe       	mov.d %d14,%a15
8000ca60:	3c e9       	j 8000ca32 <_dtoa_r+0x796>
8000ca62:	0c f0       	ld.bu %d15,[%a15]0
8000ca64:	c2 1f       	add %d15,1
8000ca66:	28 0f       	st.b [%a15]0,%d15
8000ca68:	1d 00 70 02 	j 8000cf48 <_dtoa_r+0xcac>
8000ca6c:	82 06       	mov %d6,0
8000ca6e:	7b 40 02 74 	movh %d7,16420
8000ca72:	6d ff 7e eb 	call 8000a16e <__muldf3>
8000ca76:	d2 06       	mov %e6,0
8000ca78:	0b 23 10 48 	mov %e4,%d3,%d2
8000ca7c:	0b 23 10 a8 	mov %e10,%d3,%d2
8000ca80:	60 ef       	mov.a %a15,%d14
8000ca82:	6d 00 8f 08 	call 8000dba0 <__eqdf2>
8000ca86:	df 02 90 ff 	jne %d2,0,8000c9a6 <_dtoa_r+0x70a>
8000ca8a:	1d 00 5f 02 	j 8000cf48 <_dtoa_r+0xcac>
8000ca8e:	19 a2 24 00 	ld.w %d2,[%sp]36
8000ca92:	58 08       	ld.w %d15,[%sp]32
8000ca94:	19 a8 14 00 	ld.w %d8,[%sp]20
8000ca98:	a0 0f       	mov.a %a15,0
8000ca9a:	df 02 3b 00 	jeq %d2,0,8000cb10 <_dtoa_r+0x874>
8000ca9e:	58 07       	ld.w %d15,[%sp]28
8000caa0:	ff 2f 10 00 	jge %d15,2,8000cac0 <_dtoa_r+0x824>
8000caa4:	58 13       	ld.w %d15,[%sp]76
8000caa6:	6e 05       	jz %d15,8000cab0 <_dtoa_r+0x814>
8000caa8:	1b 33 43 30 	addi %d3,%d3,1075
8000caac:	58 08       	ld.w %d15,[%sp]32
8000caae:	3c 22       	j 8000caf2 <_dtoa_r+0x856>
8000cab0:	19 a3 10 10 	ld.w %d3,[%sp]80
8000cab4:	58 08       	ld.w %d15,[%sp]32
8000cab6:	8b 63 03 31 	rsub %d3,%d3,54
8000caba:	19 a8 14 00 	ld.w %d8,[%sp]20
8000cabe:	3c 1a       	j 8000caf2 <_dtoa_r+0x856>
8000cac0:	58 04       	ld.w %d15,[%sp]16
8000cac2:	19 a2 20 00 	ld.w %d2,[%sp]32
8000cac6:	c2 ff       	add %d15,-1
8000cac8:	3f f2 04 00 	jlt %d2,%d15,8000cad0 <_dtoa_r+0x834>
8000cacc:	5a f2       	sub %d15,%d2,%d15
8000cace:	3c 0b       	j 8000cae4 <_dtoa_r+0x848>
8000cad0:	19 a3 20 00 	ld.w %d3,[%sp]32
8000cad4:	78 08       	st.w [%sp]32,%d15
8000cad6:	52 32       	sub %d2,%d15,%d3
8000cad8:	19 a3 34 00 	ld.w %d3,[%sp]52
8000cadc:	82 0f       	mov %d15,0
8000cade:	42 23       	add %d3,%d2
8000cae0:	59 a3 34 00 	st.w [%sp]52,%d3
8000cae4:	19 a3 10 00 	ld.w %d3,[%sp]16
8000cae8:	19 a8 14 00 	ld.w %d8,[%sp]20
8000caec:	ce 33       	jgez %d3,8000caf2 <_dtoa_r+0x856>
8000caee:	a2 38       	sub %d8,%d3
8000caf0:	82 03       	mov %d3,0
8000caf2:	19 a2 14 00 	ld.w %d2,[%sp]20
8000caf6:	40 d4       	mov.aa %a4,%a13
8000caf8:	42 32       	add %d2,%d3
8000cafa:	59 a2 14 00 	st.w [%sp]20,%d2
8000cafe:	19 a2 18 00 	ld.w %d2,[%sp]24
8000cb02:	82 14       	mov %d4,1
8000cb04:	42 32       	add %d2,%d3
8000cb06:	59 a2 18 00 	st.w [%sp]24,%d2
8000cb0a:	6d 00 1b 03 	call 8000d140 <__i2b>
8000cb0e:	40 2f       	mov.aa %a15,%a2
8000cb10:	19 a2 18 00 	ld.w %d2,[%sp]24
8000cb14:	8b 18 80 32 	ge %d3,%d8,1
8000cb18:	8b 12 80 34 	and.ge %d3,%d2,1
8000cb1c:	76 3e       	jz %d3,8000cb38 <_dtoa_r+0x89c>
8000cb1e:	0b 82 80 31 	min %d3,%d2,%d8
8000cb22:	19 a2 14 00 	ld.w %d2,[%sp]20
8000cb26:	a2 38       	sub %d8,%d3
8000cb28:	a2 32       	sub %d2,%d3
8000cb2a:	59 a2 14 00 	st.w [%sp]20,%d2
8000cb2e:	19 a2 18 00 	ld.w %d2,[%sp]24
8000cb32:	a2 32       	sub %d2,%d3
8000cb34:	59 a2 18 00 	st.w [%sp]24,%d2
8000cb38:	19 a3 20 00 	ld.w %d3,[%sp]32
8000cb3c:	bf 13 27 00 	jlt %d3,1,8000cb8a <_dtoa_r+0x8ee>
8000cb40:	19 a2 24 00 	ld.w %d2,[%sp]36
8000cb44:	df 02 1c 00 	jeq %d2,0,8000cb7c <_dtoa_r+0x8e0>
8000cb48:	bf 1f 13 00 	jlt %d15,1,8000cb6e <_dtoa_r+0x8d2>
8000cb4c:	40 f5       	mov.aa %a5,%a15
8000cb4e:	02 f4       	mov %d4,%d15
8000cb50:	40 d4       	mov.aa %a4,%a13
8000cb52:	6d 00 8c 03 	call 8000d26a <__pow5mult>
8000cb56:	40 e6       	mov.aa %a6,%a14
8000cb58:	40 d4       	mov.aa %a4,%a13
8000cb5a:	40 25       	mov.aa %a5,%a2
8000cb5c:	40 2f       	mov.aa %a15,%a2
8000cb5e:	6d 00 f9 02 	call 8000d150 <__multiply>
8000cb62:	40 e5       	mov.aa %a5,%a14
8000cb64:	40 2c       	mov.aa %a12,%a2
8000cb66:	40 d4       	mov.aa %a4,%a13
8000cb68:	6d 00 4e 02 	call 8000d004 <_Bfree>
8000cb6c:	40 ce       	mov.aa %a14,%a12
8000cb6e:	19 a4 20 00 	ld.w %d4,[%sp]32
8000cb72:	40 d4       	mov.aa %a4,%a13
8000cb74:	a2 f4       	sub %d4,%d15
8000cb76:	40 e5       	mov.aa %a5,%a14
8000cb78:	76 49       	jz %d4,8000cb8a <_dtoa_r+0x8ee>
8000cb7a:	3c 05       	j 8000cb84 <_dtoa_r+0x8e8>
8000cb7c:	19 a4 20 00 	ld.w %d4,[%sp]32
8000cb80:	40 d4       	mov.aa %a4,%a13
8000cb82:	40 e5       	mov.aa %a5,%a14
8000cb84:	6d 00 73 03 	call 8000d26a <__pow5mult>
8000cb88:	40 2e       	mov.aa %a14,%a2
8000cb8a:	40 d4       	mov.aa %a4,%a13
8000cb8c:	82 14       	mov %d4,1
8000cb8e:	6d 00 d9 02 	call 8000d140 <__i2b>
8000cb92:	19 a3 34 00 	ld.w %d3,[%sp]52
8000cb96:	40 2c       	mov.aa %a12,%a2
8000cb98:	8e 3c       	jlez %d3,8000cbb0 <_dtoa_r+0x914>
8000cb9a:	40 d4       	mov.aa %a4,%a13
8000cb9c:	40 25       	mov.aa %a5,%a2
8000cb9e:	02 34       	mov %d4,%d3
8000cba0:	6d 00 65 03 	call 8000d26a <__pow5mult>
8000cba4:	58 07       	ld.w %d15,[%sp]28
8000cba6:	40 2c       	mov.aa %a12,%a2
8000cba8:	82 09       	mov %d9,0
8000cbaa:	ff 2f 1f 00 	jge %d15,2,8000cbe8 <_dtoa_r+0x94c>
8000cbae:	3c 06       	j 8000cbba <_dtoa_r+0x91e>
8000cbb0:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000cbb4:	82 09       	mov %d9,0
8000cbb6:	ff 22 15 00 	jge %d2,2,8000cbe0 <_dtoa_r+0x944>
8000cbba:	82 09       	mov %d9,0
8000cbbc:	df 0c 12 80 	jne %d12,0,8000cbe0 <_dtoa_r+0x944>
8000cbc0:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000cbc4:	ee 0e       	jnz %d15,8000cbe0 <_dtoa_r+0x944>
8000cbc6:	7b 00 ff f7 	movh %d15,32752
8000cbca:	26 df       	and %d15,%d13
8000cbcc:	6e 0a       	jz %d15,8000cbe0 <_dtoa_r+0x944>
8000cbce:	19 a3 14 00 	ld.w %d3,[%sp]20
8000cbd2:	58 06       	ld.w %d15,[%sp]24
8000cbd4:	c2 13       	add %d3,1
8000cbd6:	c2 1f       	add %d15,1
8000cbd8:	59 a3 14 00 	st.w [%sp]20,%d3
8000cbdc:	78 06       	st.w [%sp]24,%d15
8000cbde:	82 19       	mov %d9,1
8000cbe0:	19 a3 34 00 	ld.w %d3,[%sp]52
8000cbe4:	82 12       	mov %d2,1
8000cbe6:	76 39       	jz %d3,8000cbf8 <_dtoa_r+0x95c>
8000cbe8:	4c c4       	ld.w %d15,[%a12]16
8000cbea:	90 c3       	addsc.a %a3,%a12,%d15,2
8000cbec:	19 34 10 00 	ld.w %d4,[%a3]16
8000cbf0:	6d 00 54 02 	call 8000d098 <__hi0bits>
8000cbf4:	8b 02 02 21 	rsub %d2,%d2,32
8000cbf8:	58 06       	ld.w %d15,[%sp]24
8000cbfa:	42 2f       	add %d15,%d2
8000cbfc:	16 1f       	and %d15,31
8000cbfe:	6e 0a       	jz %d15,8000cc12 <_dtoa_r+0x976>
8000cc00:	8b 0f 02 31 	rsub %d3,%d15,32
8000cc04:	8b cf 01 f1 	rsub %d15,%d15,28
8000cc08:	ff 53 07 00 	jge %d3,5,8000cc16 <_dtoa_r+0x97a>
8000cc0c:	df 43 10 00 	jeq %d3,4,8000cc2c <_dtoa_r+0x990>
8000cc10:	02 3f       	mov %d15,%d3
8000cc12:	1b cf 01 f0 	addi %d15,%d15,28
8000cc16:	19 a2 14 00 	ld.w %d2,[%sp]20
8000cc1a:	19 a3 18 00 	ld.w %d3,[%sp]24
8000cc1e:	42 f2       	add %d2,%d15
8000cc20:	42 f3       	add %d3,%d15
8000cc22:	59 a2 14 00 	st.w [%sp]20,%d2
8000cc26:	42 f8       	add %d8,%d15
8000cc28:	59 a3 18 00 	st.w [%sp]24,%d3
8000cc2c:	58 05       	ld.w %d15,[%sp]20
8000cc2e:	8e f7       	jlez %d15,8000cc3c <_dtoa_r+0x9a0>
8000cc30:	40 e5       	mov.aa %a5,%a14
8000cc32:	40 d4       	mov.aa %a4,%a13
8000cc34:	02 f4       	mov %d4,%d15
8000cc36:	6d 00 58 03 	call 8000d2e6 <__lshift>
8000cc3a:	40 2e       	mov.aa %a14,%a2
8000cc3c:	19 a2 18 00 	ld.w %d2,[%sp]24
8000cc40:	8e 27       	jlez %d2,8000cc4e <_dtoa_r+0x9b2>
8000cc42:	40 c5       	mov.aa %a5,%a12
8000cc44:	40 d4       	mov.aa %a4,%a13
8000cc46:	02 24       	mov %d4,%d2
8000cc48:	6d 00 4f 03 	call 8000d2e6 <__lshift>
8000cc4c:	40 2c       	mov.aa %a12,%a2
8000cc4e:	19 a3 3c 00 	ld.w %d3,[%sp]60
8000cc52:	df 03 20 00 	jeq %d3,0,8000cc92 <_dtoa_r+0x9f6>
8000cc56:	40 e4       	mov.aa %a4,%a14
8000cc58:	40 c5       	mov.aa %a5,%a12
8000cc5a:	6d 00 a3 03 	call 8000d3a0 <__mcmp>
8000cc5e:	ff 02 1a 00 	jge %d2,0,8000cc92 <_dtoa_r+0x9f6>
8000cc62:	58 02       	ld.w %d15,[%sp]8
8000cc64:	40 e5       	mov.aa %a5,%a14
8000cc66:	c2 ff       	add %d15,-1
8000cc68:	40 d4       	mov.aa %a4,%a13
8000cc6a:	fb a0 00 40 	mov %e4,10
8000cc6e:	78 02       	st.w [%sp]8,%d15
8000cc70:	6d 00 d3 01 	call 8000d016 <__multadd>
8000cc74:	19 a2 2c 00 	ld.w %d2,[%sp]44
8000cc78:	19 a3 24 00 	ld.w %d3,[%sp]36
8000cc7c:	59 a2 10 00 	st.w [%sp]16,%d2
8000cc80:	40 2e       	mov.aa %a14,%a2
8000cc82:	76 38       	jz %d3,8000cc92 <_dtoa_r+0x9f6>
8000cc84:	40 f5       	mov.aa %a5,%a15
8000cc86:	40 d4       	mov.aa %a4,%a13
8000cc88:	fb a0 00 40 	mov %e4,10
8000cc8c:	6d 00 c5 01 	call 8000d016 <__multadd>
8000cc90:	40 2f       	mov.aa %a15,%a2
8000cc92:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000cc96:	19 a3 10 00 	ld.w %d3,[%sp]16
8000cc9a:	8b 32 80 f2 	ge %d15,%d2,3
8000cc9e:	8b 13 40 f4 	and.lt %d15,%d3,1
8000cca2:	6e 2a       	jz %d15,8000ccf6 <_dtoa_r+0xa5a>
8000cca4:	f6 3f       	jnz %d3,8000ccc2 <_dtoa_r+0xa26>
8000cca6:	40 c5       	mov.aa %a5,%a12
8000cca8:	40 d4       	mov.aa %a4,%a13
8000ccaa:	d2 54       	mov %e4,5
8000ccac:	6d 00 b5 01 	call 8000d016 <__multadd>
8000ccb0:	40 e4       	mov.aa %a4,%a14
8000ccb2:	40 25       	mov.aa %a5,%a2
8000ccb4:	40 2c       	mov.aa %a12,%a2
8000ccb6:	6d 00 75 03 	call 8000d3a0 <__mcmp>
8000ccba:	4e 2e       	jgtz %d2,8000ccd6 <_dtoa_r+0xa3a>
8000ccbc:	3c 03       	j 8000ccc2 <_dtoa_r+0xa26>
8000ccbe:	a0 0c       	mov.a %a12,0
8000ccc0:	a0 0f       	mov.a %a15,0
8000ccc2:	58 0a       	ld.w %d15,[%sp]40
8000ccc4:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000ccc8:	46 0f       	not %d15
8000ccca:	78 02       	st.w [%sp]8,%d15
8000cccc:	3c 11       	j 8000ccee <_dtoa_r+0xa52>
8000ccce:	58 0c       	ld.w %d15,[%sp]48
8000ccd0:	a0 0c       	mov.a %a12,0
8000ccd2:	78 02       	st.w [%sp]8,%d15
8000ccd4:	a0 0f       	mov.a %a15,0
8000ccd6:	19 a2 08 00 	ld.w %d2,[%sp]8
8000ccda:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000ccde:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000cce2:	da 31       	mov %d15,49
8000cce4:	c2 12       	add %d2,1
8000cce6:	c2 1e       	add %d14,1
8000cce8:	2c 30       	st.b [%a3]0,%d15
8000ccea:	59 a2 08 00 	st.w [%sp]8,%d2
8000ccee:	80 f8       	mov.d %d8,%a15
8000ccf0:	a0 0f       	mov.a %a15,0
8000ccf2:	1d 00 14 01 	j 8000cf1a <_dtoa_r+0xc7e>
8000ccf6:	19 a3 24 00 	ld.w %d3,[%sp]36
8000ccfa:	f6 35       	jnz %d3,8000cd04 <_dtoa_r+0xa68>
8000ccfc:	19 a8 0c 00 	ld.w %d8,[%sp]12
8000cd00:	1d 00 c2 00 	j 8000ce84 <_dtoa_r+0xbe8>
8000cd04:	8e 87       	jlez %d8,8000cd12 <_dtoa_r+0xa76>
8000cd06:	40 f5       	mov.aa %a5,%a15
8000cd08:	40 d4       	mov.aa %a4,%a13
8000cd0a:	02 84       	mov %d4,%d8
8000cd0c:	6d 00 ed 02 	call 8000d2e6 <__lshift>
8000cd10:	40 2f       	mov.aa %a15,%a2
8000cd12:	80 f8       	mov.d %d8,%a15
8000cd14:	df 09 16 00 	jeq %d9,0,8000cd40 <_dtoa_r+0xaa4>
8000cd18:	40 d4       	mov.aa %a4,%a13
8000cd1a:	48 14       	ld.w %d4,[%a15]4
8000cd1c:	6d 00 49 01 	call 8000cfae <_Balloc>
8000cd20:	48 44       	ld.w %d4,[%a15]16
8000cd22:	d9 24 0c 00 	lea %a4,[%a2]12
8000cd26:	c2 24       	add %d4,2
8000cd28:	d9 f5 0c 00 	lea %a5,[%a15]12
8000cd2c:	06 24       	sh %d4,2
8000cd2e:	80 2f       	mov.d %d15,%a2
8000cd30:	6d 00 31 01 	call 8000cf92 <memcpy>
8000cd34:	60 f5       	mov.a %a5,%d15
8000cd36:	40 d4       	mov.aa %a4,%a13
8000cd38:	82 14       	mov %d4,1
8000cd3a:	6d 00 d6 02 	call 8000d2e6 <__lshift>
8000cd3e:	80 28       	mov.d %d8,%a2
8000cd40:	19 a9 0c 00 	ld.w %d9,[%sp]12
8000cd44:	8f 1c 00 a1 	and %d10,%d12,1
8000cd48:	40 e4       	mov.aa %a4,%a14
8000cd4a:	40 c5       	mov.aa %a5,%a12
8000cd4c:	6d ff 1a fa 	call 8000c180 <quorem>
8000cd50:	40 e4       	mov.aa %a4,%a14
8000cd52:	40 f5       	mov.aa %a5,%a15
8000cd54:	02 2e       	mov %d14,%d2
8000cd56:	1b 02 03 f0 	addi %d15,%d2,48
8000cd5a:	6d 00 23 03 	call 8000d3a0 <__mcmp>
8000cd5e:	60 86       	mov.a %a6,%d8
8000cd60:	40 d4       	mov.aa %a4,%a13
8000cd62:	40 c5       	mov.aa %a5,%a12
8000cd64:	02 2b       	mov %d11,%d2
8000cd66:	6d 00 3e 03 	call 8000d3e2 <__mdiff>
8000cd6a:	19 22 0c 00 	ld.w %d2,[%a2]12
8000cd6e:	80 2d       	mov.d %d13,%a2
8000cd70:	82 1c       	mov %d12,1
8000cd72:	f6 26       	jnz %d2,8000cd7e <_dtoa_r+0xae2>
8000cd74:	40 e4       	mov.aa %a4,%a14
8000cd76:	40 25       	mov.aa %a5,%a2
8000cd78:	6d 00 14 03 	call 8000d3a0 <__mcmp>
8000cd7c:	02 2c       	mov %d12,%d2
8000cd7e:	60 d5       	mov.a %a5,%d13
8000cd80:	40 d4       	mov.aa %a4,%a13
8000cd82:	6d 00 41 01 	call 8000d004 <_Bfree>
8000cd86:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000cd8a:	1b 19 00 d0 	addi %d13,%d9,1
8000cd8e:	a6 c3       	or %d3,%d12
8000cd90:	f6 3f       	jnz %d3,8000cdae <_dtoa_r+0xb12>
8000cd92:	f6 ae       	jnz %d10,8000cdae <_dtoa_r+0xb12>
8000cd94:	8b 9f 03 32 	eq %d3,%d15,57
8000cd98:	40 e2       	mov.aa %a2,%a14
8000cd9a:	df 03 3a 80 	jne %d3,0,8000ce0e <_dtoa_r+0xb72>
8000cd9e:	1b 1e 03 20 	addi %d2,%d14,49
8000cda2:	8b 1b 80 b2 	ge %d11,%d11,1
8000cda6:	2b f2 40 fb 	sel %d15,%d11,%d2,%d15
8000cdaa:	02 de       	mov %d14,%d13
8000cdac:	3c 37       	j 8000ce1a <_dtoa_r+0xb7e>
8000cdae:	ce b5       	jgez %d11,8000cdb8 <_dtoa_r+0xb1c>
8000cdb0:	02 fa       	mov %d10,%d15
8000cdb2:	40 e2       	mov.aa %a2,%a14
8000cdb4:	4e ca       	jgtz %d12,8000cdc8 <_dtoa_r+0xb2c>
8000cdb6:	3c 1e       	j 8000cdf2 <_dtoa_r+0xb56>
8000cdb8:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000cdbc:	a6 2b       	or %d11,%d2
8000cdbe:	df 0b 20 80 	jne %d11,0,8000cdfe <_dtoa_r+0xb62>
8000cdc2:	df 0a 1e 80 	jne %d10,0,8000cdfe <_dtoa_r+0xb62>
8000cdc6:	3c f5       	j 8000cdb0 <_dtoa_r+0xb14>
8000cdc8:	40 d4       	mov.aa %a4,%a13
8000cdca:	40 e5       	mov.aa %a5,%a14
8000cdcc:	82 14       	mov %d4,1
8000cdce:	6d 00 8c 02 	call 8000d2e6 <__lshift>
8000cdd2:	40 c5       	mov.aa %a5,%a12
8000cdd4:	40 24       	mov.aa %a4,%a2
8000cdd6:	b5 a2 04 00 	st.a [%sp]4,%a2
8000cdda:	6d 00 e3 02 	call 8000d3a0 <__mcmp>
8000cdde:	99 a2 04 00 	ld.a %a2,[%sp]4
8000cde2:	4e 23       	jgtz %d2,8000cde8 <_dtoa_r+0xb4c>
8000cde4:	f6 27       	jnz %d2,8000cdf2 <_dtoa_r+0xb56>
8000cde6:	2e 06       	jz.t %d15,0,8000cdf2 <_dtoa_r+0xb56>
8000cde8:	8b 9f 03 32 	eq %d3,%d15,57
8000cdec:	df 03 11 80 	jne %d3,0,8000ce0e <_dtoa_r+0xb72>
8000cdf0:	92 1a       	add %d10,%d15,1
8000cdf2:	60 93       	mov.a %a3,%d9
8000cdf4:	02 de       	mov %d14,%d13
8000cdf6:	34 3a       	st.b [%a3],%d10
8000cdf8:	40 2e       	mov.aa %a14,%a2
8000cdfa:	1d 00 90 00 	j 8000cf1a <_dtoa_r+0xc7e>
8000cdfe:	bf 1c 11 00 	jlt %d12,1,8000ce20 <_dtoa_r+0xb84>
8000ce02:	8b 9f 23 32 	ne %d3,%d15,57
8000ce06:	40 e2       	mov.aa %a2,%a14
8000ce08:	02 de       	mov %d14,%d13
8000ce0a:	c2 1f       	add %d15,1
8000ce0c:	f6 37       	jnz %d3,8000ce1a <_dtoa_r+0xb7e>
8000ce0e:	60 93       	mov.a %a3,%d9
8000ce10:	da 39       	mov %d15,57
8000ce12:	02 de       	mov %d14,%d13
8000ce14:	2c 30       	st.b [%a3]0,%d15
8000ce16:	40 2e       	mov.aa %a14,%a2
8000ce18:	3c 5d       	j 8000ced2 <_dtoa_r+0xc36>
8000ce1a:	60 92       	mov.a %a2,%d9
8000ce1c:	2c 20       	st.b [%a2]0,%d15
8000ce1e:	3c 7e       	j 8000cf1a <_dtoa_r+0xc7e>
8000ce20:	60 93       	mov.a %a3,%d9
8000ce22:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000ce26:	02 d5       	mov %d5,%d13
8000ce28:	19 a3 10 00 	ld.w %d3,[%sp]16
8000ce2c:	2c 30       	st.b [%a3]0,%d15
8000ce2e:	a2 25       	sub %d5,%d2
8000ce30:	02 de       	mov %d14,%d13
8000ce32:	5f 35 41 00 	jeq %d5,%d3,8000ceb4 <_dtoa_r+0xc18>
8000ce36:	40 e5       	mov.aa %a5,%a14
8000ce38:	40 d4       	mov.aa %a4,%a13
8000ce3a:	fb a0 00 40 	mov %e4,10
8000ce3e:	6d 00 ec 00 	call 8000d016 <__multadd>
8000ce42:	80 ff       	mov.d %d15,%a15
8000ce44:	40 2e       	mov.aa %a14,%a2
8000ce46:	40 d4       	mov.aa %a4,%a13
8000ce48:	40 f5       	mov.aa %a5,%a15
8000ce4a:	fb a0 00 40 	mov %e4,10
8000ce4e:	7e 86       	jne %d15,%d8,8000ce5a <_dtoa_r+0xbbe>
8000ce50:	6d 00 e3 00 	call 8000d016 <__multadd>
8000ce54:	40 2f       	mov.aa %a15,%a2
8000ce56:	80 28       	mov.d %d8,%a2
8000ce58:	3c 0b       	j 8000ce6e <_dtoa_r+0xbd2>
8000ce5a:	6d 00 de 00 	call 8000d016 <__multadd>
8000ce5e:	60 85       	mov.a %a5,%d8
8000ce60:	40 d4       	mov.aa %a4,%a13
8000ce62:	fb a0 00 40 	mov %e4,10
8000ce66:	40 2f       	mov.aa %a15,%a2
8000ce68:	6d 00 d7 00 	call 8000d016 <__multadd>
8000ce6c:	80 28       	mov.d %d8,%a2
8000ce6e:	02 d9       	mov %d9,%d13
8000ce70:	1d ff 6c ff 	j 8000cd48 <_dtoa_r+0xaac>
8000ce74:	40 e5       	mov.aa %a5,%a14
8000ce76:	40 d4       	mov.aa %a4,%a13
8000ce78:	fb a0 00 40 	mov %e4,10
8000ce7c:	6d 00 cd 00 	call 8000d016 <__multadd>
8000ce80:	02 98       	mov %d8,%d9
8000ce82:	40 2e       	mov.aa %a14,%a2
8000ce84:	40 e4       	mov.aa %a4,%a14
8000ce86:	40 c5       	mov.aa %a5,%a12
8000ce88:	6d ff 7c f9 	call 8000c180 <quorem>
8000ce8c:	1b 18 00 90 	addi %d9,%d8,1
8000ce90:	1b 02 03 f0 	addi %d15,%d2,48
8000ce94:	60 82       	mov.a %a2,%d8
8000ce96:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000ce9a:	02 95       	mov %d5,%d9
8000ce9c:	19 a3 10 00 	ld.w %d3,[%sp]16
8000cea0:	2c 20       	st.b [%a2]0,%d15
8000cea2:	a2 25       	sub %d5,%d2
8000cea4:	3f 35 e8 7f 	jlt %d5,%d3,8000ce74 <_dtoa_r+0xbd8>
8000cea8:	8b 13 40 33 	max %d3,%d3,1
8000ceac:	02 2e       	mov %d14,%d2
8000ceae:	80 f8       	mov.d %d8,%a15
8000ceb0:	42 3e       	add %d14,%d3
8000ceb2:	a0 0f       	mov.a %a15,0
8000ceb4:	40 e5       	mov.aa %a5,%a14
8000ceb6:	40 d4       	mov.aa %a4,%a13
8000ceb8:	82 14       	mov %d4,1
8000ceba:	6d 00 16 02 	call 8000d2e6 <__lshift>
8000cebe:	40 c5       	mov.aa %a5,%a12
8000cec0:	40 2e       	mov.aa %a14,%a2
8000cec2:	40 24       	mov.aa %a4,%a2
8000cec4:	6d 00 6e 02 	call 8000d3a0 <__mcmp>
8000cec8:	4e 25       	jgtz %d2,8000ced2 <_dtoa_r+0xc36>
8000ceca:	df 02 1e 80 	jne %d2,0,8000cf06 <_dtoa_r+0xc6a>
8000cece:	6f 0f 1c 00 	jz.t %d15,0,8000cf06 <_dtoa_r+0xc6a>
8000ced2:	58 03       	ld.w %d15,[%sp]12
8000ced4:	a2 ef       	sub %d15,%d14
8000ced6:	46 0f       	not %d15
8000ced8:	60 e2       	mov.a %a2,%d14
8000ceda:	60 e3       	mov.a %a3,%d14
8000cedc:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000cee0:	b0 f3       	add.a %a3,-1
8000cee2:	8b 93 03 52 	eq %d5,%d3,57
8000cee6:	76 5d       	jz %d5,8000cf00 <_dtoa_r+0xc64>
8000cee8:	9f 0f 0a 80 	jned %d15,0,8000cefc <_dtoa_r+0xc60>
8000ceec:	58 02       	ld.w %d15,[%sp]8
8000ceee:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000cef2:	c2 1f       	add %d15,1
8000cef4:	78 02       	st.w [%sp]8,%d15
8000cef6:	da 31       	mov %d15,49
8000cef8:	2c 30       	st.b [%a3]0,%d15
8000cefa:	3c 10       	j 8000cf1a <_dtoa_r+0xc7e>
8000cefc:	80 3e       	mov.d %d14,%a3
8000cefe:	3c ed       	j 8000ced8 <_dtoa_r+0xc3c>
8000cf00:	c2 13       	add %d3,1
8000cf02:	34 33       	st.b [%a3],%d3
8000cf04:	3c 0b       	j 8000cf1a <_dtoa_r+0xc7e>
8000cf06:	60 e2       	mov.a %a2,%d14
8000cf08:	60 e3       	mov.a %a3,%d14
8000cf0a:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000cf0e:	b0 f3       	add.a %a3,-1
8000cf10:	8b 0f 03 f2 	eq %d15,%d15,48
8000cf14:	6e 03       	jz %d15,8000cf1a <_dtoa_r+0xc7e>
8000cf16:	80 3e       	mov.d %d14,%a3
8000cf18:	3c f7       	j 8000cf06 <_dtoa_r+0xc6a>
8000cf1a:	40 d4       	mov.aa %a4,%a13
8000cf1c:	40 c5       	mov.aa %a5,%a12
8000cf1e:	6d 00 73 00 	call 8000d004 <_Bfree>
8000cf22:	df 08 13 00 	jeq %d8,0,8000cf48 <_dtoa_r+0xcac>
8000cf26:	80 f2       	mov.d %d2,%a15
8000cf28:	8b 02 20 f2 	ne %d15,%d2,0
8000cf2c:	0b 82 10 f2 	and.ne %d15,%d2,%d8
8000cf30:	6e 05       	jz %d15,8000cf3a <_dtoa_r+0xc9e>
8000cf32:	40 d4       	mov.aa %a4,%a13
8000cf34:	40 f5       	mov.aa %a5,%a15
8000cf36:	6d 00 67 00 	call 8000d004 <_Bfree>
8000cf3a:	60 85       	mov.a %a5,%d8
8000cf3c:	40 d4       	mov.aa %a4,%a13
8000cf3e:	6d 00 63 00 	call 8000d004 <_Bfree>
8000cf42:	3c 03       	j 8000cf48 <_dtoa_r+0xcac>
8000cf44:	58 0c       	ld.w %d15,[%sp]48
8000cf46:	78 02       	st.w [%sp]8,%d15
8000cf48:	40 d4       	mov.aa %a4,%a13
8000cf4a:	40 e5       	mov.aa %a5,%a14
8000cf4c:	6d 00 5c 00 	call 8000d004 <_Bfree>
8000cf50:	60 e2       	mov.a %a2,%d14
8000cf52:	19 a2 08 00 	ld.w %d2,[%sp]8
8000cf56:	99 a3 08 10 	ld.a %a3,[%sp]72
8000cf5a:	82 0f       	mov %d15,0
8000cf5c:	d8 0e       	ld.a %a15,[%sp]56
8000cf5e:	2c 20       	st.b [%a2]0,%d15
8000cf60:	c2 12       	add %d2,1
8000cf62:	74 32       	st.w [%a3],%d2
8000cf64:	99 a2 0c 00 	ld.a %a2,[%sp]12
8000cf68:	bc f2       	jz.a %a15,8000cf6c <_dtoa_r+0xcd0>
8000cf6a:	68 0e       	st.w [%a15]0,%d14
8000cf6c:	00 90       	ret 
	...

8000cf70 <_localeconv_r>:
8000cf70:	91 00 00 28 	movh.a %a2,32768
8000cf74:	d9 22 f0 80 	lea %a2,[%a2]3632 <80000e30 <lconv>>
8000cf78:	00 90       	ret 

8000cf7a <memchr>:
8000cf7a:	8f f4 0f 41 	and %d4,%d4,255
8000cf7e:	9f 05 04 80 	jned %d5,0,8000cf86 <memchr+0xc>
8000cf82:	a0 02       	mov.a %a2,0
8000cf84:	00 90       	ret 
8000cf86:	0c 40       	ld.bu %d15,[%a4]0
8000cf88:	3e 43       	jeq %d15,%d4,8000cf8e <memchr+0x14>
8000cf8a:	b0 14       	add.a %a4,1
8000cf8c:	3c f9       	j 8000cf7e <memchr+0x4>
8000cf8e:	40 42       	mov.aa %a2,%a4
8000cf90:	00 90       	ret 

8000cf92 <memcpy>:
8000cf92:	40 42       	mov.aa %a2,%a4
8000cf94:	a0 0f       	mov.a %a15,0
8000cf96:	01 f2 10 40 	add.a %a4,%a2,%a15
8000cf9a:	01 f5 10 30 	add.a %a3,%a5,%a15
8000cf9e:	9f 04 03 80 	jned %d4,0,8000cfa4 <memcpy+0x12>
8000cfa2:	00 90       	ret 
8000cfa4:	79 3f 00 00 	ld.b %d15,[%a3]0
8000cfa8:	b0 1f       	add.a %a15,1
8000cfaa:	2c 40       	st.b [%a4]0,%d15
8000cfac:	3c f5       	j 8000cf96 <memcpy+0x4>

8000cfae <_Balloc>:
8000cfae:	19 42 0c 10 	ld.w %d2,[%a4]76
8000cfb2:	40 4f       	mov.aa %a15,%a4
8000cfb4:	02 4f       	mov %d15,%d4
8000cfb6:	76 29       	jz %d2,8000cfc8 <_Balloc+0x1a>
8000cfb8:	99 f3 0c 10 	ld.a %a3,[%a15]76
8000cfbc:	90 33       	addsc.a %a3,%a3,%d15,2
8000cfbe:	d4 32       	ld.a %a2,[%a3]
8000cfc0:	bc 2f       	jz.a %a2,8000cfde <_Balloc+0x30>
8000cfc2:	4c 20       	ld.w %d15,[%a2]0
8000cfc4:	6c 30       	st.w [%a3]0,%d15
8000cfc6:	3c 1b       	j 8000cffc <_Balloc+0x4e>
8000cfc8:	82 44       	mov %d4,4
8000cfca:	3b 10 02 50 	mov %d5,33
8000cfce:	6d 00 5c 03 	call 8000d686 <_calloc_r>
8000cfd2:	b5 f2 0c 10 	st.a [%a15]76,%a2
8000cfd6:	bd 02 f1 ff 	jnz.a %a2,8000cfb8 <_Balloc+0xa>
8000cfda:	a0 02       	mov.a %a2,0
8000cfdc:	00 90       	ret 
8000cfde:	82 18       	mov %d8,1
8000cfe0:	0f f8 00 80 	sh %d8,%d8,%d15
8000cfe4:	1b 58 00 50 	addi %d5,%d8,5
8000cfe8:	40 f4       	mov.aa %a4,%a15
8000cfea:	82 14       	mov %d4,1
8000cfec:	06 25       	sh %d5,2
8000cfee:	6d 00 4c 03 	call 8000d686 <_calloc_r>
8000cff2:	bd 02 f4 7f 	jz.a %a2,8000cfda <_Balloc+0x2c>
8000cff6:	6c 21       	st.w [%a2]4,%d15
8000cff8:	59 28 08 00 	st.w [%a2]8,%d8
8000cffc:	82 0f       	mov %d15,0
8000cffe:	6c 24       	st.w [%a2]16,%d15
8000d000:	6c 23       	st.w [%a2]12,%d15
8000d002:	00 90       	ret 

8000d004 <_Bfree>:
8000d004:	bc 58       	jz.a %a5,8000d014 <_Bfree+0x10>
8000d006:	99 4f 0c 10 	ld.a %a15,[%a4]76
8000d00a:	4c 51       	ld.w %d15,[%a5]4
8000d00c:	90 ff       	addsc.a %a15,%a15,%d15,2
8000d00e:	4c f0       	ld.w %d15,[%a15]0
8000d010:	6c 50       	st.w [%a5]0,%d15
8000d012:	e8 05       	st.a [%a15]0,%a5
8000d014:	00 90       	ret 

8000d016 <__multadd>:
8000d016:	19 59 10 00 	ld.w %d9,[%a5]16
8000d01a:	40 4c       	mov.aa %a12,%a4
8000d01c:	9a f9       	add %d15,%d9,-1
8000d01e:	8b 19 80 22 	ge %d2,%d9,1
8000d022:	40 5f       	mov.aa %a15,%a5
8000d024:	02 58       	mov %d8,%d5
8000d026:	d9 53 14 00 	lea %a3,[%a5]20
8000d02a:	ab 0f 80 22 	sel %d2,%d2,%d15,0
8000d02e:	40 32       	mov.aa %a2,%a3
8000d030:	44 25       	ld.w %d5,[%a2+]
8000d032:	b7 05 10 38 	insert %d3,%d5,0,16,16
8000d036:	8f 05 1f f0 	sh %d15,%d5,-16
8000d03a:	03 43 0a 38 	madd %d3,%d8,%d3,%d4
8000d03e:	8f 03 1f 60 	sh %d6,%d3,-16
8000d042:	03 4f 0a f6 	madd %d15,%d6,%d15,%d4
8000d046:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
8000d04a:	8f 0f 1f 80 	sh %d8,%d15,-16
8000d04e:	74 33       	st.w [%a3],%d3
8000d050:	40 23       	mov.aa %a3,%a2
8000d052:	9f 02 ee ff 	jned %d2,0,8000d02e <__multadd+0x18>
8000d056:	df 08 1f 00 	jeq %d8,0,8000d094 <__multadd+0x7e>
8000d05a:	4c f2       	ld.w %d15,[%a15]8
8000d05c:	3f f9 16 00 	jlt %d9,%d15,8000d088 <__multadd+0x72>
8000d060:	48 14       	ld.w %d4,[%a15]4
8000d062:	40 c4       	mov.aa %a4,%a12
8000d064:	c2 14       	add %d4,1
8000d066:	6d ff a4 ff 	call 8000cfae <_Balloc>
8000d06a:	48 44       	ld.w %d4,[%a15]16
8000d06c:	d9 f5 0c 00 	lea %a5,[%a15]12
8000d070:	c2 24       	add %d4,2
8000d072:	d9 24 0c 00 	lea %a4,[%a2]12
8000d076:	06 24       	sh %d4,2
8000d078:	40 2d       	mov.aa %a13,%a2
8000d07a:	6d ff 8c ff 	call 8000cf92 <memcpy>
8000d07e:	40 f5       	mov.aa %a5,%a15
8000d080:	40 c4       	mov.aa %a4,%a12
8000d082:	6d ff c1 ff 	call 8000d004 <_Bfree>
8000d086:	40 df       	mov.aa %a15,%a13
8000d088:	01 f9 02 26 	addsc.a %a2,%a15,%d9,2
8000d08c:	c2 19       	add %d9,1
8000d08e:	59 28 14 00 	st.w [%a2]20,%d8
8000d092:	68 49       	st.w [%a15]16,%d9
8000d094:	40 f2       	mov.aa %a2,%a15
8000d096:	00 90       	ret 

8000d098 <__hi0bits>:
8000d098:	b7 04 10 f0 	insert %d15,%d4,0,0,16
8000d09c:	82 02       	mov %d2,0
8000d09e:	ee 05       	jnz %d15,8000d0a8 <__hi0bits+0x10>
8000d0a0:	8f 04 01 40 	sh %d4,%d4,16
8000d0a4:	3b 00 01 20 	mov %d2,16
8000d0a8:	b7 04 18 f0 	insert %d15,%d4,0,0,24
8000d0ac:	ee 05       	jnz %d15,8000d0b6 <__hi0bits+0x1e>
8000d0ae:	1b 82 00 20 	addi %d2,%d2,8
8000d0b2:	8f 84 00 40 	sh %d4,%d4,8
8000d0b6:	b7 04 1c f0 	insert %d15,%d4,0,0,28
8000d0ba:	ee 03       	jnz %d15,8000d0c0 <__hi0bits+0x28>
8000d0bc:	c2 42       	add %d2,4
8000d0be:	06 44       	sh %d4,4
8000d0c0:	b7 04 1e f0 	insert %d15,%d4,0,0,30
8000d0c4:	ee 03       	jnz %d15,8000d0ca <__hi0bits+0x32>
8000d0c6:	c2 22       	add %d2,2
8000d0c8:	06 24       	sh %d4,2
8000d0ca:	0e 47       	jltz %d4,8000d0d8 <__hi0bits+0x40>
8000d0cc:	7b 00 00 f4 	movh %d15,16384
8000d0d0:	26 f4       	and %d4,%d15
8000d0d2:	c2 12       	add %d2,1
8000d0d4:	ab 02 82 24 	sel %d2,%d4,%d2,32
8000d0d8:	00 90       	ret 

8000d0da <__lo0bits>:
8000d0da:	54 43       	ld.w %d3,[%a4]
8000d0dc:	8f 73 00 f1 	and %d15,%d3,7
8000d0e0:	6e 0e       	jz %d15,8000d0fc <__lo0bits+0x22>
8000d0e2:	82 02       	mov %d2,0
8000d0e4:	6f 03 2d 80 	jnz.t %d3,0,8000d13e <__lo0bits+0x64>
8000d0e8:	6f 13 06 00 	jz.t %d3,1,8000d0f4 <__lo0bits+0x1a>
8000d0ec:	06 f3       	sh %d3,-1
8000d0ee:	74 43       	st.w [%a4],%d3
8000d0f0:	82 12       	mov %d2,1
8000d0f2:	00 90       	ret 
8000d0f4:	06 e3       	sh %d3,-2
8000d0f6:	74 43       	st.w [%a4],%d3
8000d0f8:	82 22       	mov %d2,2
8000d0fa:	00 90       	ret 
8000d0fc:	b7 03 10 f8 	insert %d15,%d3,0,16,16
8000d100:	82 04       	mov %d4,0
8000d102:	ee 05       	jnz %d15,8000d10c <__lo0bits+0x32>
8000d104:	8f 03 1f 30 	sh %d3,%d3,-16
8000d108:	3b 00 01 40 	mov %d4,16
8000d10c:	02 3f       	mov %d15,%d3
8000d10e:	16 ff       	and %d15,255
8000d110:	ee 04       	jnz %d15,8000d118 <__lo0bits+0x3e>
8000d112:	1b 84 00 40 	addi %d4,%d4,8
8000d116:	06 83       	sh %d3,-8
8000d118:	8f f3 00 f1 	and %d15,%d3,15
8000d11c:	ee 03       	jnz %d15,8000d122 <__lo0bits+0x48>
8000d11e:	c2 44       	add %d4,4
8000d120:	06 c3       	sh %d3,-4
8000d122:	8f 33 00 f1 	and %d15,%d3,3
8000d126:	ee 03       	jnz %d15,8000d12c <__lo0bits+0x52>
8000d128:	c2 24       	add %d4,2
8000d12a:	06 e3       	sh %d3,-2
8000d12c:	6f 03 07 80 	jnz.t %d3,0,8000d13a <__lo0bits+0x60>
8000d130:	06 f3       	sh %d3,-1
8000d132:	3b 00 02 20 	mov %d2,32
8000d136:	76 34       	jz %d3,8000d13e <__lo0bits+0x64>
8000d138:	c2 14       	add %d4,1
8000d13a:	74 43       	st.w [%a4],%d3
8000d13c:	02 42       	mov %d2,%d4
8000d13e:	00 90       	ret 

8000d140 <__i2b>:
8000d140:	02 4f       	mov %d15,%d4
8000d142:	82 14       	mov %d4,1
8000d144:	6d ff 35 ff 	call 8000cfae <_Balloc>
8000d148:	6c 25       	st.w [%a2]20,%d15
8000d14a:	82 1f       	mov %d15,1
8000d14c:	6c 24       	st.w [%a2]16,%d15
8000d14e:	00 90       	ret 

8000d150 <__multiply>:
8000d150:	19 52 10 00 	ld.w %d2,[%a5]16
8000d154:	4c 64       	ld.w %d15,[%a6]16
8000d156:	40 5f       	mov.aa %a15,%a5
8000d158:	40 6c       	mov.aa %a12,%a6
8000d15a:	7f f2 04 00 	jge %d2,%d15,8000d162 <__multiply+0x12>
8000d15e:	40 6f       	mov.aa %a15,%a6
8000d160:	40 5c       	mov.aa %a12,%a5
8000d162:	48 4a       	ld.w %d10,[%a15]16
8000d164:	19 c9 10 00 	ld.w %d9,[%a12]16
8000d168:	4c f2       	ld.w %d15,[%a15]8
8000d16a:	0b 9a 00 80 	add %d8,%d10,%d9
8000d16e:	48 12       	ld.w %d2,[%a15]4
8000d170:	0b 8f 20 41 	lt %d4,%d15,%d8
8000d174:	42 24       	add %d4,%d2
8000d176:	6d ff 1c ff 	call 8000cfae <_Balloc>
8000d17a:	d9 23 14 00 	lea %a3,[%a2]20
8000d17e:	01 38 02 d6 	addsc.a %a13,%a3,%d8,2
8000d182:	40 34       	mov.aa %a4,%a3
8000d184:	82 0f       	mov %d15,0
8000d186:	80 43       	mov.d %d3,%a4
8000d188:	80 d2       	mov.d %d2,%a13
8000d18a:	7f 23 04 80 	jge.u %d3,%d2,8000d192 <__multiply+0x42>
8000d18e:	64 4f       	st.w [%a4+],%d15
8000d190:	3c fb       	j 8000d186 <__multiply+0x36>
8000d192:	d9 ff 14 00 	lea %a15,[%a15]20
8000d196:	d9 cc 14 00 	lea %a12,[%a12]20
8000d19a:	80 f3       	mov.d %d3,%a15
8000d19c:	80 cf       	mov.d %d15,%a12
8000d19e:	13 4a 20 43 	madd %d4,%d3,%d10,4
8000d1a2:	13 49 20 0f 	madd %d0,%d15,%d9,4
8000d1a6:	80 c2       	mov.d %d2,%a12
8000d1a8:	7f 02 54 80 	jge.u %d2,%d0,8000d250 <__multiply+0x100>
8000d1ac:	b9 c2 00 00 	ld.hu %d2,[%a12]0
8000d1b0:	40 34       	mov.aa %a4,%a3
8000d1b2:	40 f6       	mov.aa %a6,%a15
8000d1b4:	82 03       	mov %d3,0
8000d1b6:	df 02 21 00 	jeq %d2,0,8000d1f8 <__multiply+0xa8>
8000d1ba:	40 45       	mov.aa %a5,%a4
8000d1bc:	44 67       	ld.w %d7,[%a6+]
8000d1be:	44 56       	ld.w %d6,[%a5+]
8000d1c0:	b7 07 10 18 	insert %d1,%d7,0,16,16
8000d1c4:	b7 06 10 58 	insert %d5,%d6,0,16,16
8000d1c8:	8f 07 1f 70 	sh %d7,%d7,-16
8000d1cc:	03 21 0a 55 	madd %d5,%d5,%d1,%d2
8000d1d0:	8f 06 1f 60 	sh %d6,%d6,-16
8000d1d4:	03 27 0a 66 	madd %d6,%d6,%d7,%d2
8000d1d8:	42 35       	add %d5,%d3
8000d1da:	8f 05 1f 30 	sh %d3,%d5,-16
8000d1de:	1a 36       	add %d15,%d6,%d3
8000d1e0:	37 f5 10 58 	insert %d5,%d5,%d15,16,16
8000d1e4:	8f 0f 1f 30 	sh %d3,%d15,-16
8000d1e8:	80 6f       	mov.d %d15,%a6
8000d1ea:	74 45       	st.w [%a4],%d5
8000d1ec:	7f 4f 04 80 	jge.u %d15,%d4,8000d1f4 <__multiply+0xa4>
8000d1f0:	40 54       	mov.aa %a4,%a5
8000d1f2:	3c e4       	j 8000d1ba <__multiply+0x6a>
8000d1f4:	59 43 04 00 	st.w [%a4]4,%d3
8000d1f8:	b9 c2 02 00 	ld.hu %d2,[%a12]2
8000d1fc:	df 02 27 00 	jeq %d2,0,8000d24a <__multiply+0xfa>
8000d200:	54 33       	ld.w %d3,[%a3]
8000d202:	40 34       	mov.aa %a4,%a3
8000d204:	40 f5       	mov.aa %a5,%a15
8000d206:	82 07       	mov %d7,0
8000d208:	40 56       	mov.aa %a6,%a5
8000d20a:	44 66       	ld.w %d6,[%a6+]
8000d20c:	40 47       	mov.aa %a7,%a4
8000d20e:	44 75       	ld.w %d5,[%a7+]
8000d210:	b7 06 10 68 	insert %d6,%d6,0,16,16
8000d214:	8f 05 1f 50 	sh %d5,%d5,-16
8000d218:	03 26 0a f5 	madd %d15,%d5,%d6,%d2
8000d21c:	42 7f       	add %d15,%d7
8000d21e:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
8000d222:	8f 0f 1f f0 	sh %d15,%d15,-16
8000d226:	74 43       	st.w [%a4],%d3
8000d228:	b9 55 02 00 	ld.hu %d5,[%a5]2
8000d22c:	b9 43 04 00 	ld.hu %d3,[%a4]4
8000d230:	40 65       	mov.aa %a5,%a6
8000d232:	03 25 0a 33 	madd %d3,%d3,%d5,%d2
8000d236:	42 f3       	add %d3,%d15
8000d238:	80 6f       	mov.d %d15,%a6
8000d23a:	8f 03 1f 70 	sh %d7,%d3,-16
8000d23e:	7f 4f 04 80 	jge.u %d15,%d4,8000d246 <__multiply+0xf6>
8000d242:	40 74       	mov.aa %a4,%a7
8000d244:	3c e2       	j 8000d208 <__multiply+0xb8>
8000d246:	59 43 04 00 	st.w [%a4]4,%d3
8000d24a:	b0 4c       	add.a %a12,4
8000d24c:	b0 43       	add.a %a3,4
8000d24e:	3c ac       	j 8000d1a6 <__multiply+0x56>
8000d250:	8b 08 40 f3 	max %d15,%d8,0
8000d254:	9f 0f 05 80 	jned %d15,0,8000d25e <__multiply+0x10e>
8000d258:	59 28 10 00 	st.w [%a2]16,%d8
8000d25c:	00 90       	ret 
8000d25e:	09 d2 3c f5 	ld.w %d2,[+%a13]-4
8000d262:	df 02 fb ff 	jne %d2,0,8000d258 <__multiply+0x108>
8000d266:	c2 f8       	add %d8,-1
8000d268:	3c f6       	j 8000d254 <__multiply+0x104>

8000d26a <__pow5mult>:
8000d26a:	8f 34 00 21 	and %d2,%d4,3
8000d26e:	40 4c       	mov.aa %a12,%a4
8000d270:	40 5d       	mov.aa %a13,%a5
8000d272:	02 4f       	mov %d15,%d4
8000d274:	76 2d       	jz %d2,8000d28e <__pow5mult+0x24>
8000d276:	91 00 00 f8 	movh.a %a15,32768
8000d27a:	d9 ff e8 90 	lea %a15,[%a15]3688 <80000e68 <p05.2553>>
8000d27e:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
8000d282:	82 05       	mov %d5,0
8000d284:	19 f4 fc ff 	ld.w %d4,[%a15]-4
8000d288:	6d ff c7 fe 	call 8000d016 <__multadd>
8000d28c:	40 2d       	mov.aa %a13,%a2
8000d28e:	86 ef       	sha %d15,-2
8000d290:	6e 29       	jz %d15,8000d2e2 <__pow5mult+0x78>
8000d292:	99 cf 08 10 	ld.a %a15,[%a12]72
8000d296:	7c fb       	jnz.a %a15,8000d2ac <__pow5mult+0x42>
8000d298:	40 c4       	mov.aa %a4,%a12
8000d29a:	3b 10 27 40 	mov %d4,625
8000d29e:	6d ff 51 ff 	call 8000d140 <__i2b>
8000d2a2:	82 02       	mov %d2,0
8000d2a4:	b5 c2 08 10 	st.a [%a12]72,%a2
8000d2a8:	40 2f       	mov.aa %a15,%a2
8000d2aa:	74 22       	st.w [%a2],%d2
8000d2ac:	82 08       	mov %d8,0
8000d2ae:	2e 0c       	jz.t %d15,0,8000d2c6 <__pow5mult+0x5c>
8000d2b0:	40 d5       	mov.aa %a5,%a13
8000d2b2:	40 c4       	mov.aa %a4,%a12
8000d2b4:	40 f6       	mov.aa %a6,%a15
8000d2b6:	6d ff 4d ff 	call 8000d150 <__multiply>
8000d2ba:	40 d5       	mov.aa %a5,%a13
8000d2bc:	40 2e       	mov.aa %a14,%a2
8000d2be:	40 c4       	mov.aa %a4,%a12
8000d2c0:	6d ff a2 fe 	call 8000d004 <_Bfree>
8000d2c4:	40 ed       	mov.aa %a13,%a14
8000d2c6:	86 ff       	sha %d15,-1
8000d2c8:	6e 0d       	jz %d15,8000d2e2 <__pow5mult+0x78>
8000d2ca:	c8 02       	ld.a %a2,[%a15]0
8000d2cc:	bc 23       	jz.a %a2,8000d2d2 <__pow5mult+0x68>
8000d2ce:	40 2f       	mov.aa %a15,%a2
8000d2d0:	3c ef       	j 8000d2ae <__pow5mult+0x44>
8000d2d2:	40 c4       	mov.aa %a4,%a12
8000d2d4:	40 f5       	mov.aa %a5,%a15
8000d2d6:	40 f6       	mov.aa %a6,%a15
8000d2d8:	6d ff 3c ff 	call 8000d150 <__multiply>
8000d2dc:	e8 02       	st.a [%a15]0,%a2
8000d2de:	74 28       	st.w [%a2],%d8
8000d2e0:	3c f7       	j 8000d2ce <__pow5mult+0x64>
8000d2e2:	40 d2       	mov.aa %a2,%a13
8000d2e4:	00 90       	ret 

8000d2e6 <__lshift>:
8000d2e6:	19 5b 10 00 	ld.w %d11,[%a5]16
8000d2ea:	8f b4 3f 80 	sha %d8,%d4,-5
8000d2ee:	02 4a       	mov %d10,%d4
8000d2f0:	42 8b       	add %d11,%d8
8000d2f2:	19 54 04 00 	ld.w %d4,[%a5]4
8000d2f6:	4c 52       	ld.w %d15,[%a5]8
8000d2f8:	40 4e       	mov.aa %a14,%a4
8000d2fa:	40 5c       	mov.aa %a12,%a5
8000d2fc:	1b 1b 00 90 	addi %d9,%d11,1
8000d300:	7f 9f 05 00 	jge %d15,%d9,8000d30a <__lshift+0x24>
8000d304:	c2 14       	add %d4,1
8000d306:	06 1f       	sh %d15,1
8000d308:	3c fc       	j 8000d300 <__lshift+0x1a>
8000d30a:	40 e4       	mov.aa %a4,%a14
8000d30c:	6d ff 51 fe 	call 8000cfae <_Balloc>
8000d310:	8b 08 40 f3 	max %d15,%d8,0
8000d314:	40 2d       	mov.aa %a13,%a2
8000d316:	d9 2f 14 00 	lea %a15,[%a2]20
8000d31a:	d2 02       	mov %e2,0
8000d31c:	01 f2 02 26 	addsc.a %a2,%a15,%d2,2
8000d320:	9f 0f 03 80 	jned %d15,0,8000d326 <__lshift+0x40>
8000d324:	3c 04       	j 8000d32c <__lshift+0x46>
8000d326:	74 23       	st.w [%a2],%d3
8000d328:	c2 12       	add %d2,1
8000d32a:	3c f9       	j 8000d31c <__lshift+0x36>
8000d32c:	8b 08 40 83 	max %d8,%d8,0
8000d330:	01 f8 02 36 	addsc.a %a3,%a15,%d8,2
8000d334:	d9 cf 14 00 	lea %a15,[%a12]20
8000d338:	19 c2 10 00 	ld.w %d2,[%a12]16
8000d33c:	80 f3       	mov.d %d3,%a15
8000d33e:	8f fa 01 41 	and %d4,%d10,31
8000d342:	13 42 20 23 	madd %d2,%d3,%d2,4
8000d346:	8b 04 02 51 	rsub %d5,%d4,32
8000d34a:	82 0f       	mov %d15,0
8000d34c:	df 04 1a 00 	jeq %d4,0,8000d380 <__lshift+0x9a>
8000d350:	40 f5       	mov.aa %a5,%a15
8000d352:	44 53       	ld.w %d3,[%a5+]
8000d354:	d9 32 04 00 	lea %a2,[%a3]4
8000d358:	0f 43 00 30 	sh %d3,%d3,%d4
8000d35c:	a6 3f       	or %d15,%d3
8000d35e:	6c 30       	st.w [%a3]0,%d15
8000d360:	4c f0       	ld.w %d15,[%a15]0
8000d362:	8b 05 00 31 	rsub %d3,%d5,0
8000d366:	0f 3f 00 30 	sh %d3,%d15,%d3
8000d36a:	02 3f       	mov %d15,%d3
8000d36c:	80 53       	mov.d %d3,%a5
8000d36e:	40 5f       	mov.aa %a15,%a5
8000d370:	7f 23 04 80 	jge.u %d3,%d2,8000d378 <__lshift+0x92>
8000d374:	40 23       	mov.aa %a3,%a2
8000d376:	3c ed       	j 8000d350 <__lshift+0x6a>
8000d378:	c2 2b       	add %d11,2
8000d37a:	6c 31       	st.w [%a3]4,%d15
8000d37c:	2a b9       	cmov %d9,%d15,%d11
8000d37e:	3c 08       	j 8000d38e <__lshift+0xa8>
8000d380:	4c f0       	ld.w %d15,[%a15]0
8000d382:	b0 4f       	add.a %a15,4
8000d384:	80 f3       	mov.d %d3,%a15
8000d386:	6c 30       	st.w [%a3]0,%d15
8000d388:	b0 43       	add.a %a3,4
8000d38a:	3f 23 fb ff 	jlt.u %d3,%d2,8000d380 <__lshift+0x9a>
8000d38e:	c2 f9       	add %d9,-1
8000d390:	59 d9 10 00 	st.w [%a13]16,%d9
8000d394:	40 e4       	mov.aa %a4,%a14
8000d396:	40 c5       	mov.aa %a5,%a12
8000d398:	6d ff 36 fe 	call 8000d004 <_Bfree>
8000d39c:	40 d2       	mov.aa %a2,%a13
8000d39e:	00 90       	ret 

8000d3a0 <__mcmp>:
8000d3a0:	4c 54       	ld.w %d15,[%a5]16
8000d3a2:	19 42 10 00 	ld.w %d2,[%a4]16
8000d3a6:	a2 f2       	sub %d2,%d15
8000d3a8:	df 02 1c 80 	jne %d2,0,8000d3e0 <__mcmp+0x40>
8000d3ac:	80 42       	mov.d %d2,%a4
8000d3ae:	06 2f       	sh %d15,2
8000d3b0:	60 f2       	mov.a %a2,%d15
8000d3b2:	1b 42 01 30 	addi %d3,%d2,20
8000d3b6:	d9 55 14 00 	lea %a5,[%a5]20
8000d3ba:	01 23 00 f6 	addsc.a %a15,%a2,%d3,0
8000d3be:	30 25       	add.a %a5,%a2
8000d3c0:	09 f2 3c f5 	ld.w %d2,[+%a15]-4
8000d3c4:	09 5f 3c f5 	ld.w %d15,[+%a5]-4
8000d3c8:	5f f2 08 00 	jeq %d2,%d15,8000d3d8 <__mcmp+0x38>
8000d3cc:	0b f2 30 21 	lt.u %d2,%d2,%d15
8000d3d0:	82 f3       	mov %d3,-1
8000d3d2:	ab 13 80 22 	sel %d2,%d2,%d3,1
8000d3d6:	00 90       	ret 
8000d3d8:	80 ff       	mov.d %d15,%a15
8000d3da:	3f f3 f3 ff 	jlt.u %d3,%d15,8000d3c0 <__mcmp+0x20>
8000d3de:	82 02       	mov %d2,0
8000d3e0:	00 90       	ret 

8000d3e2 <__mdiff>:
8000d3e2:	40 4d       	mov.aa %a13,%a4
8000d3e4:	40 5f       	mov.aa %a15,%a5
8000d3e6:	40 54       	mov.aa %a4,%a5
8000d3e8:	40 65       	mov.aa %a5,%a6
8000d3ea:	40 6c       	mov.aa %a12,%a6
8000d3ec:	6d ff da ff 	call 8000d3a0 <__mcmp>
8000d3f0:	02 2f       	mov %d15,%d2
8000d3f2:	f6 2a       	jnz %d2,8000d406 <__mdiff+0x24>
8000d3f4:	40 d4       	mov.aa %a4,%a13
8000d3f6:	82 04       	mov %d4,0
8000d3f8:	6d ff db fd 	call 8000cfae <_Balloc>
8000d3fc:	82 12       	mov %d2,1
8000d3fe:	59 22 10 00 	st.w [%a2]16,%d2
8000d402:	6c 25       	st.w [%a2]20,%d15
8000d404:	00 90       	ret 
8000d406:	82 08       	mov %d8,0
8000d408:	ce 25       	jgez %d2,8000d412 <__mdiff+0x30>
8000d40a:	40 f2       	mov.aa %a2,%a15
8000d40c:	82 18       	mov %d8,1
8000d40e:	40 cf       	mov.aa %a15,%a12
8000d410:	40 2c       	mov.aa %a12,%a2
8000d412:	40 d4       	mov.aa %a4,%a13
8000d414:	48 14       	ld.w %d4,[%a15]4
8000d416:	6d ff cc fd 	call 8000cfae <_Balloc>
8000d41a:	48 42       	ld.w %d2,[%a15]16
8000d41c:	d9 ff 14 00 	lea %a15,[%a15]20
8000d420:	80 ff       	mov.d %d15,%a15
8000d422:	d9 c4 14 00 	lea %a4,[%a12]20
8000d426:	13 42 20 7f 	madd %d7,%d15,%d2,4
8000d42a:	19 c0 10 00 	ld.w %d0,[%a12]16
8000d42e:	80 4f       	mov.d %d15,%a4
8000d430:	59 28 0c 00 	st.w [%a2]12,%d8
8000d434:	13 40 20 0f 	madd %d0,%d15,%d0,4
8000d438:	d9 25 14 00 	lea %a5,[%a2]20
8000d43c:	82 03       	mov %d3,0
8000d43e:	44 f6       	ld.w %d6,[%a15+]
8000d440:	44 45       	ld.w %d5,[%a4+]
8000d442:	b7 06 10 48 	insert %d4,%d6,0,16,16
8000d446:	b7 05 10 18 	insert %d1,%d5,0,16,16
8000d44a:	42 34       	add %d4,%d3
8000d44c:	a2 14       	sub %d4,%d1
8000d44e:	8f 06 1f 60 	sh %d6,%d6,-16
8000d452:	8f 05 1f 50 	sh %d5,%d5,-16
8000d456:	8f 04 3f 30 	sha %d3,%d4,-16
8000d45a:	0b 56 80 50 	sub %d5,%d6,%d5
8000d45e:	1a 35       	add %d15,%d5,%d3
8000d460:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8000d464:	8f 0f 3f 30 	sha %d3,%d15,-16
8000d468:	80 4f       	mov.d %d15,%a4
8000d46a:	d9 53 04 00 	lea %a3,[%a5]4
8000d46e:	74 54       	st.w [%a5],%d4
8000d470:	40 35       	mov.aa %a5,%a3
8000d472:	3f 0f e6 ff 	jlt.u %d15,%d0,8000d43e <__mdiff+0x5c>
8000d476:	80 ff       	mov.d %d15,%a15
8000d478:	7f 7f 12 80 	jge.u %d15,%d7,8000d49c <__mdiff+0xba>
8000d47c:	44 f5       	ld.w %d5,[%a15+]
8000d47e:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000d482:	8f 05 1f 50 	sh %d5,%d5,-16
8000d486:	42 34       	add %d4,%d3
8000d488:	8f 04 3f f0 	sha %d15,%d4,-16
8000d48c:	42 5f       	add %d15,%d5
8000d48e:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8000d492:	8f 0f 3f 30 	sha %d3,%d15,-16
8000d496:	74 34       	st.w [%a3],%d4
8000d498:	b0 43       	add.a %a3,4
8000d49a:	3c ee       	j 8000d476 <__mdiff+0x94>
8000d49c:	09 3f 3c f5 	ld.w %d15,[+%a3]-4
8000d4a0:	ee 03       	jnz %d15,8000d4a6 <__mdiff+0xc4>
8000d4a2:	c2 f2       	add %d2,-1
8000d4a4:	3c fc       	j 8000d49c <__mdiff+0xba>
8000d4a6:	59 22 10 00 	st.w [%a2]16,%d2
8000d4aa:	00 90       	ret 

8000d4ac <__d2b>:
8000d4ac:	20 08       	sub.a %sp,8
8000d4ae:	02 48       	mov %d8,%d4
8000d4b0:	82 14       	mov %d4,1
8000d4b2:	02 59       	mov %d9,%d5
8000d4b4:	40 5d       	mov.aa %a13,%a5
8000d4b6:	40 6c       	mov.aa %a12,%a6
8000d4b8:	6d ff 7b fd 	call 8000cfae <_Balloc>
8000d4bc:	b7 09 0c 2a 	insert %d2,%d9,0,20,12
8000d4c0:	37 09 6b 9a 	extr.u %d9,%d9,20,11
8000d4c4:	40 2f       	mov.aa %a15,%a2
8000d4c6:	76 93       	jz %d9,8000d4cc <__d2b+0x20>
8000d4c8:	b7 f2 01 2a 	insert %d2,%d2,15,20,1
8000d4cc:	59 a2 04 00 	st.w [%sp]4,%d2
8000d4d0:	df 08 20 00 	jeq %d8,0,8000d510 <__d2b+0x64>
8000d4d4:	d9 a4 08 00 	lea %a4,[%sp]8
8000d4d8:	89 48 38 f5 	st.w [+%a4]-8,%d8
8000d4dc:	40 a4       	mov.aa %a4,%sp
8000d4de:	6d ff fe fd 	call 8000d0da <__lo0bits>
8000d4e2:	58 00       	ld.w %d15,[%sp]0
8000d4e4:	76 2f       	jz %d2,8000d502 <__d2b+0x56>
8000d4e6:	19 a4 04 00 	ld.w %d4,[%sp]4
8000d4ea:	8b 02 02 31 	rsub %d3,%d2,32
8000d4ee:	0f 34 00 30 	sh %d3,%d4,%d3
8000d4f2:	a6 3f       	or %d15,%d3
8000d4f4:	68 5f       	st.w [%a15]20,%d15
8000d4f6:	8b 02 00 f1 	rsub %d15,%d2,0
8000d4fa:	0f f4 00 f0 	sh %d15,%d4,%d15
8000d4fe:	78 01       	st.w [%sp]4,%d15
8000d500:	3c 02       	j 8000d504 <__d2b+0x58>
8000d502:	68 5f       	st.w [%a15]20,%d15
8000d504:	58 01       	ld.w %d15,[%sp]4
8000d506:	82 28       	mov %d8,2
8000d508:	ea 18       	cmovn %d8,%d15,1
8000d50a:	68 6f       	st.w [%a15]24,%d15
8000d50c:	68 48       	st.w [%a15]16,%d8
8000d50e:	3c 0c       	j 8000d526 <__d2b+0x7a>
8000d510:	d9 a4 04 00 	lea %a4,[%sp]4
8000d514:	6d ff e3 fd 	call 8000d0da <__lo0bits>
8000d518:	58 01       	ld.w %d15,[%sp]4
8000d51a:	1b 02 02 20 	addi %d2,%d2,32
8000d51e:	68 5f       	st.w [%a15]20,%d15
8000d520:	82 1f       	mov %d15,1
8000d522:	68 4f       	st.w [%a15]16,%d15
8000d524:	82 18       	mov %d8,1
8000d526:	76 98       	jz %d9,8000d536 <__d2b+0x8a>
8000d528:	1b d9 bc 9f 	addi %d9,%d9,-1075
8000d52c:	42 29       	add %d9,%d2
8000d52e:	74 d9       	st.w [%a13],%d9
8000d530:	8b 52 03 21 	rsub %d2,%d2,53
8000d534:	3c 0d       	j 8000d54e <__d2b+0xa2>
8000d536:	01 f8 02 26 	addsc.a %a2,%a15,%d8,2
8000d53a:	1b e2 bc 2f 	addi %d2,%d2,-1074
8000d53e:	74 d2       	st.w [%a13],%d2
8000d540:	19 24 10 00 	ld.w %d4,[%a2]16
8000d544:	6d ff aa fd 	call 8000d098 <__hi0bits>
8000d548:	06 58       	sh %d8,5
8000d54a:	0b 28 80 20 	sub %d2,%d8,%d2
8000d54e:	74 c2       	st.w [%a12],%d2
8000d550:	40 f2       	mov.aa %a2,%a15
8000d552:	00 90       	ret 

8000d554 <__fpclassifyd>:
8000d554:	0f 45 a0 f0 	or %d15,%d5,%d4
8000d558:	82 22       	mov %d2,2
8000d55a:	6e 1d       	jz %d15,8000d594 <__fpclassifyd+0x40>
8000d55c:	7b 00 00 38 	movh %d3,32768
8000d560:	3a 53       	eq %d15,%d3,%d5
8000d562:	8b 04 00 f4 	and.eq %d15,%d4,0
8000d566:	8b 04 00 62 	eq %d6,%d4,0
8000d56a:	ee 15       	jnz %d15,8000d594 <__fpclassifyd+0x40>
8000d56c:	b7 05 81 5f 	insert %d5,%d5,0,31,1
8000d570:	7b 00 fe f7 	movh %d15,32736
8000d574:	9b 05 ff 3f 	addih %d3,%d5,65520
8000d578:	82 42       	mov %d2,4
8000d57a:	3f f3 0d 80 	jlt.u %d3,%d15,8000d594 <__fpclassifyd+0x40>
8000d57e:	7b 00 01 f0 	movh %d15,16
8000d582:	82 32       	mov %d2,3
8000d584:	3f f5 08 80 	jlt.u %d5,%d15,8000d594 <__fpclassifyd+0x40>
8000d588:	7b 00 ff 27 	movh %d2,32752
8000d58c:	0b 25 00 51 	eq %d5,%d5,%d2
8000d590:	0f 56 80 20 	and %d2,%d6,%d5
8000d594:	00 90       	ret 

8000d596 <__ssprint_r>:
8000d596:	4c 62       	ld.w %d15,[%a6]8
8000d598:	20 08       	sub.a %sp,8
8000d59a:	40 4e       	mov.aa %a14,%a4
8000d59c:	40 5f       	mov.aa %a15,%a5
8000d59e:	40 6c       	mov.aa %a12,%a6
8000d5a0:	54 6c       	ld.w %d12,[%a6]
8000d5a2:	6e 30       	jz %d15,8000d602 <__ssprint_r+0x6c>
8000d5a4:	a0 02       	mov.a %a2,0
8000d5a6:	b5 a2 04 00 	st.a [%sp]4,%a2
8000d5aa:	82 09       	mov %d9,0
8000d5ac:	3b 00 48 e0 	mov %d14,1152
8000d5b0:	3b f0 b7 df 	mov %d13,-1153
8000d5b4:	3c 0a       	j 8000d5c8 <__ssprint_r+0x32>
8000d5b6:	60 c2       	mov.a %a2,%d12
8000d5b8:	d4 22       	ld.a %a2,[%a2]
8000d5ba:	b5 a2 04 00 	st.a [%sp]4,%a2
8000d5be:	60 c2       	mov.a %a2,%d12
8000d5c0:	1b 8c 00 c0 	addi %d12,%d12,8
8000d5c4:	19 29 04 00 	ld.w %d9,[%a2]4
8000d5c8:	df 09 f7 7f 	jeq %d9,0,8000d5b6 <__ssprint_r+0x20>
8000d5cc:	48 28       	ld.w %d8,[%a15]8
8000d5ce:	3f 89 5a 80 	jlt.u %d9,%d8,8000d682 <__ssprint_r+0xec>
8000d5d2:	88 62       	ld.h %d2,[%a15]12
8000d5d4:	0f e2 80 f0 	and %d15,%d2,%d14
8000d5d8:	ee 19       	jnz %d15,8000d60a <__ssprint_r+0x74>
8000d5da:	3f 89 54 80 	jlt.u %d9,%d8,8000d682 <__ssprint_r+0xec>
8000d5de:	c8 04       	ld.a %a4,[%a15]0
8000d5e0:	99 a5 04 00 	ld.a %a5,[%sp]4 <0 <NULL>>
8000d5e4:	02 84       	mov %d4,%d8
8000d5e6:	6d 00 81 00 	call 8000d6e8 <memmove>
8000d5ea:	4c f2       	ld.w %d15,[%a15]8
8000d5ec:	a2 8f       	sub %d15,%d8
8000d5ee:	68 2f       	st.w [%a15]8,%d15
8000d5f0:	4c f0       	ld.w %d15,[%a15]0
8000d5f2:	42 f8       	add %d8,%d15
8000d5f4:	4c c2       	ld.w %d15,[%a12]8
8000d5f6:	68 08       	st.w [%a15]0,%d8
8000d5f8:	52 99       	sub %d9,%d15,%d9
8000d5fa:	59 c9 08 00 	st.w [%a12]8,%d9
8000d5fe:	df 09 dc ff 	jne %d9,0,8000d5b6 <__ssprint_r+0x20>
8000d602:	82 0f       	mov %d15,0
8000d604:	6c c1       	st.w [%a12]4,%d15
8000d606:	82 02       	mov %d2,0
8000d608:	00 90       	ret 
8000d60a:	c8 45       	ld.a %a5,[%a15]16
8000d60c:	48 5a       	ld.w %d10,[%a15]20
8000d60e:	4c f0       	ld.w %d15,[%a15]0
8000d610:	80 53       	mov.d %d3,%a5
8000d612:	53 3a 20 a0 	mul %d10,%d10,3
8000d616:	a2 3f       	sub %d15,%d3
8000d618:	82 23       	mov %d3,2
8000d61a:	4b 3a 01 a2 	div %e10,%d10,%d3
8000d61e:	92 13       	add %d3,%d15,1
8000d620:	42 93       	add %d3,%d9
8000d622:	0b 3a b0 a1 	max.u %d10,%d10,%d3
8000d626:	40 e4       	mov.aa %a4,%a14
8000d628:	02 a4       	mov %d4,%d10
8000d62a:	6f a2 12 00 	jz.t %d2,10,8000d64e <__ssprint_r+0xb8>
8000d62e:	6d ff 0c e9 	call 8000a846 <_malloc_r>
8000d632:	40 2d       	mov.aa %a13,%a2
8000d634:	bd 02 15 00 	jz.a %a2,8000d65e <__ssprint_r+0xc8>
8000d638:	c8 45       	ld.a %a5,[%a15]16
8000d63a:	40 24       	mov.aa %a4,%a2
8000d63c:	02 f4       	mov %d4,%d15
8000d63e:	6d ff aa fc 	call 8000cf92 <memcpy>
8000d642:	88 62       	ld.h %d2,[%a15]12
8000d644:	26 d2       	and %d2,%d13
8000d646:	8f 02 48 21 	or %d2,%d2,128
8000d64a:	a8 62       	st.h [%a15]12,%d2
8000d64c:	3c 13       	j 8000d672 <__ssprint_r+0xdc>
8000d64e:	6d 00 7d 00 	call 8000d748 <_realloc_r>
8000d652:	40 2d       	mov.aa %a13,%a2
8000d654:	7c 2f       	jnz.a %a2,8000d672 <__ssprint_r+0xdc>
8000d656:	c8 45       	ld.a %a5,[%a15]16
8000d658:	40 e4       	mov.aa %a4,%a14
8000d65a:	6d ff eb eb 	call 8000ae30 <_free_r>
8000d65e:	da 0c       	mov %d15,12
8000d660:	6c e0       	st.w [%a14]0,%d15
8000d662:	8c f6       	ld.h %d15,[%a15]12
8000d664:	82 f2       	mov %d2,-1
8000d666:	96 40       	or %d15,64
8000d668:	a8 6f       	st.h [%a15]12,%d15
8000d66a:	82 0f       	mov %d15,0
8000d66c:	6c c2       	st.w [%a12]8,%d15
8000d66e:	6c c1       	st.w [%a12]4,%d15
8000d670:	00 90       	ret 
8000d672:	e8 4d       	st.a [%a15]16,%a13
8000d674:	10 dd       	addsc.a %a13,%a13,%d15,0
8000d676:	68 5a       	st.w [%a15]20,%d10
8000d678:	a2 fa       	sub %d10,%d15
8000d67a:	e8 0d       	st.a [%a15]0,%a13
8000d67c:	02 98       	mov %d8,%d9
8000d67e:	68 2a       	st.w [%a15]8,%d10
8000d680:	3c ad       	j 8000d5da <__ssprint_r+0x44>
8000d682:	02 98       	mov %d8,%d9
8000d684:	3c ad       	j 8000d5de <__ssprint_r+0x48>

8000d686 <_calloc_r>:
8000d686:	e2 54       	mul %d4,%d5
8000d688:	6d ff df e8 	call 8000a846 <_malloc_r>
8000d68c:	40 2f       	mov.aa %a15,%a2
8000d68e:	a0 02       	mov.a %a2,0
8000d690:	bd 0f 2b 00 	jz.a %a15,8000d6e6 <_calloc_r+0x60>
8000d694:	19 f5 fc ff 	ld.w %d5,[%a15]-4
8000d698:	8f 35 c0 51 	andn %d5,%d5,3
8000d69c:	c2 c5       	add %d5,-4
8000d69e:	8b 55 a2 f2 	ge.u %d15,%d5,37
8000d6a2:	ee 1d       	jnz %d15,8000d6dc <_calloc_r+0x56>
8000d6a4:	8b 45 61 f2 	lt.u %d15,%d5,20
8000d6a8:	40 f2       	mov.aa %a2,%a15
8000d6aa:	ee 14       	jnz %d15,8000d6d2 <_calloc_r+0x4c>
8000d6ac:	82 0f       	mov %d15,0
8000d6ae:	68 0f       	st.w [%a15]0,%d15
8000d6b0:	68 1f       	st.w [%a15]4,%d15
8000d6b2:	8b c5 a1 22 	ge.u %d2,%d5,28
8000d6b6:	d9 f2 08 00 	lea %a2,[%a15]8
8000d6ba:	76 2c       	jz %d2,8000d6d2 <_calloc_r+0x4c>
8000d6bc:	68 2f       	st.w [%a15]8,%d15
8000d6be:	68 3f       	st.w [%a15]12,%d15
8000d6c0:	8b 45 02 52 	eq %d5,%d5,36
8000d6c4:	d9 f2 10 00 	lea %a2,[%a15]16
8000d6c8:	76 55       	jz %d5,8000d6d2 <_calloc_r+0x4c>
8000d6ca:	68 4f       	st.w [%a15]16,%d15
8000d6cc:	d9 f2 18 00 	lea %a2,[%a15]24
8000d6d0:	68 5f       	st.w [%a15]20,%d15
8000d6d2:	82 0f       	mov %d15,0
8000d6d4:	6c 20       	st.w [%a2]0,%d15
8000d6d6:	6c 21       	st.w [%a2]4,%d15
8000d6d8:	6c 22       	st.w [%a2]8,%d15
8000d6da:	3c 05       	j 8000d6e4 <_calloc_r+0x5e>
8000d6dc:	40 f4       	mov.aa %a4,%a15
8000d6de:	82 04       	mov %d4,0
8000d6e0:	6d 00 2c 00 	call 8000d738 <memset>
8000d6e4:	40 f2       	mov.aa %a2,%a15
8000d6e6:	00 90       	ret 

8000d6e8 <memmove>:
8000d6e8:	80 46       	mov.d %d6,%a4
8000d6ea:	80 52       	mov.d %d2,%a5
8000d6ec:	7f 62 16 80 	jge.u %d2,%d6,8000d718 <memmove+0x30>
8000d6f0:	0b 42 00 50 	add %d5,%d2,%d4
8000d6f4:	7f 56 12 80 	jge.u %d6,%d5,8000d718 <memmove+0x30>
8000d6f8:	60 4f       	mov.a %a15,%d4
8000d6fa:	02 42       	mov %d2,%d4
8000d6fc:	c2 f2       	add %d2,-1
8000d6fe:	fd f0 03 00 	loop %a15,8000d704 <memmove+0x1c>
8000d702:	3c 19       	j 8000d734 <memmove+0x4c>
8000d704:	5a 42       	sub %d15,%d2,%d4
8000d706:	60 f2       	mov.a %a2,%d15
8000d708:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
8000d70c:	1a 62       	add %d15,%d2,%d6
8000d70e:	79 23 00 00 	ld.b %d3,[%a2]0
8000d712:	60 f2       	mov.a %a2,%d15
8000d714:	34 23       	st.b [%a2],%d3
8000d716:	3c f3       	j 8000d6fc <memmove+0x14>
8000d718:	60 4f       	mov.a %a15,%d4
8000d71a:	a0 02       	mov.a %a2,0
8000d71c:	01 26 00 46 	addsc.a %a4,%a2,%d6,0
8000d720:	01 22 00 36 	addsc.a %a3,%a2,%d2,0
8000d724:	fd f0 03 00 	loop %a15,8000d72a <memmove+0x42>
8000d728:	3c 06       	j 8000d734 <memmove+0x4c>
8000d72a:	79 33 00 00 	ld.b %d3,[%a3]0
8000d72e:	b0 12       	add.a %a2,1
8000d730:	34 43       	st.b [%a4],%d3
8000d732:	3c f5       	j 8000d71c <memmove+0x34>
8000d734:	60 62       	mov.a %a2,%d6
8000d736:	00 90       	ret 

8000d738 <memset>:
8000d738:	40 42       	mov.aa %a2,%a4
8000d73a:	40 4f       	mov.aa %a15,%a4
8000d73c:	9f 05 03 80 	jned %d5,0,8000d742 <memset+0xa>
8000d740:	00 90       	ret 
8000d742:	28 04       	st.b [%a15]0,%d4
8000d744:	b0 1f       	add.a %a15,1
8000d746:	3c fb       	j 8000d73c <memset+0x4>

8000d748 <_realloc_r>:
8000d748:	40 4d       	mov.aa %a13,%a4
8000d74a:	40 5f       	mov.aa %a15,%a5
8000d74c:	02 49       	mov %d9,%d4
8000d74e:	7c 53       	jnz.a %a5,8000d754 <_realloc_r+0xc>
8000d750:	1d ff 7b e8 	j 8000a846 <_malloc_r>
8000d754:	6d ff c6 ea 	call 8000ace0 <__malloc_lock>
8000d758:	1b b9 00 20 	addi %d2,%d9,11
8000d75c:	8b 72 61 f2 	lt.u %d15,%d2,23
8000d760:	8f 72 c0 21 	andn %d2,%d2,7
8000d764:	ab 02 a1 ff 	seln %d15,%d15,%d2,16
8000d768:	19 f3 fc ff 	ld.w %d3,[%a15]-4
8000d76c:	0b 9f 30 21 	lt.u %d2,%d15,%d9
8000d770:	8b 0f 20 25 	or.lt %d2,%d15,0
8000d774:	d9 fe f8 ff 	lea %a14,[%a15]-8
8000d778:	8f 33 c0 81 	andn %d8,%d3,3
8000d77c:	76 25       	jz %d2,8000d786 <_realloc_r+0x3e>
8000d77e:	da 0c       	mov %d15,12
8000d780:	6c d0       	st.w [%a13]0,%d15
8000d782:	1d 00 56 01 	j 8000da2e <_realloc_r+0x2e6>
8000d786:	7f f8 ac 01 	jge %d8,%d15,8000dade <_realloc_r+0x396>
8000d78a:	7b 00 00 c7 	movh %d12,28672
8000d78e:	60 c3       	mov.a %a3,%d12
8000d790:	01 e8 00 26 	addsc.a %a2,%a14,%d8,0
8000d794:	d9 34 38 30 	lea %a4,[%a3]248
8000d798:	99 43 08 00 	ld.a %a3,[%a4]8
8000d79c:	80 4c       	mov.d %d12,%a4
8000d79e:	19 2b 04 00 	ld.w %d11,[%a2]4
8000d7a2:	7d 32 0a 00 	jeq.a %a2,%a3,8000d7b6 <_realloc_r+0x6e>
8000d7a6:	8f 1b c0 21 	andn %d2,%d11,1
8000d7aa:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
8000d7ae:	19 42 04 00 	ld.w %d2,[%a4]4
8000d7b2:	6f 02 2b 80 	jnz.t %d2,0,8000d808 <_realloc_r+0xc0>
8000d7b6:	8f 3b c0 b1 	andn %d11,%d11,3
8000d7ba:	0b 8b 00 20 	add %d2,%d11,%d8
8000d7be:	7d 32 1b 80 	jne.a %a2,%a3,8000d7f4 <_realloc_r+0xac>
8000d7c2:	1b 0f 01 40 	addi %d4,%d15,16
8000d7c6:	3f 42 23 00 	jlt %d2,%d4,8000d80c <_realloc_r+0xc4>
8000d7ca:	10 ee       	addsc.a %a14,%a14,%d15,0
8000d7cc:	60 c2       	mov.a %a2,%d12
8000d7ce:	a2 f2       	sub %d2,%d15
8000d7d0:	b5 2e 08 00 	st.a [%a2]8,%a14
8000d7d4:	8f 12 40 21 	or %d2,%d2,1
8000d7d8:	59 e2 04 00 	st.w [%a14]4,%d2
8000d7dc:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8000d7e0:	40 d4       	mov.aa %a4,%a13
8000d7e2:	8f 12 00 21 	and %d2,%d2,1
8000d7e6:	a6 2f       	or %d15,%d2
8000d7e8:	59 ff fc ff 	st.w [%a15]-4,%d15
8000d7ec:	6d ff 7b ea 	call 8000ace2 <__malloc_unlock>
8000d7f0:	40 f2       	mov.aa %a2,%a15
8000d7f2:	00 90       	ret 
8000d7f4:	3f f2 0c 00 	jlt %d2,%d15,8000d80c <_realloc_r+0xc4>
8000d7f8:	cc 23       	ld.a %a15,[%a2]12
8000d7fa:	99 22 08 00 	ld.a %a2,[%a2]8
8000d7fe:	02 28       	mov %d8,%d2
8000d800:	ec 23       	st.a [%a2]12,%a15
8000d802:	e8 22       	st.a [%a15]8,%a2
8000d804:	1d 00 6d 01 	j 8000dade <_realloc_r+0x396>
8000d808:	82 0b       	mov %d11,0
8000d80a:	a0 02       	mov.a %a2,0
8000d80c:	6f 03 08 81 	jnz.t %d3,0,8000da1c <_realloc_r+0x2d4>
8000d810:	99 fc f8 ff 	ld.a %a12,[%a15]-8
8000d814:	01 ce 20 c0 	sub.a %a12,%a14,%a12
8000d818:	19 ca 04 00 	ld.w %d10,[%a12]4
8000d81c:	8f 3a c0 a1 	andn %d10,%d10,3
8000d820:	42 8a       	add %d10,%d8
8000d822:	bd 02 b3 00 	jz.a %a2,8000d988 <_realloc_r+0x240>
8000d826:	42 ab       	add %d11,%d10
8000d828:	7d 32 5f 80 	jne.a %a2,%a3,8000d8e6 <_realloc_r+0x19e>
8000d82c:	1b 0f 01 20 	addi %d2,%d15,16
8000d830:	3f 2b ac 00 	jlt %d11,%d2,8000d988 <_realloc_r+0x240>
8000d834:	40 ce       	mov.aa %a14,%a12
8000d836:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000d83a:	09 e3 88 05 	ld.a %a3,[+%a14]8
8000d83e:	1b c8 ff 4f 	addi %d4,%d8,-4
8000d842:	8b 54 a2 22 	ge.u %d2,%d4,37
8000d846:	b5 32 0c 00 	st.a [%a3]12,%a2
8000d84a:	b5 23 08 00 	st.a [%a2]8,%a3
8000d84e:	df 02 36 80 	jne %d2,0,8000d8ba <_realloc_r+0x172>
8000d852:	8b 44 61 22 	lt.u %d2,%d4,20
8000d856:	40 e3       	mov.aa %a3,%a14
8000d858:	df 02 28 80 	jne %d2,0,8000d8a8 <_realloc_r+0x160>
8000d85c:	48 02       	ld.w %d2,[%a15]0
8000d85e:	59 c2 08 00 	st.w [%a12]8,%d2
8000d862:	48 13       	ld.w %d3,[%a15]4
8000d864:	8b c4 a1 22 	ge.u %d2,%d4,28
8000d868:	59 c3 0c 00 	st.w [%a12]12,%d3
8000d86c:	f6 26       	jnz %d2,8000d878 <_realloc_r+0x130>
8000d86e:	d9 c3 10 00 	lea %a3,[%a12]16
8000d872:	d9 ff 08 00 	lea %a15,[%a15]8
8000d876:	3c 19       	j 8000d8a8 <_realloc_r+0x160>
8000d878:	48 22       	ld.w %d2,[%a15]8
8000d87a:	8b 44 02 82 	eq %d8,%d4,36
8000d87e:	59 c2 10 00 	st.w [%a12]16,%d2
8000d882:	48 33       	ld.w %d3,[%a15]12
8000d884:	59 c3 14 00 	st.w [%a12]20,%d3
8000d888:	f6 86       	jnz %d8,8000d894 <_realloc_r+0x14c>
8000d88a:	d9 c3 18 00 	lea %a3,[%a12]24
8000d88e:	d9 ff 10 00 	lea %a15,[%a15]16
8000d892:	3c 0b       	j 8000d8a8 <_realloc_r+0x160>
8000d894:	48 42       	ld.w %d2,[%a15]16
8000d896:	d9 c3 20 00 	lea %a3,[%a12]32
8000d89a:	59 c2 18 00 	st.w [%a12]24,%d2
8000d89e:	48 53       	ld.w %d3,[%a15]20
8000d8a0:	d9 ff 18 00 	lea %a15,[%a15]24
8000d8a4:	59 c3 1c 00 	st.w [%a12]28,%d3
8000d8a8:	48 02       	ld.w %d2,[%a15]0
8000d8aa:	74 32       	st.w [%a3],%d2
8000d8ac:	48 13       	ld.w %d3,[%a15]4
8000d8ae:	59 33 04 00 	st.w [%a3]4,%d3
8000d8b2:	48 22       	ld.w %d2,[%a15]8
8000d8b4:	59 32 08 00 	st.w [%a3]8,%d2
8000d8b8:	3c 05       	j 8000d8c2 <_realloc_r+0x17a>
8000d8ba:	40 e4       	mov.aa %a4,%a14
8000d8bc:	40 f5       	mov.aa %a5,%a15
8000d8be:	6d ff 15 ff 	call 8000d6e8 <memmove>
8000d8c2:	10 cf       	addsc.a %a15,%a12,%d15,0
8000d8c4:	60 c2       	mov.a %a2,%d12
8000d8c6:	a2 fb       	sub %d11,%d15
8000d8c8:	ec 22       	st.a [%a2]8,%a15
8000d8ca:	8f 1b 40 b1 	or %d11,%d11,1
8000d8ce:	68 1b       	st.w [%a15]4,%d11
8000d8d0:	19 c2 04 00 	ld.w %d2,[%a12]4
8000d8d4:	40 d4       	mov.aa %a4,%a13
8000d8d6:	8f 12 00 21 	and %d2,%d2,1
8000d8da:	a6 2f       	or %d15,%d2
8000d8dc:	6c c1       	st.w [%a12]4,%d15
8000d8de:	6d ff 02 ea 	call 8000ace2 <__malloc_unlock>
8000d8e2:	40 e2       	mov.aa %a2,%a14
8000d8e4:	00 90       	ret 
8000d8e6:	3f fb 51 00 	jlt %d11,%d15,8000d988 <_realloc_r+0x240>
8000d8ea:	99 23 0c 00 	ld.a %a3,[%a2]12
8000d8ee:	99 22 08 00 	ld.a %a2,[%a2]8
8000d8f2:	40 c4       	mov.aa %a4,%a12
8000d8f4:	1b c8 ff 4f 	addi %d4,%d8,-4
8000d8f8:	b5 23 0c 00 	st.a [%a2]12,%a3
8000d8fc:	b5 32 08 00 	st.a [%a3]8,%a2
8000d900:	09 43 88 05 	ld.a %a3,[+%a4]8
8000d904:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000d908:	8b 54 a2 22 	ge.u %d2,%d4,37
8000d90c:	b5 32 0c 00 	st.a [%a3]12,%a2
8000d910:	b5 23 08 00 	st.a [%a2]8,%a3
8000d914:	df 02 35 80 	jne %d2,0,8000d97e <_realloc_r+0x236>
8000d918:	8b 44 61 22 	lt.u %d2,%d4,20
8000d91c:	df 02 28 80 	jne %d2,0,8000d96c <_realloc_r+0x224>
8000d920:	48 02       	ld.w %d2,[%a15]0
8000d922:	59 c2 08 00 	st.w [%a12]8,%d2
8000d926:	48 13       	ld.w %d3,[%a15]4
8000d928:	8b c4 a1 22 	ge.u %d2,%d4,28
8000d92c:	59 c3 0c 00 	st.w [%a12]12,%d3
8000d930:	f6 26       	jnz %d2,8000d93c <_realloc_r+0x1f4>
8000d932:	d9 c4 10 00 	lea %a4,[%a12]16
8000d936:	d9 ff 08 00 	lea %a15,[%a15]8
8000d93a:	3c 19       	j 8000d96c <_realloc_r+0x224>
8000d93c:	48 22       	ld.w %d2,[%a15]8
8000d93e:	8b 44 02 82 	eq %d8,%d4,36
8000d942:	59 c2 10 00 	st.w [%a12]16,%d2
8000d946:	48 33       	ld.w %d3,[%a15]12
8000d948:	59 c3 14 00 	st.w [%a12]20,%d3
8000d94c:	f6 86       	jnz %d8,8000d958 <_realloc_r+0x210>
8000d94e:	d9 c4 18 00 	lea %a4,[%a12]24
8000d952:	d9 ff 10 00 	lea %a15,[%a15]16
8000d956:	3c 0b       	j 8000d96c <_realloc_r+0x224>
8000d958:	48 42       	ld.w %d2,[%a15]16
8000d95a:	d9 c4 20 00 	lea %a4,[%a12]32
8000d95e:	59 c2 18 00 	st.w [%a12]24,%d2
8000d962:	48 53       	ld.w %d3,[%a15]20
8000d964:	d9 ff 18 00 	lea %a15,[%a15]24
8000d968:	59 c3 1c 00 	st.w [%a12]28,%d3
8000d96c:	48 02       	ld.w %d2,[%a15]0
8000d96e:	74 42       	st.w [%a4],%d2
8000d970:	48 13       	ld.w %d3,[%a15]4
8000d972:	59 43 04 00 	st.w [%a4]4,%d3
8000d976:	48 22       	ld.w %d2,[%a15]8
8000d978:	59 42 08 00 	st.w [%a4]8,%d2
8000d97c:	3c 04       	j 8000d984 <_realloc_r+0x23c>
8000d97e:	40 f5       	mov.aa %a5,%a15
8000d980:	6d ff b4 fe 	call 8000d6e8 <memmove>
8000d984:	02 b8       	mov %d8,%d11
8000d986:	3c 45       	j 8000da10 <_realloc_r+0x2c8>
8000d988:	3f fa 4a 00 	jlt %d10,%d15,8000da1c <_realloc_r+0x2d4>
8000d98c:	40 c4       	mov.aa %a4,%a12
8000d98e:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000d992:	09 43 88 05 	ld.a %a3,[+%a4]8
8000d996:	1b c8 ff 4f 	addi %d4,%d8,-4
8000d99a:	8b 54 a2 22 	ge.u %d2,%d4,37
8000d99e:	b5 32 0c 00 	st.a [%a3]12,%a2
8000d9a2:	b5 23 08 00 	st.a [%a2]8,%a3
8000d9a6:	df 02 37 80 	jne %d2,0,8000da14 <_realloc_r+0x2cc>
8000d9aa:	8b 44 61 22 	lt.u %d2,%d4,20
8000d9ae:	df 02 28 80 	jne %d2,0,8000d9fe <_realloc_r+0x2b6>
8000d9b2:	48 03       	ld.w %d3,[%a15]0
8000d9b4:	59 c3 08 00 	st.w [%a12]8,%d3
8000d9b8:	48 12       	ld.w %d2,[%a15]4
8000d9ba:	59 c2 0c 00 	st.w [%a12]12,%d2
8000d9be:	8b c4 a1 22 	ge.u %d2,%d4,28
8000d9c2:	f6 26       	jnz %d2,8000d9ce <_realloc_r+0x286>
8000d9c4:	d9 c4 10 00 	lea %a4,[%a12]16
8000d9c8:	d9 ff 08 00 	lea %a15,[%a15]8
8000d9cc:	3c 19       	j 8000d9fe <_realloc_r+0x2b6>
8000d9ce:	48 23       	ld.w %d3,[%a15]8
8000d9d0:	8b 44 02 82 	eq %d8,%d4,36
8000d9d4:	59 c3 10 00 	st.w [%a12]16,%d3
8000d9d8:	48 32       	ld.w %d2,[%a15]12
8000d9da:	59 c2 14 00 	st.w [%a12]20,%d2
8000d9de:	f6 86       	jnz %d8,8000d9ea <_realloc_r+0x2a2>
8000d9e0:	d9 c4 18 00 	lea %a4,[%a12]24
8000d9e4:	d9 ff 10 00 	lea %a15,[%a15]16
8000d9e8:	3c 0b       	j 8000d9fe <_realloc_r+0x2b6>
8000d9ea:	48 43       	ld.w %d3,[%a15]16
8000d9ec:	d9 c4 20 00 	lea %a4,[%a12]32
8000d9f0:	59 c3 18 00 	st.w [%a12]24,%d3
8000d9f4:	48 52       	ld.w %d2,[%a15]20
8000d9f6:	d9 ff 18 00 	lea %a15,[%a15]24
8000d9fa:	59 c2 1c 00 	st.w [%a12]28,%d2
8000d9fe:	48 03       	ld.w %d3,[%a15]0
8000da00:	74 43       	st.w [%a4],%d3
8000da02:	48 12       	ld.w %d2,[%a15]4
8000da04:	59 42 04 00 	st.w [%a4]4,%d2
8000da08:	48 23       	ld.w %d3,[%a15]8
8000da0a:	59 43 08 00 	st.w [%a4]8,%d3
8000da0e:	02 a8       	mov %d8,%d10
8000da10:	40 ce       	mov.aa %a14,%a12
8000da12:	3c 66       	j 8000dade <_realloc_r+0x396>
8000da14:	40 f5       	mov.aa %a5,%a15
8000da16:	6d ff 69 fe 	call 8000d6e8 <memmove>
8000da1a:	3c fa       	j 8000da0e <_realloc_r+0x2c6>
8000da1c:	40 d4       	mov.aa %a4,%a13
8000da1e:	02 94       	mov %d4,%d9
8000da20:	6d ff 13 e7 	call 8000a846 <_malloc_r>
8000da24:	40 2c       	mov.aa %a12,%a2
8000da26:	7c 26       	jnz.a %a2,8000da32 <_realloc_r+0x2ea>
8000da28:	40 d4       	mov.aa %a4,%a13
8000da2a:	6d ff 5c e9 	call 8000ace2 <__malloc_unlock>
8000da2e:	a0 02       	mov.a %a2,0
8000da30:	00 90       	ret 
8000da32:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8000da36:	d9 23 f8 ff 	lea %a3,[%a2]-8
8000da3a:	8f 12 c0 21 	andn %d2,%d2,1
8000da3e:	01 e2 00 26 	addsc.a %a2,%a14,%d2,0
8000da42:	80 32       	mov.d %d2,%a3
8000da44:	80 23       	mov.d %d3,%a2
8000da46:	5f 32 08 80 	jne %d2,%d3,8000da56 <_realloc_r+0x30e>
8000da4a:	19 c2 fc ff 	ld.w %d2,[%a12]-4
8000da4e:	8f 32 c0 21 	andn %d2,%d2,3
8000da52:	42 28       	add %d8,%d2
8000da54:	3c 45       	j 8000dade <_realloc_r+0x396>
8000da56:	1b c8 ff 4f 	addi %d4,%d8,-4
8000da5a:	8b 54 a2 f2 	ge.u %d15,%d4,37
8000da5e:	ee 33       	jnz %d15,8000dac4 <_realloc_r+0x37c>
8000da60:	8b 44 61 f2 	lt.u %d15,%d4,20
8000da64:	40 c3       	mov.aa %a3,%a12
8000da66:	40 f2       	mov.aa %a2,%a15
8000da68:	ee 23       	jnz %d15,8000daae <_realloc_r+0x366>
8000da6a:	4c f0       	ld.w %d15,[%a15]0
8000da6c:	d9 c3 08 00 	lea %a3,[%a12]8
8000da70:	6c c0       	st.w [%a12]0,%d15
8000da72:	48 12       	ld.w %d2,[%a15]4
8000da74:	8b c4 a1 f2 	ge.u %d15,%d4,28
8000da78:	59 c2 04 00 	st.w [%a12]4,%d2
8000da7c:	d9 f2 08 00 	lea %a2,[%a15]8
8000da80:	6e 17       	jz %d15,8000daae <_realloc_r+0x366>
8000da82:	48 23       	ld.w %d3,[%a15]8
8000da84:	8b 44 02 82 	eq %d8,%d4,36
8000da88:	59 c3 08 00 	st.w [%a12]8,%d3
8000da8c:	4c f3       	ld.w %d15,[%a15]12
8000da8e:	d9 c3 10 00 	lea %a3,[%a12]16
8000da92:	6c c3       	st.w [%a12]12,%d15
8000da94:	d9 f2 10 00 	lea %a2,[%a15]16
8000da98:	76 8b       	jz %d8,8000daae <_realloc_r+0x366>
8000da9a:	48 42       	ld.w %d2,[%a15]16
8000da9c:	d9 c3 18 00 	lea %a3,[%a12]24
8000daa0:	59 c2 10 00 	st.w [%a12]16,%d2
8000daa4:	48 53       	ld.w %d3,[%a15]20
8000daa6:	d9 f2 18 00 	lea %a2,[%a15]24
8000daaa:	59 c3 14 00 	st.w [%a12]20,%d3
8000daae:	4c 20       	ld.w %d15,[%a2]0
8000dab0:	6c 30       	st.w [%a3]0,%d15
8000dab2:	19 22 04 00 	ld.w %d2,[%a2]4
8000dab6:	59 32 04 00 	st.w [%a3]4,%d2
8000daba:	19 23 08 00 	ld.w %d3,[%a2]8
8000dabe:	59 33 08 00 	st.w [%a3]8,%d3
8000dac2:	3c 05       	j 8000dacc <_realloc_r+0x384>
8000dac4:	40 c4       	mov.aa %a4,%a12
8000dac6:	40 f5       	mov.aa %a5,%a15
8000dac8:	6d ff 10 fe 	call 8000d6e8 <memmove>
8000dacc:	40 d4       	mov.aa %a4,%a13
8000dace:	40 f5       	mov.aa %a5,%a15
8000dad0:	6d ff b0 e9 	call 8000ae30 <_free_r>
8000dad4:	40 d4       	mov.aa %a4,%a13
8000dad6:	6d ff 06 e9 	call 8000ace2 <__malloc_unlock>
8000dada:	40 c2       	mov.aa %a2,%a12
8000dadc:	00 90       	ret 
8000dade:	0b f8 80 20 	sub %d2,%d8,%d15
8000dae2:	8b 02 61 42 	lt.u %d4,%d2,16
8000dae6:	19 e3 04 00 	ld.w %d3,[%a14]4
8000daea:	df 04 16 80 	jne %d4,0,8000db16 <_realloc_r+0x3ce>
8000daee:	8f 13 00 31 	and %d3,%d3,1
8000daf2:	10 e5       	addsc.a %a5,%a14,%d15,0
8000daf4:	a6 3f       	or %d15,%d3
8000daf6:	6c e1       	st.w [%a14]4,%d15
8000daf8:	01 52 00 f6 	addsc.a %a15,%a5,%d2,0
8000dafc:	8f 12 40 f1 	or %d15,%d2,1
8000db00:	b7 10 21 20 	imask %e2,1,0,1
8000db04:	6c 51       	st.w [%a5]4,%d15
8000db06:	49 f2 44 08 	ldmst [%a15]4,%e2
8000db0a:	40 d4       	mov.aa %a4,%a13
8000db0c:	d9 55 08 00 	lea %a5,[%a5]8
8000db10:	6d ff 90 e9 	call 8000ae30 <_free_r>
8000db14:	3c 0c       	j 8000db2c <_realloc_r+0x3e4>
8000db16:	8f 13 00 31 	and %d3,%d3,1
8000db1a:	a6 83       	or %d3,%d8
8000db1c:	59 e3 04 00 	st.w [%a14]4,%d3
8000db20:	01 e8 00 f6 	addsc.a %a15,%a14,%d8,0
8000db24:	b7 10 21 20 	imask %e2,1,0,1
8000db28:	49 f2 44 08 	ldmst [%a15]4,%e2
8000db2c:	40 d4       	mov.aa %a4,%a13
8000db2e:	6d ff da e8 	call 8000ace2 <__malloc_unlock>
8000db32:	d9 e2 08 00 	lea %a2,[%a14]8
8000db36:	00 90       	ret 

8000db38 <_exit>:
8000db38:	76 43       	jz %d4,8000db3e <_exit+0x6>
8000db3a:	60 4e       	mov.a %a14,%d4
8000db3c:	3c 04       	j 8000db44 <_exit+0xc>
8000db3e:	bb d0 00 f9 	mov.u %d15,36877
8000db42:	60 fe       	mov.a %a14,%d15
8000db44:	00 a0       	debug 
8000db46:	3c 00       	j 8000db46 <_exit+0xe>

8000db48 <sbrk>:
8000db48:	91 00 00 f7 	movh.a %a15,28672
8000db4c:	19 ff a8 40 	ld.w %d15,[%a15]2344 <70000928 <heap_top.2289>>
8000db50:	7b 00 00 27 	movh %d2,28672
8000db54:	42 f4       	add %d4,%d15
8000db56:	1b 02 c5 20 	addi %d2,%d2,3152
8000db5a:	7f 42 09 80 	jge.u %d2,%d4,8000db6c <sbrk+0x24>
8000db5e:	6d 00 13 00 	call 8000db84 <__errno>
8000db62:	da 0c       	mov %d15,12
8000db64:	6c 20       	st.w [%a2]0,%d15
8000db66:	a0 02       	mov.a %a2,0
8000db68:	b0 f2       	add.a %a2,-1
8000db6a:	00 90       	ret 
8000db6c:	7b 00 00 27 	movh %d2,28672
8000db70:	1b 02 c5 20 	addi %d2,%d2,3152
8000db74:	7f 24 04 80 	jge.u %d4,%d2,8000db7c <sbrk+0x34>
8000db78:	6d 00 0b 00 	call 8000db8e <abort>
8000db7c:	59 f4 a8 40 	st.w [%a15]2344,%d4
8000db80:	60 f2       	mov.a %a2,%d15
8000db82:	00 90       	ret 

8000db84 <__errno>:
8000db84:	91 00 00 27 	movh.a %a2,28672
8000db88:	d9 22 c8 10 	lea %a2,[%a2]3144 <70000c48 <_my_errno>>
8000db8c:	00 90       	ret 

8000db8e <abort>:
8000db8e:	00 a0       	debug 
8000db90:	7b e0 ea fd 	movh %d15,57006
8000db94:	1b ff ee fb 	addi %d15,%d15,-16657
8000db98:	60 fe       	mov.a %a14,%d15
8000db9a:	1d ff cf ff 	j 8000db38 <_exit>
8000db9e:	3c 00       	j 8000db9e <abort+0x10>

8000dba0 <__eqdf2>:
8000dba0:	20 38       	sub.a %sp,56
8000dba2:	40 a4       	mov.aa %a4,%sp
8000dba4:	d9 a5 10 00 	lea %a5,[%sp]16
8000dba8:	89 a4 40 09 	st.d [%sp],%e4
8000dbac:	89 a6 48 09 	st.d [%sp]8,%e6
8000dbb0:	6d ff 85 e5 	call 8000a6ba <__unpack_d>
8000dbb4:	d9 a4 08 00 	lea %a4,[%sp]8
8000dbb8:	d9 a5 24 00 	lea %a5,[%sp]36
8000dbbc:	6d ff 7f e5 	call 8000a6ba <__unpack_d>
8000dbc0:	39 af 10 00 	ld.bu %d15,[%sp]16
8000dbc4:	82 12       	mov %d2,1
8000dbc6:	bf 2f 0c 80 	jlt.u %d15,2,8000dbde <__eqdf2+0x3e>
8000dbca:	39 af 24 00 	ld.bu %d15,[%sp]36
8000dbce:	bf 2f 08 80 	jlt.u %d15,2,8000dbde <__eqdf2+0x3e>
8000dbd2:	d9 a4 10 00 	lea %a4,[%sp]16
8000dbd6:	d9 a5 24 00 	lea %a5,[%sp]36
8000dbda:	6d 00 0d 01 	call 8000ddf4 <__fpcmp_parts_d>
8000dbde:	00 90       	ret 

8000dbe0 <__nedf2>:
8000dbe0:	20 38       	sub.a %sp,56
8000dbe2:	40 a4       	mov.aa %a4,%sp
8000dbe4:	d9 a5 10 00 	lea %a5,[%sp]16
8000dbe8:	89 a4 40 09 	st.d [%sp],%e4
8000dbec:	89 a6 48 09 	st.d [%sp]8,%e6
8000dbf0:	6d ff 65 e5 	call 8000a6ba <__unpack_d>
8000dbf4:	d9 a4 08 00 	lea %a4,[%sp]8
8000dbf8:	d9 a5 24 00 	lea %a5,[%sp]36
8000dbfc:	6d ff 5f e5 	call 8000a6ba <__unpack_d>
8000dc00:	39 af 10 00 	ld.bu %d15,[%sp]16
8000dc04:	82 12       	mov %d2,1
8000dc06:	bf 2f 0c 80 	jlt.u %d15,2,8000dc1e <__nedf2+0x3e>
8000dc0a:	39 af 24 00 	ld.bu %d15,[%sp]36
8000dc0e:	bf 2f 08 80 	jlt.u %d15,2,8000dc1e <__nedf2+0x3e>
8000dc12:	d9 a4 10 00 	lea %a4,[%sp]16
8000dc16:	d9 a5 24 00 	lea %a5,[%sp]36
8000dc1a:	6d 00 ed 00 	call 8000ddf4 <__fpcmp_parts_d>
8000dc1e:	00 90       	ret 

8000dc20 <__gtdf2>:
8000dc20:	20 38       	sub.a %sp,56
8000dc22:	40 a4       	mov.aa %a4,%sp
8000dc24:	d9 a5 10 00 	lea %a5,[%sp]16
8000dc28:	89 a4 40 09 	st.d [%sp],%e4
8000dc2c:	89 a6 48 09 	st.d [%sp]8,%e6
8000dc30:	6d ff 45 e5 	call 8000a6ba <__unpack_d>
8000dc34:	d9 a4 08 00 	lea %a4,[%sp]8
8000dc38:	d9 a5 24 00 	lea %a5,[%sp]36
8000dc3c:	6d ff 3f e5 	call 8000a6ba <__unpack_d>
8000dc40:	39 af 10 00 	ld.bu %d15,[%sp]16
8000dc44:	82 f2       	mov %d2,-1
8000dc46:	bf 2f 0c 80 	jlt.u %d15,2,8000dc5e <__gtdf2+0x3e>
8000dc4a:	39 af 24 00 	ld.bu %d15,[%sp]36
8000dc4e:	bf 2f 08 80 	jlt.u %d15,2,8000dc5e <__gtdf2+0x3e>
8000dc52:	d9 a4 10 00 	lea %a4,[%sp]16
8000dc56:	d9 a5 24 00 	lea %a5,[%sp]36
8000dc5a:	6d 00 cd 00 	call 8000ddf4 <__fpcmp_parts_d>
8000dc5e:	00 90       	ret 

8000dc60 <__gedf2>:
8000dc60:	20 38       	sub.a %sp,56
8000dc62:	40 a4       	mov.aa %a4,%sp
8000dc64:	d9 a5 10 00 	lea %a5,[%sp]16
8000dc68:	89 a4 40 09 	st.d [%sp],%e4
8000dc6c:	89 a6 48 09 	st.d [%sp]8,%e6
8000dc70:	6d ff 25 e5 	call 8000a6ba <__unpack_d>
8000dc74:	d9 a4 08 00 	lea %a4,[%sp]8
8000dc78:	d9 a5 24 00 	lea %a5,[%sp]36
8000dc7c:	6d ff 1f e5 	call 8000a6ba <__unpack_d>
8000dc80:	39 af 10 00 	ld.bu %d15,[%sp]16
8000dc84:	82 f2       	mov %d2,-1
8000dc86:	bf 2f 0c 80 	jlt.u %d15,2,8000dc9e <__gedf2+0x3e>
8000dc8a:	39 af 24 00 	ld.bu %d15,[%sp]36
8000dc8e:	bf 2f 08 80 	jlt.u %d15,2,8000dc9e <__gedf2+0x3e>
8000dc92:	d9 a4 10 00 	lea %a4,[%sp]16
8000dc96:	d9 a5 24 00 	lea %a5,[%sp]36
8000dc9a:	6d 00 ad 00 	call 8000ddf4 <__fpcmp_parts_d>
8000dc9e:	00 90       	ret 

8000dca0 <__ltdf2>:
8000dca0:	20 38       	sub.a %sp,56
8000dca2:	40 a4       	mov.aa %a4,%sp
8000dca4:	d9 a5 10 00 	lea %a5,[%sp]16
8000dca8:	89 a4 40 09 	st.d [%sp],%e4
8000dcac:	89 a6 48 09 	st.d [%sp]8,%e6
8000dcb0:	6d ff 05 e5 	call 8000a6ba <__unpack_d>
8000dcb4:	d9 a4 08 00 	lea %a4,[%sp]8
8000dcb8:	d9 a5 24 00 	lea %a5,[%sp]36
8000dcbc:	6d ff ff e4 	call 8000a6ba <__unpack_d>
8000dcc0:	39 af 10 00 	ld.bu %d15,[%sp]16
8000dcc4:	82 12       	mov %d2,1
8000dcc6:	bf 2f 0c 80 	jlt.u %d15,2,8000dcde <__ltdf2+0x3e>
8000dcca:	39 af 24 00 	ld.bu %d15,[%sp]36
8000dcce:	bf 2f 08 80 	jlt.u %d15,2,8000dcde <__ltdf2+0x3e>
8000dcd2:	d9 a4 10 00 	lea %a4,[%sp]16
8000dcd6:	d9 a5 24 00 	lea %a5,[%sp]36
8000dcda:	6d 00 8d 00 	call 8000ddf4 <__fpcmp_parts_d>
8000dcde:	00 90       	ret 

8000dce0 <__fixdfsi>:
8000dce0:	20 20       	sub.a %sp,32
8000dce2:	d9 a4 20 00 	lea %a4,[%sp]32
8000dce6:	89 44 64 f5 	st.d [+%a4]-28,%e4
8000dcea:	d9 a5 0c 00 	lea %a5,[%sp]12
8000dcee:	6d ff e6 e4 	call 8000a6ba <__unpack_d>
8000dcf2:	0c ac       	ld.bu %d15,[%sp]12
8000dcf4:	82 02       	mov %d2,0
8000dcf6:	bf 3f 1b 80 	jlt.u %d15,3,8000dd2c <__fixdfsi+0x4c>
8000dcfa:	5e 48       	jne %d15,4,8000dd0a <__fixdfsi+0x2a>
8000dcfc:	7b 00 00 28 	movh %d2,32768
8000dd00:	58 04       	ld.w %d15,[%sp]16
8000dd02:	1b f2 ff 3f 	addi %d3,%d2,-1
8000dd06:	6a 32       	cmovn %d2,%d15,%d3
8000dd08:	00 90       	ret 
8000dd0a:	19 a6 14 00 	ld.w %d6,[%sp]20
8000dd0e:	82 02       	mov %d2,0
8000dd10:	0e 6e       	jltz %d6,8000dd2c <__fixdfsi+0x4c>
8000dd12:	8b f6 81 f2 	ge %d15,%d6,31
8000dd16:	ee f3       	jnz %d15,8000dcfc <__fixdfsi+0x1c>
8000dd18:	09 a4 58 09 	ld.d %e4,[%sp]24
8000dd1c:	8b c6 03 61 	rsub %d6,%d6,60
8000dd20:	6d ff cb e0 	call 80009eb6 <__lshrdi3>
8000dd24:	58 04       	ld.w %d15,[%sp]16
8000dd26:	8b 02 00 41 	rsub %d4,%d2,0
8000dd2a:	2a 42       	cmov %d2,%d15,%d4
8000dd2c:	00 90       	ret 

8000dd2e <__udivdi3>:
8000dd2e:	0f 67 a0 20 	or %d2,%d7,%d6
8000dd32:	0b 45 10 a8 	mov %e10,%d5,%d4
8000dd36:	02 6f       	mov %d15,%d6
8000dd38:	02 7c       	mov %d12,%d7
8000dd3a:	d2 f8       	mov %e8,-1
8000dd3c:	df 02 46 00 	jeq %d2,0,8000ddc8 <__udivdi3+0x9a>
8000dd40:	8f 07 40 21 	or %d2,%d7,0
8000dd44:	f6 2d       	jnz %d2,8000dd5e <__udivdi3+0x30>
8000dd46:	4b 6b 11 82 	div.u %e8,%d11,%d6
8000dd4a:	d2 04       	mov %e4,0
8000dd4c:	02 a4       	mov %d4,%d10
8000dd4e:	42 95       	add %d5,%d9
8000dd50:	6d 00 a5 00 	call 8000de9a <__udiv6432>
8000dd54:	82 04       	mov %d4,0
8000dd56:	02 85       	mov %d5,%d8
8000dd58:	13 12 40 84 	madd.u %e8,%e4,%d2,1
8000dd5c:	3c 36       	j 8000ddc8 <__udivdi3+0x9a>
8000dd5e:	0b 7b 00 21 	eq %d2,%d11,%d7
8000dd62:	0b 64 30 22 	and.lt.u %d2,%d4,%d6
8000dd66:	0b 7b a0 22 	or.lt.u %d2,%d11,%d7
8000dd6a:	d2 08       	mov %e8,0
8000dd6c:	df 02 2e 80 	jne %d2,0,8000ddc8 <__udivdi3+0x9a>
8000dd70:	77 4b 80 5f 	dextr %d5,%d11,%d4,31
8000dd74:	0f 07 b0 d1 	clz %d13,%d7
8000dd78:	60 5f       	mov.a %a15,%d5
8000dd7a:	0b 67 10 48 	mov %e4,%d7,%d6
8000dd7e:	02 d6       	mov %d6,%d13
8000dd80:	6d ff bf e3 	call 8000a4fe <__ashldi3>
8000dd84:	8f fb 1f e0 	sh %d14,%d11,-1
8000dd88:	80 f4       	mov.d %d4,%a15
8000dd8a:	02 36       	mov %d6,%d3
8000dd8c:	02 e5       	mov %d5,%d14
8000dd8e:	6d 00 86 00 	call 8000de9a <__udiv6432>
8000dd92:	8b fd 01 d1 	rsub %d13,%d13,31
8000dd96:	8b 0d 00 31 	rsub %d3,%d13,0
8000dd9a:	0f 32 00 30 	sh %d3,%d2,%d3
8000dd9e:	02 32       	mov %d2,%d3
8000dda0:	8b f2 9f 80 	addx %d8,%d2,-1
8000dda4:	23 f8 68 aa 	msub.u %e10,%e10,%d8,%d15
8000dda8:	82 03       	mov %d3,0
8000ddaa:	8b f3 bf 90 	addc %d9,%d3,-1
8000ddae:	23 c8 0a bb 	msub %d11,%d11,%d8,%d12
8000ddb2:	23 f9 0a bb 	msub %d11,%d11,%d9,%d15
8000ddb6:	0b cb 00 41 	eq %d4,%d11,%d12
8000ddba:	0b fa 30 42 	and.lt.u %d4,%d10,%d15
8000ddbe:	0b cb a0 42 	or.lt.u %d4,%d11,%d12
8000ddc2:	f6 43       	jnz %d4,8000ddc8 <__udivdi3+0x9a>
8000ddc4:	0b 23 10 88 	mov %e8,%d3,%d2
8000ddc8:	0b 89 10 28 	mov %e2,%d9,%d8
8000ddcc:	00 90       	ret 

8000ddce <__umoddi3>:
8000ddce:	0f 67 a0 90 	or %d9,%d7,%d6
8000ddd2:	02 6f       	mov %d15,%d6
8000ddd4:	d2 00       	mov %e0,0
8000ddd6:	76 9c       	jz %d9,8000ddee <__umoddi3+0x20>
8000ddd8:	02 7a       	mov %d10,%d7
8000ddda:	0b 45 10 88 	mov %e8,%d5,%d4
8000ddde:	6d ff a8 ff 	call 8000dd2e <__udivdi3>
8000dde2:	23 f2 68 08 	msub.u %e0,%e8,%d2,%d15
8000dde6:	23 a2 0a 11 	msub %d1,%d1,%d2,%d10
8000ddea:	23 f3 0a 11 	msub %d1,%d1,%d3,%d15
8000ddee:	0b 01 10 28 	mov %e2,%d1,%d0
8000ddf2:	00 90       	ret 

8000ddf4 <__fpcmp_parts_d>:
8000ddf4:	14 43       	ld.bu %d3,[%a4]
8000ddf6:	82 12       	mov %d2,1
8000ddf8:	bf 23 50 80 	jlt.u %d3,2,8000de98 <__fpcmp_parts_d+0xa4>
8000ddfc:	0c 50       	ld.bu %d15,[%a5]0
8000ddfe:	bf 2f 4d 80 	jlt.u %d15,2,8000de98 <__fpcmp_parts_d+0xa4>
8000de02:	8b 43 00 42 	eq %d4,%d3,4
8000de06:	8b 4f 00 22 	eq %d2,%d15,4
8000de0a:	0f 24 80 50 	and %d5,%d4,%d2
8000de0e:	76 56       	jz %d5,8000de1a <__fpcmp_parts_d+0x26>
8000de10:	19 52 04 00 	ld.w %d2,[%a5]4
8000de14:	4c 41       	ld.w %d15,[%a4]4
8000de16:	a2 f2       	sub %d2,%d15
8000de18:	00 90       	ret 
8000de1a:	76 47       	jz %d4,8000de28 <__fpcmp_parts_d+0x34>
8000de1c:	19 42 04 00 	ld.w %d2,[%a4]4
8000de20:	82 1f       	mov %d15,1
8000de22:	ab ff bf 22 	seln %d2,%d2,%d15,-1
8000de26:	00 90       	ret 
8000de28:	76 27       	jz %d2,8000de36 <__fpcmp_parts_d+0x42>
8000de2a:	19 52 04 00 	ld.w %d2,[%a5]4
8000de2e:	82 ff       	mov %d15,-1
8000de30:	ab 1f a0 22 	seln %d2,%d2,%d15,1
8000de34:	00 90       	ret 
8000de36:	df 23 06 80 	jne %d3,2,8000de42 <__fpcmp_parts_d+0x4e>
8000de3a:	82 02       	mov %d2,0
8000de3c:	df 2f f7 ff 	jne %d15,2,8000de2a <__fpcmp_parts_d+0x36>
8000de40:	00 90       	ret 
8000de42:	df 2f ed 7f 	jeq %d15,2,8000de1c <__fpcmp_parts_d+0x28>
8000de46:	19 45 04 00 	ld.w %d5,[%a4]4
8000de4a:	4c 51       	ld.w %d15,[%a5]4
8000de4c:	5f f5 19 80 	jne %d5,%d15,8000de7e <__fpcmp_parts_d+0x8a>
8000de50:	19 42 08 00 	ld.w %d2,[%a4]8
8000de54:	4c 52       	ld.w %d15,[%a5]8
8000de56:	3f 2f 14 00 	jlt %d15,%d2,8000de7e <__fpcmp_parts_d+0x8a>
8000de5a:	3f f2 1c 00 	jlt %d2,%d15,8000de92 <__fpcmp_parts_d+0x9e>
8000de5e:	19 43 10 00 	ld.w %d3,[%a4]16
8000de62:	19 54 10 00 	ld.w %d4,[%a5]16
8000de66:	19 47 0c 00 	ld.w %d7,[%a4]12
8000de6a:	19 56 0c 00 	ld.w %d6,[%a5]12
8000de6e:	0b 43 00 21 	eq %d2,%d3,%d4
8000de72:	0b 76 50 22 	and.ge.u %d2,%d6,%d7
8000de76:	0b 43 a0 22 	or.lt.u %d2,%d3,%d4
8000de7a:	3a 43       	eq %d15,%d3,%d4
8000de7c:	f6 25       	jnz %d2,8000de86 <__fpcmp_parts_d+0x92>
8000de7e:	82 12       	mov %d2,1
8000de80:	ab f2 bf 25 	seln %d2,%d5,%d2,-1
8000de84:	00 90       	ret 
8000de86:	0b 67 50 f2 	and.ge.u %d15,%d7,%d6
8000de8a:	0b 34 a0 f2 	or.lt.u %d15,%d4,%d3
8000de8e:	82 02       	mov %d2,0
8000de90:	ee 04       	jnz %d15,8000de98 <__fpcmp_parts_d+0xa4>
8000de92:	82 f2       	mov %d2,-1
8000de94:	ab 12 a0 25 	seln %d2,%d5,%d2,1
8000de98:	00 90       	ret 

8000de9a <__udiv6432>:
8000de9a:	02 53       	mov %d3,%d5
8000de9c:	82 f2       	mov %d2,-1
8000de9e:	7f 65 4b 80 	jge.u %d5,%d6,8000df34 <__udiv6432+0x9a>
8000dea2:	0f 06 b0 21 	clz %d2,%d6
8000dea6:	0f 26 00 60 	sh %d6,%d6,%d2
8000deaa:	17 45 80 52 	dextr %d5,%d5,%d4,%d2
8000deae:	2b 35 40 32 	sel %d3,%d2,%d5,%d3
8000deb2:	8f 06 1f 70 	sh %d7,%d6,-16
8000deb6:	4b 73 11 02 	div.u %e0,%d3,%d7
8000deba:	b7 06 10 88 	insert %d8,%d6,0,16,16
8000debe:	0f 24 00 20 	sh %d2,%d4,%d2
8000dec2:	02 05       	mov %d5,%d0
8000dec4:	23 07 0a 13 	msub %d1,%d3,%d7,%d0
8000dec8:	e2 80       	mul %d0,%d8
8000deca:	8f 02 1f b0 	sh %d11,%d2,-16
8000dece:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000ded2:	82 0c       	mov %d12,0
8000ded4:	7b 10 00 90 	movh %d9,1
8000ded8:	7f 95 09 80 	jge.u %d5,%d9,8000deea <__udiv6432+0x50>
8000dedc:	8f 01 01 f0 	sh %d15,%d1,16
8000dee0:	0b 0c 00 a0 	add %d10,%d12,%d0
8000dee4:	42 bf       	add %d15,%d11
8000dee6:	7f af 07 80 	jge.u %d15,%d10,8000def4 <__udiv6432+0x5a>
8000deea:	42 71       	add %d1,%d7
8000deec:	c2 f5       	add %d5,-1
8000deee:	a2 8c       	sub %d12,%d8
8000def0:	3f 91 f4 ff 	jlt.u %d1,%d9,8000ded8 <__udiv6432+0x3e>
8000def4:	8f 03 01 30 	sh %d3,%d3,16
8000def8:	42 3b       	add %d11,%d3
8000defa:	23 65 0a 6b 	msub %d6,%d11,%d5,%d6
8000defe:	82 0a       	mov %d10,0
8000df00:	4b 76 11 02 	div.u %e0,%d6,%d7
8000df04:	7b 10 00 10 	movh %d1,1
8000df08:	02 03       	mov %d3,%d0
8000df0a:	23 07 0a 66 	msub %d6,%d6,%d7,%d0
8000df0e:	e2 80       	mul %d0,%d8
8000df10:	7f 13 09 80 	jge.u %d3,%d1,8000df22 <__udiv6432+0x88>
8000df14:	8f 06 01 f0 	sh %d15,%d6,16
8000df18:	0b 0a 00 90 	add %d9,%d10,%d0
8000df1c:	42 2f       	add %d15,%d2
8000df1e:	7f 9f 07 80 	jge.u %d15,%d9,8000df2c <__udiv6432+0x92>
8000df22:	42 76       	add %d6,%d7
8000df24:	c2 f3       	add %d3,-1
8000df26:	a2 8a       	sub %d10,%d8
8000df28:	3f 16 f4 ff 	jlt.u %d6,%d1,8000df10 <__udiv6432+0x76>
8000df2c:	8f 05 01 50 	sh %d5,%d5,16
8000df30:	0b 53 00 20 	add %d2,%d3,%d5
8000df34:	00 90       	ret 
	...
